/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./cell.js":
/*!*****************!*\
  !*** ./cell.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Wall = __webpack_require__(/*! ./wall */ \"./wall.js\");\n\nfunction Cell(row, col, grid) {\n    this.row = row;\n    this.col = col;\n    this.grid = grid;\n    this.walls = [new Wall(), new Wall(), new Wall(), new Wall()];\n    // this.walls = []\n    this.visited = false;\n\n    // [1, 2, 3, 4].forEach(() => this.walls.push(new Wall()));\n\n    this.highlight = function(){\n        // console.log(this.row, this.col);\n        const startRow = this.row * 40;\n        const startCol = this.col * 40;\n        noStroke();\n        fill(\"purple\");\n        rect(startRow, startCol, 40, 40)\n    }\n\n    this.render = function () {\n        const startRow = this.row * 40;\n        const startCol = this.col * 40;\n\n        // x, y, width, height\n        // rect(startX, startY, 40, 40)\n        // noFill();\n        \n        for (let i = 0; i < this.walls.length; i++) {\n            if(this.walls[i].present){\n                this.walls[i].render(i, startRow, startCol);\n            } else {\n                this.walls[i].derender(i, startRow, startCol);\n            }\n        }\n        \n        \n        if (this.visited) {\n            noStroke();\n            fill(\"white\");\n            rect(startRow+1, startCol+1, 38, 38)\n        }\n\n        \n    }\n\n\n    this.getNeighbor = function () {\n\n        // const neighborsIndices = [\n        //     [row - 1, col],\n        //     [row + 1, col],\n        //     [row, col - 1],\n        //     [row, col + 1]            \n        // ]\n        // console.log(row)\n        // console.log(col)\n        // console.log(grid)\n\n        const top = grid[row - 1];\n        const right = grid[row + 1];\n        const bottom = grid[row];\n        const left = grid[row];\n\n        const neighbors = []\n\n        if(top){\n            neighbors.push(grid[row - 1][col]);\n        }\n\n        if(right){\n            neighbors.push(grid[row + 1][col]);\n        }\n\n        if (bottom) {\n            neighbors.push(grid[row][col - 1]);\n        }\n\n        if (left) {\n            neighbors.push(grid[row][col + 1]);\n        }\n\n\n        // const neighbors = [\n        //     grid[row - 1][col],\n        //     grid[row + 1][col],\n        //     grid[row][col - 1],\n        //     grid[row][col + 1]\n        // ]\n        //  const neighborsIndices = [\n        //     [row - 1, col],\n        //     [row + 1, col],\n        //     [row, col - 1],\n        //     [row, col + 1]            \n        // ]\n\n        // const neighbors = [];\n        \n        // const validateIdx = function (idx) {\n        //     idx >= 0 && idx < 20\n        // }\n        // for(let i = 0; i < neighborsIndices.length; i++){\n        //     if(validateIdx(neighborsIndices[i][0]) && validateIdx(neighborsIndices[i][1])){\n        //         neighbors.push(grid[neighborsIndices[i][0]][neighborsIndices[i][1]])\n        //     }\n        // }\n\n\n        // let top = [(row - 1), col];\n        // validateIdx(top);\n        // let right = [row, (col+1)];\n        // validateIdx(right);\n        // let bottom = [(row + 1), col];\n        // validateIdx(bottom);\n        // let left = [row, (col - 1)];\n        // validateIdx(left);\n        // console.log(\"neighbors\")\n        // console.log(neighbors)\n\n        const validNeighbors = [];\n\n        // for(let i = 0; i < neighbors.length; i++){\n        //     if ((neighbors[i][0] < 20 && neighbors[i][0] >= 0) && (neighbors[i][1] < 20 && neighbors[i][1] >= 0)) {\n        //         validNeighbors.push(neighbors[i]);\n        //     }\n        // }\n\n        // const validNeighbors = neighbors.filter(neighbor => {\n        //     // let x = neighbor[0];\n        //     // let y = neighbor[1];\n\n        //     if((neighbor[0] < 20 && neighbor[0] >= 0) && (neighbor[1] < 20 && neighbor[1] >= 0)){\n        //         return neighbor;\n        //     }\n        // }\n\n        // const validateNeighbors = function(neighbor) {\n        //     if(!neighbor){\n        //         return false;\n        //     }\n        //     // let x = neighbor[0];\n        //     // let y = neighbor[1];\n\n        //     if(neighbor.row < 20 || neighbor.row >=0){\n        //         return false;\n        //     } else if(neighbor.col < 20 || neighbor.col >= 0){\n        //         return false;\n        //     } else{\n        //         return true\n        //     }\n\n        // }\n\n        // const validateNeighbors = function(neighbor){\n        //     console.log(neighbor)\n        //     neighbor\n        // }\n\n        // const validNeighbors = neighbors.filter(validateNeighbors);\n\n        // for (let i = 0; i < neighbors.length; i++) {\n        //     if (neighbors[i] && !(neighbors[i].visited)) {\n        //         if(neighbors[i].row < 20 && neighbors[i].row >=0){\n        //             if(neighbors[i].col < 20 && neighbors[i].col >= 0){\n\n        //                 validNeighbors.push(neighbors[i])\n        //             }\n        //         }\n        //     }\n        // }\n\n          for (let i = 0; i < neighbors.length; i++) {\n            if (neighbors[i] && !(neighbors[i].visited)) {\n                // if(neighbors[i].row < 20 && neighbors[i].row >=0){\n                //     if(neighbors[i].col < 20 && neighbors[i].col >= 0){\n\n                        validNeighbors.push(neighbors[i])\n                    // }\n                // }\n            }\n        }\n\n\n        // console.log(\"valid\")\n        // console.log(validNeighbors)\n\n        let nextCell;\n\n        if (validNeighbors.length > 0) {\n            nextCell = this.chooseRandomNeighbor(validNeighbors);\n            return nextCell;\n        } else{\n            return undefined;\n        }\n        // let nextCell = \n\n        // //need to check if nextCell is true bc it could be undefined at the edges\n        // while(nextCell && nextCell.visited){\n        //     nextCell = this.chooseRandomNeighbor(neighbors)\n\n        //     if(nextCell && !nextCell.visited){\n        //         return nextCell\n        //     }\n        // }\n\n        // if (nextCell) {\n        //     rect(startRow, startCol, 40, 40)\n        //     fill(\"purple\");\n        // }\n        // console.log(nextCell)\n        // return nextCell;\n\n    }\n\n    this.chooseRandomNeighbor = function (validNeighbors) {\n        return validNeighbors[Math.floor(Math.random() * validNeighbors.length)]\n    }\n\n}\n\nmodule.exports = Cell;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jZWxsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vY2VsbC5qcz9kYjFkIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFdhbGwgPSByZXF1aXJlKCcuL3dhbGwnKTtcblxuZnVuY3Rpb24gQ2VsbChyb3csIGNvbCwgZ3JpZCkge1xuICAgIHRoaXMucm93ID0gcm93O1xuICAgIHRoaXMuY29sID0gY29sO1xuICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG4gICAgdGhpcy53YWxscyA9IFtuZXcgV2FsbCgpLCBuZXcgV2FsbCgpLCBuZXcgV2FsbCgpLCBuZXcgV2FsbCgpXTtcbiAgICAvLyB0aGlzLndhbGxzID0gW11cbiAgICB0aGlzLnZpc2l0ZWQgPSBmYWxzZTtcblxuICAgIC8vIFsxLCAyLCAzLCA0XS5mb3JFYWNoKCgpID0+IHRoaXMud2FsbHMucHVzaChuZXcgV2FsbCgpKSk7XG5cbiAgICB0aGlzLmhpZ2hsaWdodCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMucm93LCB0aGlzLmNvbCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0Um93ID0gdGhpcy5yb3cgKiA0MDtcbiAgICAgICAgY29uc3Qgc3RhcnRDb2wgPSB0aGlzLmNvbCAqIDQwO1xuICAgICAgICBub1N0cm9rZSgpO1xuICAgICAgICBmaWxsKFwicHVycGxlXCIpO1xuICAgICAgICByZWN0KHN0YXJ0Um93LCBzdGFydENvbCwgNDAsIDQwKVxuICAgIH1cblxuICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBzdGFydFJvdyA9IHRoaXMucm93ICogNDA7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q29sID0gdGhpcy5jb2wgKiA0MDtcblxuICAgICAgICAvLyB4LCB5LCB3aWR0aCwgaGVpZ2h0XG4gICAgICAgIC8vIHJlY3Qoc3RhcnRYLCBzdGFydFksIDQwLCA0MClcbiAgICAgICAgLy8gbm9GaWxsKCk7XG4gICAgICAgIFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMud2FsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmKHRoaXMud2FsbHNbaV0ucHJlc2VudCl7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxsc1tpXS5yZW5kZXIoaSwgc3RhcnRSb3csIHN0YXJ0Q29sKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxsc1tpXS5kZXJlbmRlcihpLCBzdGFydFJvdywgc3RhcnRDb2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgaWYgKHRoaXMudmlzaXRlZCkge1xuICAgICAgICAgICAgbm9TdHJva2UoKTtcbiAgICAgICAgICAgIGZpbGwoXCJ3aGl0ZVwiKTtcbiAgICAgICAgICAgIHJlY3Qoc3RhcnRSb3crMSwgc3RhcnRDb2wrMSwgMzgsIDM4KVxuICAgICAgICB9XG5cbiAgICAgICAgXG4gICAgfVxuXG5cbiAgICB0aGlzLmdldE5laWdoYm9yID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8vIGNvbnN0IG5laWdoYm9yc0luZGljZXMgPSBbXG4gICAgICAgIC8vICAgICBbcm93IC0gMSwgY29sXSxcbiAgICAgICAgLy8gICAgIFtyb3cgKyAxLCBjb2xdLFxuICAgICAgICAvLyAgICAgW3JvdywgY29sIC0gMV0sXG4gICAgICAgIC8vICAgICBbcm93LCBjb2wgKyAxXSAgICAgICAgICAgIFxuICAgICAgICAvLyBdXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHJvdylcbiAgICAgICAgLy8gY29uc29sZS5sb2coY29sKVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhncmlkKVxuXG4gICAgICAgIGNvbnN0IHRvcCA9IGdyaWRbcm93IC0gMV07XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gZ3JpZFtyb3cgKyAxXTtcbiAgICAgICAgY29uc3QgYm90dG9tID0gZ3JpZFtyb3ddO1xuICAgICAgICBjb25zdCBsZWZ0ID0gZ3JpZFtyb3ddO1xuXG4gICAgICAgIGNvbnN0IG5laWdoYm9ycyA9IFtdXG5cbiAgICAgICAgaWYodG9wKXtcbiAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKGdyaWRbcm93IC0gMV1bY29sXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihyaWdodCl7XG4gICAgICAgICAgICBuZWlnaGJvcnMucHVzaChncmlkW3JvdyArIDFdW2NvbF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJvdHRvbSkge1xuICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goZ3JpZFtyb3ddW2NvbCAtIDFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZWZ0KSB7XG4gICAgICAgICAgICBuZWlnaGJvcnMucHVzaChncmlkW3Jvd11bY29sICsgMV0pO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBjb25zdCBuZWlnaGJvcnMgPSBbXG4gICAgICAgIC8vICAgICBncmlkW3JvdyAtIDFdW2NvbF0sXG4gICAgICAgIC8vICAgICBncmlkW3JvdyArIDFdW2NvbF0sXG4gICAgICAgIC8vICAgICBncmlkW3Jvd11bY29sIC0gMV0sXG4gICAgICAgIC8vICAgICBncmlkW3Jvd11bY29sICsgMV1cbiAgICAgICAgLy8gXVxuICAgICAgICAvLyAgY29uc3QgbmVpZ2hib3JzSW5kaWNlcyA9IFtcbiAgICAgICAgLy8gICAgIFtyb3cgLSAxLCBjb2xdLFxuICAgICAgICAvLyAgICAgW3JvdyArIDEsIGNvbF0sXG4gICAgICAgIC8vICAgICBbcm93LCBjb2wgLSAxXSxcbiAgICAgICAgLy8gICAgIFtyb3csIGNvbCArIDFdICAgICAgICAgICAgXG4gICAgICAgIC8vIF1cblxuICAgICAgICAvLyBjb25zdCBuZWlnaGJvcnMgPSBbXTtcbiAgICAgICAgXG4gICAgICAgIC8vIGNvbnN0IHZhbGlkYXRlSWR4ID0gZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAvLyAgICAgaWR4ID49IDAgJiYgaWR4IDwgMjBcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBmb3IobGV0IGkgPSAwOyBpIDwgbmVpZ2hib3JzSW5kaWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIC8vICAgICBpZih2YWxpZGF0ZUlkeChuZWlnaGJvcnNJbmRpY2VzW2ldWzBdKSAmJiB2YWxpZGF0ZUlkeChuZWlnaGJvcnNJbmRpY2VzW2ldWzFdKSl7XG4gICAgICAgIC8vICAgICAgICAgbmVpZ2hib3JzLnB1c2goZ3JpZFtuZWlnaGJvcnNJbmRpY2VzW2ldWzBdXVtuZWlnaGJvcnNJbmRpY2VzW2ldWzFdXSlcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuXG5cbiAgICAgICAgLy8gbGV0IHRvcCA9IFsocm93IC0gMSksIGNvbF07XG4gICAgICAgIC8vIHZhbGlkYXRlSWR4KHRvcCk7XG4gICAgICAgIC8vIGxldCByaWdodCA9IFtyb3csIChjb2wrMSldO1xuICAgICAgICAvLyB2YWxpZGF0ZUlkeChyaWdodCk7XG4gICAgICAgIC8vIGxldCBib3R0b20gPSBbKHJvdyArIDEpLCBjb2xdO1xuICAgICAgICAvLyB2YWxpZGF0ZUlkeChib3R0b20pO1xuICAgICAgICAvLyBsZXQgbGVmdCA9IFtyb3csIChjb2wgLSAxKV07XG4gICAgICAgIC8vIHZhbGlkYXRlSWR4KGxlZnQpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIm5laWdoYm9yc1wiKVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhuZWlnaGJvcnMpXG5cbiAgICAgICAgY29uc3QgdmFsaWROZWlnaGJvcnMgPSBbXTtcblxuICAgICAgICAvLyBmb3IobGV0IGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgLy8gICAgIGlmICgobmVpZ2hib3JzW2ldWzBdIDwgMjAgJiYgbmVpZ2hib3JzW2ldWzBdID49IDApICYmIChuZWlnaGJvcnNbaV1bMV0gPCAyMCAmJiBuZWlnaGJvcnNbaV1bMV0gPj0gMCkpIHtcbiAgICAgICAgLy8gICAgICAgICB2YWxpZE5laWdoYm9ycy5wdXNoKG5laWdoYm9yc1tpXSk7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBjb25zdCB2YWxpZE5laWdoYm9ycyA9IG5laWdoYm9ycy5maWx0ZXIobmVpZ2hib3IgPT4ge1xuICAgICAgICAvLyAgICAgLy8gbGV0IHggPSBuZWlnaGJvclswXTtcbiAgICAgICAgLy8gICAgIC8vIGxldCB5ID0gbmVpZ2hib3JbMV07XG5cbiAgICAgICAgLy8gICAgIGlmKChuZWlnaGJvclswXSA8IDIwICYmIG5laWdoYm9yWzBdID49IDApICYmIChuZWlnaGJvclsxXSA8IDIwICYmIG5laWdoYm9yWzFdID49IDApKXtcbiAgICAgICAgLy8gICAgICAgICByZXR1cm4gbmVpZ2hib3I7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBjb25zdCB2YWxpZGF0ZU5laWdoYm9ycyA9IGZ1bmN0aW9uKG5laWdoYm9yKSB7XG4gICAgICAgIC8vICAgICBpZighbmVpZ2hib3Ipe1xuICAgICAgICAvLyAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gICAgIC8vIGxldCB4ID0gbmVpZ2hib3JbMF07XG4gICAgICAgIC8vICAgICAvLyBsZXQgeSA9IG5laWdoYm9yWzFdO1xuXG4gICAgICAgIC8vICAgICBpZihuZWlnaGJvci5yb3cgPCAyMCB8fCBuZWlnaGJvci5yb3cgPj0wKXtcbiAgICAgICAgLy8gICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vICAgICB9IGVsc2UgaWYobmVpZ2hib3IuY29sIDwgMjAgfHwgbmVpZ2hib3IuY29sID49IDApe1xuICAgICAgICAvLyAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gICAgIH0gZWxzZXtcbiAgICAgICAgLy8gICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAvLyAgICAgfVxuXG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBjb25zdCB2YWxpZGF0ZU5laWdoYm9ycyA9IGZ1bmN0aW9uKG5laWdoYm9yKXtcbiAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKG5laWdoYm9yKVxuICAgICAgICAvLyAgICAgbmVpZ2hib3JcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGNvbnN0IHZhbGlkTmVpZ2hib3JzID0gbmVpZ2hib3JzLmZpbHRlcih2YWxpZGF0ZU5laWdoYm9ycyk7XG5cbiAgICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gICAgIGlmIChuZWlnaGJvcnNbaV0gJiYgIShuZWlnaGJvcnNbaV0udmlzaXRlZCkpIHtcbiAgICAgICAgLy8gICAgICAgICBpZihuZWlnaGJvcnNbaV0ucm93IDwgMjAgJiYgbmVpZ2hib3JzW2ldLnJvdyA+PTApe1xuICAgICAgICAvLyAgICAgICAgICAgICBpZihuZWlnaGJvcnNbaV0uY29sIDwgMjAgJiYgbmVpZ2hib3JzW2ldLmNvbCA+PSAwKXtcblxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgdmFsaWROZWlnaGJvcnMucHVzaChuZWlnaGJvcnNbaV0pXG4gICAgICAgIC8vICAgICAgICAgICAgIH1cbiAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobmVpZ2hib3JzW2ldICYmICEobmVpZ2hib3JzW2ldLnZpc2l0ZWQpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYobmVpZ2hib3JzW2ldLnJvdyA8IDIwICYmIG5laWdoYm9yc1tpXS5yb3cgPj0wKXtcbiAgICAgICAgICAgICAgICAvLyAgICAgaWYobmVpZ2hib3JzW2ldLmNvbCA8IDIwICYmIG5laWdoYm9yc1tpXS5jb2wgPj0gMCl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkTmVpZ2hib3JzLnB1c2gobmVpZ2hib3JzW2ldKVxuICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcInZhbGlkXCIpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHZhbGlkTmVpZ2hib3JzKVxuXG4gICAgICAgIGxldCBuZXh0Q2VsbDtcblxuICAgICAgICBpZiAodmFsaWROZWlnaGJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbmV4dENlbGwgPSB0aGlzLmNob29zZVJhbmRvbU5laWdoYm9yKHZhbGlkTmVpZ2hib3JzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0Q2VsbDtcbiAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBsZXQgbmV4dENlbGwgPSBcblxuICAgICAgICAvLyAvL25lZWQgdG8gY2hlY2sgaWYgbmV4dENlbGwgaXMgdHJ1ZSBiYyBpdCBjb3VsZCBiZSB1bmRlZmluZWQgYXQgdGhlIGVkZ2VzXG4gICAgICAgIC8vIHdoaWxlKG5leHRDZWxsICYmIG5leHRDZWxsLnZpc2l0ZWQpe1xuICAgICAgICAvLyAgICAgbmV4dENlbGwgPSB0aGlzLmNob29zZVJhbmRvbU5laWdoYm9yKG5laWdoYm9ycylcblxuICAgICAgICAvLyAgICAgaWYobmV4dENlbGwgJiYgIW5leHRDZWxsLnZpc2l0ZWQpe1xuICAgICAgICAvLyAgICAgICAgIHJldHVybiBuZXh0Q2VsbFxuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gaWYgKG5leHRDZWxsKSB7XG4gICAgICAgIC8vICAgICByZWN0KHN0YXJ0Um93LCBzdGFydENvbCwgNDAsIDQwKVxuICAgICAgICAvLyAgICAgZmlsbChcInB1cnBsZVwiKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhuZXh0Q2VsbClcbiAgICAgICAgLy8gcmV0dXJuIG5leHRDZWxsO1xuXG4gICAgfVxuXG4gICAgdGhpcy5jaG9vc2VSYW5kb21OZWlnaGJvciA9IGZ1bmN0aW9uICh2YWxpZE5laWdoYm9ycykge1xuICAgICAgICByZXR1cm4gdmFsaWROZWlnaGJvcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdmFsaWROZWlnaGJvcnMubGVuZ3RoKV1cbiAgICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./cell.js\n");

/***/ }),

/***/ "./game.js":
/*!*****************!*\
  !*** ./game.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const User = __webpack_require__(/*! ./user */ \"./user.js\");\n\nfunction Game(){\n    this.user = new User();\n    this.end = [19, 19];\n    // this.userPos = [0, 0];\n\n    this.userRender = function(){\n        this.user.render(this.user.pos[0], this.user.pos[1]);\n    }\n\n    this.play = function(){\n        this.userMove();\n    }\n\n    this.end = function(userPos){\n        this.user.pos === this.end\n    }\n\n    this.userMove = function(){\n\n        let userPos = this.user.pos;\n        let x = userPos[0];\n        let y = userPos[1];\n        // const keypress = event.keyCode;\n        // console.log(event);\n        if (keyIsDown(LEFT_ARROW)) {\n            // console.log(this.user.pos)\n            this.user.updatePos([\"y\", -40]);\n            this.user.render(this.user.pos[0], this.user.pos[1]);\n        }\n    \n        if (keyIsDown(RIGHT_ARROW)) {\n            this.user.updatePos([\"y\", 40]);\n            this.user.render(this.user.pos[0], this.user.pos[1]);\n        }\n    \n        if (keyIsDown(UP_ARROW)) {\n            this.user.updatePos([\"x\", -40]);\n            this.user.render(this.user.pos[0], this.user.pos[1]);\n        }\n    \n        if (keyIsDown(DOWN_ARROW)) {\n            this.user.updatePos([\"x\", 40]);\n            this.user.render(this.user.pos[0], this.user.pos[1]);\n        }\n        \n        // this.user.update();\n        // this.user.display();\n        // const colors = [\"lightcoral\", \"orange\", \"Chartreuse\", \"darkcyan\", \"darkorchid\"];\n        // let currentColor = colors[Math.floor(Math.random() * colors.length)];\n        \n        // fill(currentColor);\n        // ellipse(19, 19, 15, 15);\n    }\n\n}\n\nmodule.exports = Game;\n//     this.xDimen = 900;\n//     this.yDimen = 900;\n//     this.cells = [];\n// }\n\n// Game.prototype.render = function(canvas){\n//     Game.setUp()\n// })\n\n// Game.prototype.setUp = function(mazeCanvas){\n//     const canvas = mazeCanvas.getContext(\"2d\");\n\n//     canvas.fillStyle = \"purple\";\n//     //x, y, width, height\n//     canvas.fillRect(0, 0, 800, 800);\n\n//     cols = 10; //each will be 8 x 8\n//     rows = 10;\n\n//     for(let rowNum = 0; rowNum < rows; rowNum++){\n//         for (let colNum = 0; colNum < cols, colNum++){\n//             cells.push(new Cell(rowNum, colNum))\n//         }\n//     }\n\n//     for(let i = 0; i < this.cells.length; i++){\n        \n//     }//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9nYW1lLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZ2FtZS5qcz8zNjU3Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFVzZXIgPSByZXF1aXJlKCcuL3VzZXInKTtcblxuZnVuY3Rpb24gR2FtZSgpe1xuICAgIHRoaXMudXNlciA9IG5ldyBVc2VyKCk7XG4gICAgdGhpcy5lbmQgPSBbMTksIDE5XTtcbiAgICAvLyB0aGlzLnVzZXJQb3MgPSBbMCwgMF07XG5cbiAgICB0aGlzLnVzZXJSZW5kZXIgPSBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLnVzZXIucmVuZGVyKHRoaXMudXNlci5wb3NbMF0sIHRoaXMudXNlci5wb3NbMV0pO1xuICAgIH1cblxuICAgIHRoaXMucGxheSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMudXNlck1vdmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLmVuZCA9IGZ1bmN0aW9uKHVzZXJQb3Mpe1xuICAgICAgICB0aGlzLnVzZXIucG9zID09PSB0aGlzLmVuZFxuICAgIH1cblxuICAgIHRoaXMudXNlck1vdmUgPSBmdW5jdGlvbigpe1xuXG4gICAgICAgIGxldCB1c2VyUG9zID0gdGhpcy51c2VyLnBvcztcbiAgICAgICAgbGV0IHggPSB1c2VyUG9zWzBdO1xuICAgICAgICBsZXQgeSA9IHVzZXJQb3NbMV07XG4gICAgICAgIC8vIGNvbnN0IGtleXByZXNzID0gZXZlbnQua2V5Q29kZTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coZXZlbnQpO1xuICAgICAgICBpZiAoa2V5SXNEb3duKExFRlRfQVJST1cpKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnVzZXIucG9zKVxuICAgICAgICAgICAgdGhpcy51c2VyLnVwZGF0ZVBvcyhbXCJ5XCIsIC00MF0pO1xuICAgICAgICAgICAgdGhpcy51c2VyLnJlbmRlcih0aGlzLnVzZXIucG9zWzBdLCB0aGlzLnVzZXIucG9zWzFdKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBpZiAoa2V5SXNEb3duKFJJR0hUX0FSUk9XKSkge1xuICAgICAgICAgICAgdGhpcy51c2VyLnVwZGF0ZVBvcyhbXCJ5XCIsIDQwXSk7XG4gICAgICAgICAgICB0aGlzLnVzZXIucmVuZGVyKHRoaXMudXNlci5wb3NbMF0sIHRoaXMudXNlci5wb3NbMV0pO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGlmIChrZXlJc0Rvd24oVVBfQVJST1cpKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXIudXBkYXRlUG9zKFtcInhcIiwgLTQwXSk7XG4gICAgICAgICAgICB0aGlzLnVzZXIucmVuZGVyKHRoaXMudXNlci5wb3NbMF0sIHRoaXMudXNlci5wb3NbMV0pO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGlmIChrZXlJc0Rvd24oRE9XTl9BUlJPVykpIHtcbiAgICAgICAgICAgIHRoaXMudXNlci51cGRhdGVQb3MoW1wieFwiLCA0MF0pO1xuICAgICAgICAgICAgdGhpcy51c2VyLnJlbmRlcih0aGlzLnVzZXIucG9zWzBdLCB0aGlzLnVzZXIucG9zWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gdGhpcy51c2VyLnVwZGF0ZSgpO1xuICAgICAgICAvLyB0aGlzLnVzZXIuZGlzcGxheSgpO1xuICAgICAgICAvLyBjb25zdCBjb2xvcnMgPSBbXCJsaWdodGNvcmFsXCIsIFwib3JhbmdlXCIsIFwiQ2hhcnRyZXVzZVwiLCBcImRhcmtjeWFuXCIsIFwiZGFya29yY2hpZFwiXTtcbiAgICAgICAgLy8gbGV0IGN1cnJlbnRDb2xvciA9IGNvbG9yc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjb2xvcnMubGVuZ3RoKV07XG4gICAgICAgIFxuICAgICAgICAvLyBmaWxsKGN1cnJlbnRDb2xvcik7XG4gICAgICAgIC8vIGVsbGlwc2UoMTksIDE5LCAxNSwgMTUpO1xuICAgIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWU7XG4vLyAgICAgdGhpcy54RGltZW4gPSA5MDA7XG4vLyAgICAgdGhpcy55RGltZW4gPSA5MDA7XG4vLyAgICAgdGhpcy5jZWxscyA9IFtdO1xuLy8gfVxuXG4vLyBHYW1lLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihjYW52YXMpe1xuLy8gICAgIEdhbWUuc2V0VXAoKVxuLy8gfSlcblxuLy8gR2FtZS5wcm90b3R5cGUuc2V0VXAgPSBmdW5jdGlvbihtYXplQ2FudmFzKXtcbi8vICAgICBjb25zdCBjYW52YXMgPSBtYXplQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuLy8gICAgIGNhbnZhcy5maWxsU3R5bGUgPSBcInB1cnBsZVwiO1xuLy8gICAgIC8veCwgeSwgd2lkdGgsIGhlaWdodFxuLy8gICAgIGNhbnZhcy5maWxsUmVjdCgwLCAwLCA4MDAsIDgwMCk7XG5cbi8vICAgICBjb2xzID0gMTA7IC8vZWFjaCB3aWxsIGJlIDggeCA4XG4vLyAgICAgcm93cyA9IDEwO1xuXG4vLyAgICAgZm9yKGxldCByb3dOdW0gPSAwOyByb3dOdW0gPCByb3dzOyByb3dOdW0rKyl7XG4vLyAgICAgICAgIGZvciAobGV0IGNvbE51bSA9IDA7IGNvbE51bSA8IGNvbHMsIGNvbE51bSsrKXtcbi8vICAgICAgICAgICAgIGNlbGxzLnB1c2gobmV3IENlbGwocm93TnVtLCBjb2xOdW0pKVxuLy8gICAgICAgICB9XG4vLyAgICAgfVxuXG4vLyAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuY2VsbHMubGVuZ3RoOyBpKyspe1xuICAgICAgICBcbi8vICAgICB9Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./game.js\n");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Cell = __webpack_require__(/*! ./cell */ \"./cell.js\");\n// const MovingObject = require('./moving_objects');\n// const User = require('./user');\nconst Game = __webpack_require__(/*! ./game */ \"./game.js\");\nconst Maze = __webpack_require__(/*! ./maze */ \"./maze.js\");\n\n// window.MovingObject = MovingObject;\n\nconst grid = [];\n\nlet current;\n\nconst stack = [];\n\nlet game = new Game();\nwindow.addEventListener(\"keypress\", (event) => (game.userMove(event)));\n\n\nlet maze;\n\nlet mapComplete = false;\n\n// const user = new User();\n\nfunction setup() {\n  createCanvas(800, 800);\n//   cols = 10;\n//   rows = 10;\n\n  for(let x = 0; x < 20; x++){\n      grid[x] = [];\n      for(let y = 0; y < 20; y++){\n        grid[x].push(new Cell(x, y, grid, stack))\n      }\n  }\n\n  let current_row = Math.floor(Math.random() * 20);\n  let current_col = Math.floor(Math.random() * 20);\n\n  current = grid[current_row][current_col];\n  maze = new Maze(current, grid, game)\n\n  //   console.log(\"current\")\n//   console.log(current)\n  \n  frameRate(100);\n  \n}\n\n// const maze = new Maze(current, grid);\n\nfunction draw() {\n    // if(!mapComplete){\n    maze.draw();\n        // mapComplete = maze.mapComplete();\n    // }\n    console.log(\"finish maze\")\n    game.userMove();\n    game.userRender();\n    // game.userRender(0, 0);\n\n    // const keypress = event.keyCode;\n    // console.log(event);\n\n\n    // game.userMove();\n    // game.user.draw();\n\n    // loop();\n    // background(51)\n\n    // if(!map && !gameEnd){\n    //     if (current) {\n    //         current.visited = true;\n    //     // current.highlight();\n    //         stack.push(current);\n    //     }\n    \n    \n    //     // let nextCell = current.getNextCell(current.row, current.col);\n    //     let nextCell = current.getNeighbor();\n    \n    //     // console.log(\"nextcell\")\n    //     // console.log(nextCell);\n        \n    //     this.removeWalls = function(current, next, grid){\n    //         const changeX = current.row - next.row;\n    //         const changeY = current.col - next.col;\n\n    \n    //         switch(changeX){\n    //             case 1:\n    //                 current.walls[0].present = false;  \n    //                 next.walls[2].present = false;\n    //                 break;\n    //             case -1:\n    //                 current.walls[2].present = false;\n    //                 next.walls[0].present = false;\n    //                 break;\n    //         }\n    \n    //         switch (changeY) {\n    //             case 1:\n    //                 current.walls[3].present = false;\n    //                 next.walls[1].present = false;\n    //                 break;\n    //             case -1:\n    //                 current.walls[1].present = false;\n    //                 next.walls[3].present = false;\n    //                 break;\n    //         }\n    \n    //         // const firstRow = grid[0];\n    //         // const lastRow = grid[19];\n    \n    //         // for (let i = 0; i < firstRow.length; i++) {\n    //         //     firstRow[i].walls[3].present = true\n    //         // }\n    \n    //         // for (let i = 0; i < lastRow.length; i++) {\n    //         //     lastRow[i].walls[1].present = true\n    //         // }\n    \n    //         // const firstCol = grid.filter((cell) => {\n    //         //     return cell.col === 0\n    //         // })\n    \n    //         // const lastCol = grid.filter((cell) => {\n    //         //     return cell.col === 19\n    //         // })\n    \n    //         // for (let i = 0; i < firstCol.length; i++) {\n    //         //     firstCol[i].walls[2].present = true;\n    //         // }\n    \n    //         // for (let i = 0; i < lastCol.length; i++) {\n    //         //     lastCol[i].walls[0].present = true;\n    //         // }\n    //     } \n    \n    //     if(nextCell){\n    //         nextCell.visited = true;\n    //         this.removeWalls(current, nextCell, grid);\n    //         current = nextCell;\n    //         // console.log(\"stack\")\n    //         // console.log(stack);\n    //     } else if(stack.length > 0){\n    //         potentialRestart = stack.pop()\n    //             while (potentialRestart && !potentialRestart.getNeighbor()){\n    //                 if(!stack.length){\n    //                     potentialRestart.visited = true\n    //                     map = true;\n    //                     noLoop();\n    //                     break;\n    //                 } else {\n    //                     potentialRestart = stack.pop();\n    //                 }\n    //             }\n    //             current = potentialRestart;\n    //             // console.log(current)\n    //     // } else if(allVisited) {\n    //     //     noLoop();\n    //     }\n    \n    \n    //     for (let i = 0; i < grid.length; i++) {\n    //         for (let j = 0; j < grid[i].length; j++) {\n    //             grid[i][j].render();\n    //         }\n    //     }\n\n    //     game.userRender();\n    // } else if(map && !gameEnd){\n    //     // loop()\n    //     console.log(\"hi\")\n    //     game.userRender();\n    //     // game.userMove();\n    //     keyPressed();\n        \n    //     for (let i = 0; i < grid.length; i++) {\n    //         for (let j = 0; j < grid[i].length; j++) {\n    //             grid[i][j].render();\n    //         }\n    //     }\n        \n    // }\n    \n    // // current.highlight();\n    \n    // function keyPressed(){\n    //     // loop();\n    //     game.userMove();\n    //     // loop()        \n    //     return false;\n    // }\n\n    // keyPressed();\n\n    // // user.render();\n\n    \n\n    // // redraw();\n    \n    // // while (!game.end()){\n    // //     game.userMove()\n    // // }\n\n}\n\n\n// function Cell(row, col) {\n//     this.row = row;\n//     this.col = col;\n//     this.walls = [new Wall(), new Wall(), new Wall(), new Wall()];\n//     this.visited = false;\n\n//     this.render = function () {\n//         const startRow = this.row * 40;\n//         const startCol = this.col * 40;\n\n//         // x, y, width, height\n//         // rect(startX, startY, 40, 40)\n//         // noFill();\n//         for(let i = 0; i < this.walls.length; i++){\n//             this.walls[i].render(i, startRow, startCol);\n//         }\n\n//         if(this.visited){\n//             rect(startRow, startCol, 40, 40)\n//             fill(\"green\");\n//         }\n        \n//     }\n\n//     this.getNeighbor = function(){\n        \n//         // const neighborsIndices = [\n//         //     [row - 1, col],\n//         //     [row + 1, col],\n//         //     [row, col - 1],\n//         //     [row, col + 1]            \n//         // ]\n\n//         const neighbors = [\n//             grid[row - 1][col],\n//             grid[row + 1][col],\n//             grid[row][col - 1],\n//             grid[row][col + 1]            \n//         ]\n\n//         // const neighbors = [];\n\n//         // const validateIdx = function (idxArr) {\n//         //     if(idxArr.every((idx) => {\n//         //         return idx < 20 && idx >= 0}\n//         //         )){\n                \n//         //         neighbors.push(idxArr);\n//         //     }\n//         // }\n\n//         // let top = [(row - 1), col];\n//         // validateIdx(top);\n//         // let right = [row, (col+1)];\n//         // validateIdx(right);\n//         // let bottom = [(row + 1), col];\n//         // validateIdx(bottom);\n//         // let left = [row, (col - 1)];\n//         // validateIdx(left);\n\n//         console.log(neighbors)\n\n//         const validNeighbors = [];\n\n//         // for(let i = 0; i < neighbors.length; i++){\n//         //     if ((neighbors[i][0] < 20 && neighbors[i][0] >= 0) && (neighbors[i][1] < 20 && neighbors[i][1] >= 0)) {\n//         //         validNeighbors.push(neighbors[i]);\n//         //     }\n//         // }\n\n//         // const validNeighbors = neighbors.filter(neighbor => {\n//         //     // let x = neighbor[0];\n//         //     // let y = neighbor[1];\n\n//         //     if((neighbor[0] < 20 && neighbor[0] >= 0) && (neighbor[1] < 20 && neighbor[1] >= 0)){\n//         //         return neighbor;\n//         //     }\n//         // }\n\n//         // const validateNeighbors = function(neighbor) {\n//         //     if(!neighbor){\n//         //         return false;\n//         //     }\n//         //     // let x = neighbor[0];\n//         //     // let y = neighbor[1];\n\n//         //     if(neighbor.row < 20 || neighbor.row >=0){\n//         //         return false;\n//         //     } else if(neighbor.col < 20 || neighbor.col >= 0){\n//         //         return false;\n//         //     } else{\n//         //         return true\n//         //     }\n            \n//         // }\n\n//         // const validateNeighbors = function(neighbor){\n//         //     console.log(neighbor)\n//         //     neighbor\n//         // }\n\n//         // const validNeighbors = neighbors.filter(validateNeighbors);\n\n//         for(let i = 0; i < neighbors.length; i++){\n//             if(neighbors[i] && !(neighbors[i].visited)){\n//                 validNeighbors.push(neighbors[i])\n//             }\n//         }\n        \n        \n//         console.log(\"valid\") \n//         console.log(validNeighbors)\n        \n//         let nextCell;\n\n//         if(validNeighbors.length > 0){\n//             nextCell = this.chooseRandomNeighbor(validNeighbors);\n//             return nextCell;\n//         }\n//         // let nextCell = \n        \n//         // //need to check if nextCell is true bc it could be undefined at the edges\n//         // while(nextCell && nextCell.visited){\n//             //     nextCell = this.chooseRandomNeighbor(neighbors)\n            \n//             //     if(nextCell && !nextCell.visited){\n//                 //         return nextCell\n//                 //     }\n//                 // }\n                \n//                 // if (nextCell) {\n//                     //     rect(startRow, startCol, 40, 40)\n//                     //     fill(\"purple\");\n//                     // }\n//                     // console.log(nextCell)\n//                     // return nextCell;\n           \n//     }\n    \n//     this.chooseRandomNeighbor = function(validNeighbors) {\n//        return validNeighbors[Math.floor(Math.random() * validNeighbors.length)] \n//     }\n\n// }\n\n// function Wall(){\n//     this.present = true;\n\n//     this.render = function(i, x, y){\n//         stroke(255);\n//         switch(i){\n//             case 0: \n//                 line(x, y, x, y + 40)\n//             case 1:\n//                 line(x, y + 40, x + 40, y + 40)\n//             case 2: \n//                 line(x + 40, y + 40, x + 40, y)\n//             case 3:\n//                 line(x + 40, y, x, y)\n//         }\n//     }\n// }\n\nwindow.setup = setup;\n\nwindow.draw = draw;\n\n//p5 cannot find the functions, \n//so we need to set it to the window so the fx can be found //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2luZGV4LmpzPzQxZjUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQ2VsbCA9IHJlcXVpcmUoJy4vY2VsbCcpO1xuLy8gY29uc3QgTW92aW5nT2JqZWN0ID0gcmVxdWlyZSgnLi9tb3Zpbmdfb2JqZWN0cycpO1xuLy8gY29uc3QgVXNlciA9IHJlcXVpcmUoJy4vdXNlcicpO1xuY29uc3QgR2FtZSA9IHJlcXVpcmUoJy4vZ2FtZScpO1xuY29uc3QgTWF6ZSA9IHJlcXVpcmUoJy4vbWF6ZScpO1xuXG4vLyB3aW5kb3cuTW92aW5nT2JqZWN0ID0gTW92aW5nT2JqZWN0O1xuXG5jb25zdCBncmlkID0gW107XG5cbmxldCBjdXJyZW50O1xuXG5jb25zdCBzdGFjayA9IFtdO1xuXG5sZXQgZ2FtZSA9IG5ldyBHYW1lKCk7XG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleXByZXNzXCIsIChldmVudCkgPT4gKGdhbWUudXNlck1vdmUoZXZlbnQpKSk7XG5cblxubGV0IG1hemU7XG5cbmxldCBtYXBDb21wbGV0ZSA9IGZhbHNlO1xuXG4vLyBjb25zdCB1c2VyID0gbmV3IFVzZXIoKTtcblxuZnVuY3Rpb24gc2V0dXAoKSB7XG4gIGNyZWF0ZUNhbnZhcyg4MDAsIDgwMCk7XG4vLyAgIGNvbHMgPSAxMDtcbi8vICAgcm93cyA9IDEwO1xuXG4gIGZvcihsZXQgeCA9IDA7IHggPCAyMDsgeCsrKXtcbiAgICAgIGdyaWRbeF0gPSBbXTtcbiAgICAgIGZvcihsZXQgeSA9IDA7IHkgPCAyMDsgeSsrKXtcbiAgICAgICAgZ3JpZFt4XS5wdXNoKG5ldyBDZWxsKHgsIHksIGdyaWQsIHN0YWNrKSlcbiAgICAgIH1cbiAgfVxuXG4gIGxldCBjdXJyZW50X3JvdyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIwKTtcbiAgbGV0IGN1cnJlbnRfY29sID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjApO1xuXG4gIGN1cnJlbnQgPSBncmlkW2N1cnJlbnRfcm93XVtjdXJyZW50X2NvbF07XG4gIG1hemUgPSBuZXcgTWF6ZShjdXJyZW50LCBncmlkLCBnYW1lKVxuXG4gIC8vICAgY29uc29sZS5sb2coXCJjdXJyZW50XCIpXG4vLyAgIGNvbnNvbGUubG9nKGN1cnJlbnQpXG4gIFxuICBmcmFtZVJhdGUoMTAwKTtcbiAgXG59XG5cbi8vIGNvbnN0IG1hemUgPSBuZXcgTWF6ZShjdXJyZW50LCBncmlkKTtcblxuZnVuY3Rpb24gZHJhdygpIHtcbiAgICAvLyBpZighbWFwQ29tcGxldGUpe1xuICAgIG1hemUuZHJhdygpO1xuICAgICAgICAvLyBtYXBDb21wbGV0ZSA9IG1hemUubWFwQ29tcGxldGUoKTtcbiAgICAvLyB9XG4gICAgY29uc29sZS5sb2coXCJmaW5pc2ggbWF6ZVwiKVxuICAgIGdhbWUudXNlck1vdmUoKTtcbiAgICBnYW1lLnVzZXJSZW5kZXIoKTtcbiAgICAvLyBnYW1lLnVzZXJSZW5kZXIoMCwgMCk7XG5cbiAgICAvLyBjb25zdCBrZXlwcmVzcyA9IGV2ZW50LmtleUNvZGU7XG4gICAgLy8gY29uc29sZS5sb2coZXZlbnQpO1xuXG5cbiAgICAvLyBnYW1lLnVzZXJNb3ZlKCk7XG4gICAgLy8gZ2FtZS51c2VyLmRyYXcoKTtcblxuICAgIC8vIGxvb3AoKTtcbiAgICAvLyBiYWNrZ3JvdW5kKDUxKVxuXG4gICAgLy8gaWYoIW1hcCAmJiAhZ2FtZUVuZCl7XG4gICAgLy8gICAgIGlmIChjdXJyZW50KSB7XG4gICAgLy8gICAgICAgICBjdXJyZW50LnZpc2l0ZWQgPSB0cnVlO1xuICAgIC8vICAgICAvLyBjdXJyZW50LmhpZ2hsaWdodCgpO1xuICAgIC8vICAgICAgICAgc3RhY2sucHVzaChjdXJyZW50KTtcbiAgICAvLyAgICAgfVxuICAgIFxuICAgIFxuICAgIC8vICAgICAvLyBsZXQgbmV4dENlbGwgPSBjdXJyZW50LmdldE5leHRDZWxsKGN1cnJlbnQucm93LCBjdXJyZW50LmNvbCk7XG4gICAgLy8gICAgIGxldCBuZXh0Q2VsbCA9IGN1cnJlbnQuZ2V0TmVpZ2hib3IoKTtcbiAgICBcbiAgICAvLyAgICAgLy8gY29uc29sZS5sb2coXCJuZXh0Y2VsbFwiKVxuICAgIC8vICAgICAvLyBjb25zb2xlLmxvZyhuZXh0Q2VsbCk7XG4gICAgICAgIFxuICAgIC8vICAgICB0aGlzLnJlbW92ZVdhbGxzID0gZnVuY3Rpb24oY3VycmVudCwgbmV4dCwgZ3JpZCl7XG4gICAgLy8gICAgICAgICBjb25zdCBjaGFuZ2VYID0gY3VycmVudC5yb3cgLSBuZXh0LnJvdztcbiAgICAvLyAgICAgICAgIGNvbnN0IGNoYW5nZVkgPSBjdXJyZW50LmNvbCAtIG5leHQuY29sO1xuXG4gICAgXG4gICAgLy8gICAgICAgICBzd2l0Y2goY2hhbmdlWCl7XG4gICAgLy8gICAgICAgICAgICAgY2FzZSAxOlxuICAgIC8vICAgICAgICAgICAgICAgICBjdXJyZW50LndhbGxzWzBdLnByZXNlbnQgPSBmYWxzZTsgIFxuICAgIC8vICAgICAgICAgICAgICAgICBuZXh0LndhbGxzWzJdLnByZXNlbnQgPSBmYWxzZTtcbiAgICAvLyAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgLy8gICAgICAgICAgICAgY2FzZSAtMTpcbiAgICAvLyAgICAgICAgICAgICAgICAgY3VycmVudC53YWxsc1syXS5wcmVzZW50ID0gZmFsc2U7XG4gICAgLy8gICAgICAgICAgICAgICAgIG5leHQud2FsbHNbMF0ucHJlc2VudCA9IGZhbHNlO1xuICAgIC8vICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAvLyAgICAgICAgIH1cbiAgICBcbiAgICAvLyAgICAgICAgIHN3aXRjaCAoY2hhbmdlWSkge1xuICAgIC8vICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAvLyAgICAgICAgICAgICAgICAgY3VycmVudC53YWxsc1szXS5wcmVzZW50ID0gZmFsc2U7XG4gICAgLy8gICAgICAgICAgICAgICAgIG5leHQud2FsbHNbMV0ucHJlc2VudCA9IGZhbHNlO1xuICAgIC8vICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAvLyAgICAgICAgICAgICBjYXNlIC0xOlxuICAgIC8vICAgICAgICAgICAgICAgICBjdXJyZW50LndhbGxzWzFdLnByZXNlbnQgPSBmYWxzZTtcbiAgICAvLyAgICAgICAgICAgICAgICAgbmV4dC53YWxsc1szXS5wcmVzZW50ID0gZmFsc2U7XG4gICAgLy8gICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgIC8vICAgICAgICAgfVxuICAgIFxuICAgIC8vICAgICAgICAgLy8gY29uc3QgZmlyc3RSb3cgPSBncmlkWzBdO1xuICAgIC8vICAgICAgICAgLy8gY29uc3QgbGFzdFJvdyA9IGdyaWRbMTldO1xuICAgIFxuICAgIC8vICAgICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBmaXJzdFJvdy5sZW5ndGg7IGkrKykge1xuICAgIC8vICAgICAgICAgLy8gICAgIGZpcnN0Um93W2ldLndhbGxzWzNdLnByZXNlbnQgPSB0cnVlXG4gICAgLy8gICAgICAgICAvLyB9XG4gICAgXG4gICAgLy8gICAgICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RSb3cubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAgICAgICAgIC8vICAgICBsYXN0Um93W2ldLndhbGxzWzFdLnByZXNlbnQgPSB0cnVlXG4gICAgLy8gICAgICAgICAvLyB9XG4gICAgXG4gICAgLy8gICAgICAgICAvLyBjb25zdCBmaXJzdENvbCA9IGdyaWQuZmlsdGVyKChjZWxsKSA9PiB7XG4gICAgLy8gICAgICAgICAvLyAgICAgcmV0dXJuIGNlbGwuY29sID09PSAwXG4gICAgLy8gICAgICAgICAvLyB9KVxuICAgIFxuICAgIC8vICAgICAgICAgLy8gY29uc3QgbGFzdENvbCA9IGdyaWQuZmlsdGVyKChjZWxsKSA9PiB7XG4gICAgLy8gICAgICAgICAvLyAgICAgcmV0dXJuIGNlbGwuY29sID09PSAxOVxuICAgIC8vICAgICAgICAgLy8gfSlcbiAgICBcbiAgICAvLyAgICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgZmlyc3RDb2wubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAgICAgICAgIC8vICAgICBmaXJzdENvbFtpXS53YWxsc1syXS5wcmVzZW50ID0gdHJ1ZTtcbiAgICAvLyAgICAgICAgIC8vIH1cbiAgICBcbiAgICAvLyAgICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgbGFzdENvbC5sZW5ndGg7IGkrKykge1xuICAgIC8vICAgICAgICAgLy8gICAgIGxhc3RDb2xbaV0ud2FsbHNbMF0ucHJlc2VudCA9IHRydWU7XG4gICAgLy8gICAgICAgICAvLyB9XG4gICAgLy8gICAgIH0gXG4gICAgXG4gICAgLy8gICAgIGlmKG5leHRDZWxsKXtcbiAgICAvLyAgICAgICAgIG5leHRDZWxsLnZpc2l0ZWQgPSB0cnVlO1xuICAgIC8vICAgICAgICAgdGhpcy5yZW1vdmVXYWxscyhjdXJyZW50LCBuZXh0Q2VsbCwgZ3JpZCk7XG4gICAgLy8gICAgICAgICBjdXJyZW50ID0gbmV4dENlbGw7XG4gICAgLy8gICAgICAgICAvLyBjb25zb2xlLmxvZyhcInN0YWNrXCIpXG4gICAgLy8gICAgICAgICAvLyBjb25zb2xlLmxvZyhzdGFjayk7XG4gICAgLy8gICAgIH0gZWxzZSBpZihzdGFjay5sZW5ndGggPiAwKXtcbiAgICAvLyAgICAgICAgIHBvdGVudGlhbFJlc3RhcnQgPSBzdGFjay5wb3AoKVxuICAgIC8vICAgICAgICAgICAgIHdoaWxlIChwb3RlbnRpYWxSZXN0YXJ0ICYmICFwb3RlbnRpYWxSZXN0YXJ0LmdldE5laWdoYm9yKCkpe1xuICAgIC8vICAgICAgICAgICAgICAgICBpZighc3RhY2subGVuZ3RoKXtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbFJlc3RhcnQudmlzaXRlZCA9IHRydWVcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIG1hcCA9IHRydWU7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBub0xvb3AoKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgIC8vICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsUmVzdGFydCA9IHN0YWNrLnBvcCgpO1xuICAgIC8vICAgICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgIGN1cnJlbnQgPSBwb3RlbnRpYWxSZXN0YXJ0O1xuICAgIC8vICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGN1cnJlbnQpXG4gICAgLy8gICAgIC8vIH0gZWxzZSBpZihhbGxWaXNpdGVkKSB7XG4gICAgLy8gICAgIC8vICAgICBub0xvb3AoKTtcbiAgICAvLyAgICAgfVxuICAgIFxuICAgIFxuICAgIC8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyaWQubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZ3JpZFtpXS5sZW5ndGg7IGorKykge1xuICAgIC8vICAgICAgICAgICAgIGdyaWRbaV1bal0ucmVuZGVyKCk7XG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgIH1cblxuICAgIC8vICAgICBnYW1lLnVzZXJSZW5kZXIoKTtcbiAgICAvLyB9IGVsc2UgaWYobWFwICYmICFnYW1lRW5kKXtcbiAgICAvLyAgICAgLy8gbG9vcCgpXG4gICAgLy8gICAgIGNvbnNvbGUubG9nKFwiaGlcIilcbiAgICAvLyAgICAgZ2FtZS51c2VyUmVuZGVyKCk7XG4gICAgLy8gICAgIC8vIGdhbWUudXNlck1vdmUoKTtcbiAgICAvLyAgICAga2V5UHJlc3NlZCgpO1xuICAgICAgICBcbiAgICAvLyAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmlkLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdyaWRbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAvLyAgICAgICAgICAgICBncmlkW2ldW2pdLnJlbmRlcigpO1xuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICB9XG4gICAgICAgIFxuICAgIC8vIH1cbiAgICBcbiAgICAvLyAvLyBjdXJyZW50LmhpZ2hsaWdodCgpO1xuICAgIFxuICAgIC8vIGZ1bmN0aW9uIGtleVByZXNzZWQoKXtcbiAgICAvLyAgICAgLy8gbG9vcCgpO1xuICAgIC8vICAgICBnYW1lLnVzZXJNb3ZlKCk7XG4gICAgLy8gICAgIC8vIGxvb3AoKSAgICAgICAgXG4gICAgLy8gICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyB9XG5cbiAgICAvLyBrZXlQcmVzc2VkKCk7XG5cbiAgICAvLyAvLyB1c2VyLnJlbmRlcigpO1xuXG4gICAgXG5cbiAgICAvLyAvLyByZWRyYXcoKTtcbiAgICBcbiAgICAvLyAvLyB3aGlsZSAoIWdhbWUuZW5kKCkpe1xuICAgIC8vIC8vICAgICBnYW1lLnVzZXJNb3ZlKClcbiAgICAvLyAvLyB9XG5cbn1cblxuXG4vLyBmdW5jdGlvbiBDZWxsKHJvdywgY29sKSB7XG4vLyAgICAgdGhpcy5yb3cgPSByb3c7XG4vLyAgICAgdGhpcy5jb2wgPSBjb2w7XG4vLyAgICAgdGhpcy53YWxscyA9IFtuZXcgV2FsbCgpLCBuZXcgV2FsbCgpLCBuZXcgV2FsbCgpLCBuZXcgV2FsbCgpXTtcbi8vICAgICB0aGlzLnZpc2l0ZWQgPSBmYWxzZTtcblxuLy8gICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICBjb25zdCBzdGFydFJvdyA9IHRoaXMucm93ICogNDA7XG4vLyAgICAgICAgIGNvbnN0IHN0YXJ0Q29sID0gdGhpcy5jb2wgKiA0MDtcblxuLy8gICAgICAgICAvLyB4LCB5LCB3aWR0aCwgaGVpZ2h0XG4vLyAgICAgICAgIC8vIHJlY3Qoc3RhcnRYLCBzdGFydFksIDQwLCA0MClcbi8vICAgICAgICAgLy8gbm9GaWxsKCk7XG4vLyAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLndhbGxzLmxlbmd0aDsgaSsrKXtcbi8vICAgICAgICAgICAgIHRoaXMud2FsbHNbaV0ucmVuZGVyKGksIHN0YXJ0Um93LCBzdGFydENvbCk7XG4vLyAgICAgICAgIH1cblxuLy8gICAgICAgICBpZih0aGlzLnZpc2l0ZWQpe1xuLy8gICAgICAgICAgICAgcmVjdChzdGFydFJvdywgc3RhcnRDb2wsIDQwLCA0MClcbi8vICAgICAgICAgICAgIGZpbGwoXCJncmVlblwiKTtcbi8vICAgICAgICAgfVxuICAgICAgICBcbi8vICAgICB9XG5cbi8vICAgICB0aGlzLmdldE5laWdoYm9yID0gZnVuY3Rpb24oKXtcbiAgICAgICAgXG4vLyAgICAgICAgIC8vIGNvbnN0IG5laWdoYm9yc0luZGljZXMgPSBbXG4vLyAgICAgICAgIC8vICAgICBbcm93IC0gMSwgY29sXSxcbi8vICAgICAgICAgLy8gICAgIFtyb3cgKyAxLCBjb2xdLFxuLy8gICAgICAgICAvLyAgICAgW3JvdywgY29sIC0gMV0sXG4vLyAgICAgICAgIC8vICAgICBbcm93LCBjb2wgKyAxXSAgICAgICAgICAgIFxuLy8gICAgICAgICAvLyBdXG5cbi8vICAgICAgICAgY29uc3QgbmVpZ2hib3JzID0gW1xuLy8gICAgICAgICAgICAgZ3JpZFtyb3cgLSAxXVtjb2xdLFxuLy8gICAgICAgICAgICAgZ3JpZFtyb3cgKyAxXVtjb2xdLFxuLy8gICAgICAgICAgICAgZ3JpZFtyb3ddW2NvbCAtIDFdLFxuLy8gICAgICAgICAgICAgZ3JpZFtyb3ddW2NvbCArIDFdICAgICAgICAgICAgXG4vLyAgICAgICAgIF1cblxuLy8gICAgICAgICAvLyBjb25zdCBuZWlnaGJvcnMgPSBbXTtcblxuLy8gICAgICAgICAvLyBjb25zdCB2YWxpZGF0ZUlkeCA9IGZ1bmN0aW9uIChpZHhBcnIpIHtcbi8vICAgICAgICAgLy8gICAgIGlmKGlkeEFyci5ldmVyeSgoaWR4KSA9PiB7XG4vLyAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIGlkeCA8IDIwICYmIGlkeCA+PSAwfVxuLy8gICAgICAgICAvLyAgICAgICAgICkpe1xuICAgICAgICAgICAgICAgIFxuLy8gICAgICAgICAvLyAgICAgICAgIG5laWdoYm9ycy5wdXNoKGlkeEFycik7XG4vLyAgICAgICAgIC8vICAgICB9XG4vLyAgICAgICAgIC8vIH1cblxuLy8gICAgICAgICAvLyBsZXQgdG9wID0gWyhyb3cgLSAxKSwgY29sXTtcbi8vICAgICAgICAgLy8gdmFsaWRhdGVJZHgodG9wKTtcbi8vICAgICAgICAgLy8gbGV0IHJpZ2h0ID0gW3JvdywgKGNvbCsxKV07XG4vLyAgICAgICAgIC8vIHZhbGlkYXRlSWR4KHJpZ2h0KTtcbi8vICAgICAgICAgLy8gbGV0IGJvdHRvbSA9IFsocm93ICsgMSksIGNvbF07XG4vLyAgICAgICAgIC8vIHZhbGlkYXRlSWR4KGJvdHRvbSk7XG4vLyAgICAgICAgIC8vIGxldCBsZWZ0ID0gW3JvdywgKGNvbCAtIDEpXTtcbi8vICAgICAgICAgLy8gdmFsaWRhdGVJZHgobGVmdCk7XG5cbi8vICAgICAgICAgY29uc29sZS5sb2cobmVpZ2hib3JzKVxuXG4vLyAgICAgICAgIGNvbnN0IHZhbGlkTmVpZ2hib3JzID0gW107XG5cbi8vICAgICAgICAgLy8gZm9yKGxldCBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7IGkrKyl7XG4vLyAgICAgICAgIC8vICAgICBpZiAoKG5laWdoYm9yc1tpXVswXSA8IDIwICYmIG5laWdoYm9yc1tpXVswXSA+PSAwKSAmJiAobmVpZ2hib3JzW2ldWzFdIDwgMjAgJiYgbmVpZ2hib3JzW2ldWzFdID49IDApKSB7XG4vLyAgICAgICAgIC8vICAgICAgICAgdmFsaWROZWlnaGJvcnMucHVzaChuZWlnaGJvcnNbaV0pO1xuLy8gICAgICAgICAvLyAgICAgfVxuLy8gICAgICAgICAvLyB9XG5cbi8vICAgICAgICAgLy8gY29uc3QgdmFsaWROZWlnaGJvcnMgPSBuZWlnaGJvcnMuZmlsdGVyKG5laWdoYm9yID0+IHtcbi8vICAgICAgICAgLy8gICAgIC8vIGxldCB4ID0gbmVpZ2hib3JbMF07XG4vLyAgICAgICAgIC8vICAgICAvLyBsZXQgeSA9IG5laWdoYm9yWzFdO1xuXG4vLyAgICAgICAgIC8vICAgICBpZigobmVpZ2hib3JbMF0gPCAyMCAmJiBuZWlnaGJvclswXSA+PSAwKSAmJiAobmVpZ2hib3JbMV0gPCAyMCAmJiBuZWlnaGJvclsxXSA+PSAwKSl7XG4vLyAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIG5laWdoYm9yO1xuLy8gICAgICAgICAvLyAgICAgfVxuLy8gICAgICAgICAvLyB9XG5cbi8vICAgICAgICAgLy8gY29uc3QgdmFsaWRhdGVOZWlnaGJvcnMgPSBmdW5jdGlvbihuZWlnaGJvcikge1xuLy8gICAgICAgICAvLyAgICAgaWYoIW5laWdoYm9yKXtcbi8vICAgICAgICAgLy8gICAgICAgICByZXR1cm4gZmFsc2U7XG4vLyAgICAgICAgIC8vICAgICB9XG4vLyAgICAgICAgIC8vICAgICAvLyBsZXQgeCA9IG5laWdoYm9yWzBdO1xuLy8gICAgICAgICAvLyAgICAgLy8gbGV0IHkgPSBuZWlnaGJvclsxXTtcblxuLy8gICAgICAgICAvLyAgICAgaWYobmVpZ2hib3Iucm93IDwgMjAgfHwgbmVpZ2hib3Iucm93ID49MCl7XG4vLyAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIGZhbHNlO1xuLy8gICAgICAgICAvLyAgICAgfSBlbHNlIGlmKG5laWdoYm9yLmNvbCA8IDIwIHx8IG5laWdoYm9yLmNvbCA+PSAwKXtcbi8vICAgICAgICAgLy8gICAgICAgICByZXR1cm4gZmFsc2U7XG4vLyAgICAgICAgIC8vICAgICB9IGVsc2V7XG4vLyAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIHRydWVcbi8vICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIFxuLy8gICAgICAgICAvLyB9XG5cbi8vICAgICAgICAgLy8gY29uc3QgdmFsaWRhdGVOZWlnaGJvcnMgPSBmdW5jdGlvbihuZWlnaGJvcil7XG4vLyAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhuZWlnaGJvcilcbi8vICAgICAgICAgLy8gICAgIG5laWdoYm9yXG4vLyAgICAgICAgIC8vIH1cblxuLy8gICAgICAgICAvLyBjb25zdCB2YWxpZE5laWdoYm9ycyA9IG5laWdoYm9ycy5maWx0ZXIodmFsaWRhdGVOZWlnaGJvcnMpO1xuXG4vLyAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKyspe1xuLy8gICAgICAgICAgICAgaWYobmVpZ2hib3JzW2ldICYmICEobmVpZ2hib3JzW2ldLnZpc2l0ZWQpKXtcbi8vICAgICAgICAgICAgICAgICB2YWxpZE5laWdoYm9ycy5wdXNoKG5laWdoYm9yc1tpXSlcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgXG4vLyAgICAgICAgIGNvbnNvbGUubG9nKFwidmFsaWRcIikgXG4vLyAgICAgICAgIGNvbnNvbGUubG9nKHZhbGlkTmVpZ2hib3JzKVxuICAgICAgICBcbi8vICAgICAgICAgbGV0IG5leHRDZWxsO1xuXG4vLyAgICAgICAgIGlmKHZhbGlkTmVpZ2hib3JzLmxlbmd0aCA+IDApe1xuLy8gICAgICAgICAgICAgbmV4dENlbGwgPSB0aGlzLmNob29zZVJhbmRvbU5laWdoYm9yKHZhbGlkTmVpZ2hib3JzKTtcbi8vICAgICAgICAgICAgIHJldHVybiBuZXh0Q2VsbDtcbi8vICAgICAgICAgfVxuLy8gICAgICAgICAvLyBsZXQgbmV4dENlbGwgPSBcbiAgICAgICAgXG4vLyAgICAgICAgIC8vIC8vbmVlZCB0byBjaGVjayBpZiBuZXh0Q2VsbCBpcyB0cnVlIGJjIGl0IGNvdWxkIGJlIHVuZGVmaW5lZCBhdCB0aGUgZWRnZXNcbi8vICAgICAgICAgLy8gd2hpbGUobmV4dENlbGwgJiYgbmV4dENlbGwudmlzaXRlZCl7XG4vLyAgICAgICAgICAgICAvLyAgICAgbmV4dENlbGwgPSB0aGlzLmNob29zZVJhbmRvbU5laWdoYm9yKG5laWdoYm9ycylcbiAgICAgICAgICAgIFxuLy8gICAgICAgICAgICAgLy8gICAgIGlmKG5leHRDZWxsICYmICFuZXh0Q2VsbC52aXNpdGVkKXtcbi8vICAgICAgICAgICAgICAgICAvLyAgICAgICAgIHJldHVybiBuZXh0Q2VsbFxuLy8gICAgICAgICAgICAgICAgIC8vICAgICB9XG4vLyAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIFxuLy8gICAgICAgICAgICAgICAgIC8vIGlmIChuZXh0Q2VsbCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAvLyAgICAgcmVjdChzdGFydFJvdywgc3RhcnRDb2wsIDQwLCA0MClcbi8vICAgICAgICAgICAgICAgICAgICAgLy8gICAgIGZpbGwoXCJwdXJwbGVcIik7XG4vLyAgICAgICAgICAgICAgICAgICAgIC8vIH1cbi8vICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cobmV4dENlbGwpXG4vLyAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBuZXh0Q2VsbDtcbiAgICAgICAgICAgXG4vLyAgICAgfVxuICAgIFxuLy8gICAgIHRoaXMuY2hvb3NlUmFuZG9tTmVpZ2hib3IgPSBmdW5jdGlvbih2YWxpZE5laWdoYm9ycykge1xuLy8gICAgICAgIHJldHVybiB2YWxpZE5laWdoYm9yc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB2YWxpZE5laWdoYm9ycy5sZW5ndGgpXSBcbi8vICAgICB9XG5cbi8vIH1cblxuLy8gZnVuY3Rpb24gV2FsbCgpe1xuLy8gICAgIHRoaXMucHJlc2VudCA9IHRydWU7XG5cbi8vICAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKGksIHgsIHkpe1xuLy8gICAgICAgICBzdHJva2UoMjU1KTtcbi8vICAgICAgICAgc3dpdGNoKGkpe1xuLy8gICAgICAgICAgICAgY2FzZSAwOiBcbi8vICAgICAgICAgICAgICAgICBsaW5lKHgsIHksIHgsIHkgKyA0MClcbi8vICAgICAgICAgICAgIGNhc2UgMTpcbi8vICAgICAgICAgICAgICAgICBsaW5lKHgsIHkgKyA0MCwgeCArIDQwLCB5ICsgNDApXG4vLyAgICAgICAgICAgICBjYXNlIDI6IFxuLy8gICAgICAgICAgICAgICAgIGxpbmUoeCArIDQwLCB5ICsgNDAsIHggKyA0MCwgeSlcbi8vICAgICAgICAgICAgIGNhc2UgMzpcbi8vICAgICAgICAgICAgICAgICBsaW5lKHggKyA0MCwgeSwgeCwgeSlcbi8vICAgICAgICAgfVxuLy8gICAgIH1cbi8vIH1cblxud2luZG93LnNldHVwID0gc2V0dXA7XG5cbndpbmRvdy5kcmF3ID0gZHJhdztcblxuLy9wNSBjYW5ub3QgZmluZCB0aGUgZnVuY3Rpb25zLCBcbi8vc28gd2UgbmVlZCB0byBzZXQgaXQgdG8gdGhlIHdpbmRvdyBzbyB0aGUgZnggY2FuIGJlIGZvdW5kICJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./index.js\n");

/***/ }),

/***/ "./maze.js":
/*!*****************!*\
  !*** ./maze.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function Maze(current, grid, game){\n    \n    this.current = current;\n    this.grid = grid;\n    this.stack = [];\n    this.map = false;\n    this.game = game;\n\n    this.draw = function(){\n\n        background(51)\n\n        // if (!map && !gameEnd) {\n            if (this.current) {\n                this.current.visited = true;\n                // this.current.highlight();\n                this.stack.push(this.current);\n            }\n\n\n            // let nextCell = this.current.getNextCell(this.current.row, this.current.col);\n            let nextCell = this.current.getNeighbor();\n\n            // console.log(\"nextcell\")\n            // console.log(nextCell);\n\n            removeWalls = function (current, next, grid) {\n                const changeX = current.row - next.row;\n                const changeY = current.col - next.col;\n\n                // current.walls.forEach(wall => wall.present = false)\n\n\n                switch (changeX) {\n                    case 1:\n                        current.walls[0].present = false;\n                        next.walls[2].present = false;\n                        break;\n                    case -1:\n                        current.walls[2].present = false;\n                        next.walls[0].present = false;\n                        break;\n                }\n\n                switch (changeY) {\n                    case 1:\n                        current.walls[3].present = false;\n                        next.walls[1].present = false;\n                        break;\n                    case -1:\n                        current.walls[1].present = false;\n                        next.walls[3].present = false;\n                        break;\n                }\n\n                // const firstRow = grid[0];\n                // const lastRow = grid[19];\n\n                // for (let i = 0; i < firstRow.length; i++) {\n                //     firstRow[i].walls[3].present = true\n                // }\n\n                // for (let i = 0; i < lastRow.length; i++) {\n                //     lastRow[i].walls[1].present = true\n                // }\n\n                // const firstCol = grid.filter((cell) => {\n                //     return cell.col === 0\n                // })\n\n                // const lastCol = grid.filter((cell) => {\n                //     return cell.col === 19\n                // })\n\n                // for (let i = 0; i < firstCol.length; i++) {\n                //     firstCol[i].walls[2].present = true;\n                // }\n\n                // for (let i = 0; i < lastCol.length; i++) {\n                //     lastCol[i].walls[0].present = true;\n                // }\n            }\n\n            if (nextCell) {\n                nextCell.visited = true;\n                removeWalls(this.current, nextCell, grid);\n                this.current = nextCell;\n                // console.log(\"this.stack\")\n                // console.log(this.stack);\n            } else if (this.stack.length > 0) {\n                potentialRestart = this.stack.pop()\n                while (potentialRestart && !potentialRestart.getNeighbor()) {\n                    if (!this.stack.length) {\n                        potentialRestart.visited = true\n                        // game.userMove();\n                        this.map = true;\n                        break;\n                        console.log(\"finish\")\n                        if(map){\n                            console.log(\"hi\")\n                            game.userMove();\n                        }\n                        // noLoop();\n                        // break;\n                    } else {\n                        potentialRestart = this.stack.pop();\n                    }\n                }\n                this.current = potentialRestart;\n                // console.log(this.this.current)\n                // } else if(allVisited) {\n                //     noLoop();\n            }\n\n\n            for (let i = 0; i < grid.length; i++) {\n                for (let j = 0; j < grid[i].length; j++) {\n                    grid[i][j].render();\n                }\n            }\n\n        //     game.start();\n        // } else if (map && !gameEnd) {\n        //     game.start();\n        //     game.userMove();\n        //     // keyPressed();\n\n        // }\n\n        // // this.current.highlight();\n\n        // function keyPressed() {\n        //     game.userMove();\n        //     // redraw();\n        //     return false;\n        // }\n\n        // keyPressed();\n\n    // user.render();\n\n\n\n    // redraw();\n\n    // while (!game.end()){\n    //     game.userMove()\n    // }\n\n    }\n\n    // this.mapComplete = function(){\n    //     return this.map;\n    // }\n\n}\n\nmodule.exports = Maze;\n\n// window.draw = draw;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9tYXplLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbWF6ZS5qcz8zZWI1Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIE1hemUoY3VycmVudCwgZ3JpZCwgZ2FtZSl7XG4gICAgXG4gICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcbiAgICB0aGlzLmdyaWQgPSBncmlkO1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB0aGlzLm1hcCA9IGZhbHNlO1xuICAgIHRoaXMuZ2FtZSA9IGdhbWU7XG5cbiAgICB0aGlzLmRyYXcgPSBmdW5jdGlvbigpe1xuXG4gICAgICAgIGJhY2tncm91bmQoNTEpXG5cbiAgICAgICAgLy8gaWYgKCFtYXAgJiYgIWdhbWVFbmQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQudmlzaXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5jdXJyZW50LmhpZ2hsaWdodCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vIGxldCBuZXh0Q2VsbCA9IHRoaXMuY3VycmVudC5nZXROZXh0Q2VsbCh0aGlzLmN1cnJlbnQucm93LCB0aGlzLmN1cnJlbnQuY29sKTtcbiAgICAgICAgICAgIGxldCBuZXh0Q2VsbCA9IHRoaXMuY3VycmVudC5nZXROZWlnaGJvcigpO1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIm5leHRjZWxsXCIpXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhuZXh0Q2VsbCk7XG5cbiAgICAgICAgICAgIHJlbW92ZVdhbGxzID0gZnVuY3Rpb24gKGN1cnJlbnQsIG5leHQsIGdyaWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VYID0gY3VycmVudC5yb3cgLSBuZXh0LnJvdztcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VZID0gY3VycmVudC5jb2wgLSBuZXh0LmNvbDtcblxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQud2FsbHMuZm9yRWFjaCh3YWxsID0+IHdhbGwucHJlc2VudCA9IGZhbHNlKVxuXG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYW5nZVgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudC53YWxsc1swXS5wcmVzZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0LndhbGxzWzJdLnByZXNlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIC0xOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudC53YWxsc1syXS5wcmVzZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0LndhbGxzWzBdLnByZXNlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhbmdlWSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LndhbGxzWzNdLnByZXNlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQud2FsbHNbMV0ucHJlc2VudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LndhbGxzWzFdLnByZXNlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQud2FsbHNbM10ucHJlc2VudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY29uc3QgZmlyc3RSb3cgPSBncmlkWzBdO1xuICAgICAgICAgICAgICAgIC8vIGNvbnN0IGxhc3RSb3cgPSBncmlkWzE5XTtcblxuICAgICAgICAgICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgZmlyc3RSb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgZmlyc3RSb3dbaV0ud2FsbHNbM10ucHJlc2VudCA9IHRydWVcbiAgICAgICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RSb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgbGFzdFJvd1tpXS53YWxsc1sxXS5wcmVzZW50ID0gdHJ1ZVxuICAgICAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgICAgIC8vIGNvbnN0IGZpcnN0Q29sID0gZ3JpZC5maWx0ZXIoKGNlbGwpID0+IHtcbiAgICAgICAgICAgICAgICAvLyAgICAgcmV0dXJuIGNlbGwuY29sID09PSAwXG4gICAgICAgICAgICAgICAgLy8gfSlcblxuICAgICAgICAgICAgICAgIC8vIGNvbnN0IGxhc3RDb2wgPSBncmlkLmZpbHRlcigoY2VsbCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vICAgICByZXR1cm4gY2VsbC5jb2wgPT09IDE5XG4gICAgICAgICAgICAgICAgLy8gfSlcblxuICAgICAgICAgICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgZmlyc3RDb2wubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgZmlyc3RDb2xbaV0ud2FsbHNbMl0ucHJlc2VudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0Q29sLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGxhc3RDb2xbaV0ud2FsbHNbMF0ucHJlc2VudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmV4dENlbGwpIHtcbiAgICAgICAgICAgICAgICBuZXh0Q2VsbC52aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZW1vdmVXYWxscyh0aGlzLmN1cnJlbnQsIG5leHRDZWxsLCBncmlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBuZXh0Q2VsbDtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInRoaXMuc3RhY2tcIilcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnN0YWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcG90ZW50aWFsUmVzdGFydCA9IHRoaXMuc3RhY2sucG9wKClcbiAgICAgICAgICAgICAgICB3aGlsZSAocG90ZW50aWFsUmVzdGFydCAmJiAhcG90ZW50aWFsUmVzdGFydC5nZXROZWlnaGJvcigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbFJlc3RhcnQudmlzaXRlZCA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdhbWUudXNlck1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJmaW5pc2hcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG1hcCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJoaVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhbWUudXNlck1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vTG9vcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxSZXN0YXJ0ID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBwb3RlbnRpYWxSZXN0YXJ0O1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMudGhpcy5jdXJyZW50KVxuICAgICAgICAgICAgICAgIC8vIH0gZWxzZSBpZihhbGxWaXNpdGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIG5vTG9vcCgpO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JpZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZ3JpZFtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBncmlkW2ldW2pdLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAvLyAgICAgZ2FtZS5zdGFydCgpO1xuICAgICAgICAvLyB9IGVsc2UgaWYgKG1hcCAmJiAhZ2FtZUVuZCkge1xuICAgICAgICAvLyAgICAgZ2FtZS5zdGFydCgpO1xuICAgICAgICAvLyAgICAgZ2FtZS51c2VyTW92ZSgpO1xuICAgICAgICAvLyAgICAgLy8ga2V5UHJlc3NlZCgpO1xuXG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyAvLyB0aGlzLmN1cnJlbnQuaGlnaGxpZ2h0KCk7XG5cbiAgICAgICAgLy8gZnVuY3Rpb24ga2V5UHJlc3NlZCgpIHtcbiAgICAgICAgLy8gICAgIGdhbWUudXNlck1vdmUoKTtcbiAgICAgICAgLy8gICAgIC8vIHJlZHJhdygpO1xuICAgICAgICAvLyAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8ga2V5UHJlc3NlZCgpO1xuXG4gICAgLy8gdXNlci5yZW5kZXIoKTtcblxuXG5cbiAgICAvLyByZWRyYXcoKTtcblxuICAgIC8vIHdoaWxlICghZ2FtZS5lbmQoKSl7XG4gICAgLy8gICAgIGdhbWUudXNlck1vdmUoKVxuICAgIC8vIH1cblxuICAgIH1cblxuICAgIC8vIHRoaXMubWFwQ29tcGxldGUgPSBmdW5jdGlvbigpe1xuICAgIC8vICAgICByZXR1cm4gdGhpcy5tYXA7XG4gICAgLy8gfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWF6ZTtcblxuLy8gd2luZG93LmRyYXcgPSBkcmF3OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./maze.js\n");

/***/ }),

/***/ "./user.js":
/*!*****************!*\
  !*** ./user.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function User(){\n    this.row = 19;\n    this.col = 19;\n    this.radius = 10;\n    this.pos = [0, 0]\n\n    const colors = [\"lightcoral\", \"orange\", \"Chartreuse\", \"darkcyan\", \"darkorchid\"];\n    let currentColor = colors[Math.floor(Math.random() * colors.length)];\n\n    this.updatePos = function(posChange){\n        switch(posChange[0]){\n            case \"x\":\n                let updatedX = this.pos[0] + posChange[1];\n                this.pos = [updatedX, this.pos[1]];\n            case \"y\":\n                let updatedY = this.pos[1] + posChange[1];\n                this.pos = [this.pos[1], updatedY]; \n        }\n    }\n\n    \n    this.render = function(x, y) {\n\n        fill(currentColor);\n        ellipse((x+20), (y+20), 15, 15);\n    }\n\n    this.draw = function(){\n        let x = this.pos[0];\n        let y = this.pos[1];\n        // const keypress = event.keyCode;\n        // console.log(event);\n        if (keyIsDown(LEFT_ARROW)) {\n            // console.log(this.user.pos)\n            this.updatePos([\"y\", -40]);\n            this.render(this.pos[0], this.pos[1]);\n        }\n\n        if (keyIsDown(RIGHT_ARROW)) {\n            this.updatePos([\"y\", 40]);\n            this.render(this.pos[0], this.pos[1]);\n        }\n\n        if (keyIsDown(UP_ARROW)) {\n            this.updatePos([\"x\", -40]);\n            this.render(this.pos[0], this.pos[1]);\n        }\n\n        if (keyIsDown(DOWN_ARROW)) {\n            this.updatePos([\"x\", 40]);\n            this.render(this.pos[0], this.pos[1]);\n        }\n    }\n}\n\nmodule.exports = User;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91c2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vdXNlci5qcz9iYjMzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIFVzZXIoKXtcbiAgICB0aGlzLnJvdyA9IDE5O1xuICAgIHRoaXMuY29sID0gMTk7XG4gICAgdGhpcy5yYWRpdXMgPSAxMDtcbiAgICB0aGlzLnBvcyA9IFswLCAwXVxuXG4gICAgY29uc3QgY29sb3JzID0gW1wibGlnaHRjb3JhbFwiLCBcIm9yYW5nZVwiLCBcIkNoYXJ0cmV1c2VcIiwgXCJkYXJrY3lhblwiLCBcImRhcmtvcmNoaWRcIl07XG4gICAgbGV0IGN1cnJlbnRDb2xvciA9IGNvbG9yc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjb2xvcnMubGVuZ3RoKV07XG5cbiAgICB0aGlzLnVwZGF0ZVBvcyA9IGZ1bmN0aW9uKHBvc0NoYW5nZSl7XG4gICAgICAgIHN3aXRjaChwb3NDaGFuZ2VbMF0pe1xuICAgICAgICAgICAgY2FzZSBcInhcIjpcbiAgICAgICAgICAgICAgICBsZXQgdXBkYXRlZFggPSB0aGlzLnBvc1swXSArIHBvc0NoYW5nZVsxXTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IFt1cGRhdGVkWCwgdGhpcy5wb3NbMV1dO1xuICAgICAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICAgICAgICBsZXQgdXBkYXRlZFkgPSB0aGlzLnBvc1sxXSArIHBvc0NoYW5nZVsxXTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IFt0aGlzLnBvc1sxXSwgdXBkYXRlZFldOyBcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFxuICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24oeCwgeSkge1xuXG4gICAgICAgIGZpbGwoY3VycmVudENvbG9yKTtcbiAgICAgICAgZWxsaXBzZSgoeCsyMCksICh5KzIwKSwgMTUsIDE1KTtcbiAgICB9XG5cbiAgICB0aGlzLmRyYXcgPSBmdW5jdGlvbigpe1xuICAgICAgICBsZXQgeCA9IHRoaXMucG9zWzBdO1xuICAgICAgICBsZXQgeSA9IHRoaXMucG9zWzFdO1xuICAgICAgICAvLyBjb25zdCBrZXlwcmVzcyA9IGV2ZW50LmtleUNvZGU7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGV2ZW50KTtcbiAgICAgICAgaWYgKGtleUlzRG93bihMRUZUX0FSUk9XKSkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy51c2VyLnBvcylcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUG9zKFtcInlcIiwgLTQwXSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcih0aGlzLnBvc1swXSwgdGhpcy5wb3NbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleUlzRG93bihSSUdIVF9BUlJPVykpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUG9zKFtcInlcIiwgNDBdKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKHRoaXMucG9zWzBdLCB0aGlzLnBvc1sxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5SXNEb3duKFVQX0FSUk9XKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQb3MoW1wieFwiLCAtNDBdKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKHRoaXMucG9zWzBdLCB0aGlzLnBvc1sxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5SXNEb3duKERPV05fQVJST1cpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBvcyhbXCJ4XCIsIDQwXSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcih0aGlzLnBvc1swXSwgdGhpcy5wb3NbMV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFVzZXI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./user.js\n");

/***/ }),

/***/ "./wall.js":
/*!*****************!*\
  !*** ./wall.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class Wall {\n  constructor() {\n    this.present = true;\n  }\n\n  render(wallPos, x, y) {\n    stroke(\"black\");\n    strokeWeight(3);\n    switch (wallPos) {\n      case 0:\n        line(x, y, x, y + 40);\n      case 1:\n        line(x, y + 40, x + 40, y + 40);\n      case 2:\n        line(x + 40, y + 40, x + 40, y);\n      case 3:\n        line(x + 40, y, x, y);\n    }\n\n  }\n\n  derender(wallPos, x, y) {\n    stroke(\"white\");\n    switch (wallPos) {\n      case 0:\n        line(x, y, x, y + 40);\n      case 1:\n        line(x, y + 40, x + 40, y + 40);\n      case 2:\n        line(x + 40, y + 40, x + 40, y);\n      case 3:\n        line(x + 40, y, x, y);\n    }\n  }\n}\n\n// class Wall{\n//     constructor(){\n//         this.present = true;\n//     }\n\n//   render = (i, x, y) => {\n//     stroke(255);\n//     switch (i) {\n//       case 0:\n//         line(x, y, x, y + 40);\n//       case 1:\n//         line(x, y + 40, x + 40, y + 40);\n//       case 2:\n//         line(x + 40, y + 40, x + 40, y);\n//       case 3:\n//         line(x + 40, y, x, y);\n//     }\n//   };\n// }\n\nmodule.exports = Wall;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93YWxsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vd2FsbC5qcz85MDU5Il0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFdhbGwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnByZXNlbnQgPSB0cnVlO1xuICB9XG5cbiAgcmVuZGVyKHdhbGxQb3MsIHgsIHkpIHtcbiAgICBzdHJva2UoXCJibGFja1wiKTtcbiAgICBzdHJva2VXZWlnaHQoMyk7XG4gICAgc3dpdGNoICh3YWxsUG9zKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIGxpbmUoeCwgeSwgeCwgeSArIDQwKTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgbGluZSh4LCB5ICsgNDAsIHggKyA0MCwgeSArIDQwKTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgbGluZSh4ICsgNDAsIHkgKyA0MCwgeCArIDQwLCB5KTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgbGluZSh4ICsgNDAsIHksIHgsIHkpO1xuICAgIH1cblxuICB9XG5cbiAgZGVyZW5kZXIod2FsbFBvcywgeCwgeSkge1xuICAgIHN0cm9rZShcIndoaXRlXCIpO1xuICAgIHN3aXRjaCAod2FsbFBvcykge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBsaW5lKHgsIHksIHgsIHkgKyA0MCk7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGxpbmUoeCwgeSArIDQwLCB4ICsgNDAsIHkgKyA0MCk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGxpbmUoeCArIDQwLCB5ICsgNDAsIHggKyA0MCwgeSk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGxpbmUoeCArIDQwLCB5LCB4LCB5KTtcbiAgICB9XG4gIH1cbn1cblxuLy8gY2xhc3MgV2FsbHtcbi8vICAgICBjb25zdHJ1Y3Rvcigpe1xuLy8gICAgICAgICB0aGlzLnByZXNlbnQgPSB0cnVlO1xuLy8gICAgIH1cblxuLy8gICByZW5kZXIgPSAoaSwgeCwgeSkgPT4ge1xuLy8gICAgIHN0cm9rZSgyNTUpO1xuLy8gICAgIHN3aXRjaCAoaSkge1xuLy8gICAgICAgY2FzZSAwOlxuLy8gICAgICAgICBsaW5lKHgsIHksIHgsIHkgKyA0MCk7XG4vLyAgICAgICBjYXNlIDE6XG4vLyAgICAgICAgIGxpbmUoeCwgeSArIDQwLCB4ICsgNDAsIHkgKyA0MCk7XG4vLyAgICAgICBjYXNlIDI6XG4vLyAgICAgICAgIGxpbmUoeCArIDQwLCB5ICsgNDAsIHggKyA0MCwgeSk7XG4vLyAgICAgICBjYXNlIDM6XG4vLyAgICAgICAgIGxpbmUoeCArIDQwLCB5LCB4LCB5KTtcbi8vICAgICB9XG4vLyAgIH07XG4vLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gV2FsbDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./wall.js\n");

/***/ })

/******/ });