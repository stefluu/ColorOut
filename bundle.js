/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./cell.js":
/*!*****************!*\
  !*** ./cell.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Wall = __webpack_require__(/*! ./wall */ \"./wall.js\");\n\nfunction Cell(row, col, grid) {\n    this.row = row;\n    this.col = col;\n    this.grid = grid;\n    this.walls = [new Wall(), new Wall(), new Wall(), new Wall()];\n    // this.walls = []\n    this.visited = false;\n\n    // [1, 2, 3, 4].forEach(() => this.walls.push(new Wall()));\n\n    this.highlight = function () {\n        // console.log(this.row, this.col);\n        const startRow = this.row * 40;\n        const startCol = this.col * 40;\n        noStroke();\n        fill(\"purple\");\n        rect(startRow, startCol, 40, 40)\n    }\n\n    this.makeWallsFalse = function(){\n        for (let i = 0; i < this.walls.length; i++) {\n            this.walls[i] = false;\n        }\n        this.render();\n    }\n\n    // this.makeBlack = function(){\n    //     const startRow = this.row * 40;\n    //     const startCol = this.col * 40;\n    //     noStroke();\n    //     fill(\"black\");\n    //     rect(startRow, startCol, 40, 40)\n    // }\n\n    this.render = function () {\n        const startRow = this.row * 40;\n        const startCol = this.col * 40;\n\n        // x, y, width, height\n        // rect(startX, startY, 40, 40)\n        // noFill();\n\n        for (let i = 0; i < this.walls.length; i++) {\n            if (this.walls[i].present) {\n                this.walls[i].render(i, startRow, startCol);\n            } else {\n                this.walls[i].derender(i, startRow, startCol);\n            }\n        }\n\n\n        if (this.visited) {\n            noStroke();\n            fill(\"white\");\n            rect(startRow + 1, startCol + 1, 38, 38)\n        }\n\n\n    }\n\n    this.renderUser = function(color) {\n        const startRow = this.row * 40;\n        const startCol = this.col * 40;\n\n        for (let i = 0; i < this.walls.length; i++) {\n            if (this.walls[i].present) {\n                this.walls[i].render(i, startRow, startCol);\n            } else {\n                this.walls[i].derender(i, startRow, startCol);\n            }\n        }\n\n        noStroke();\n        fill(\"white\");\n        rect(startRow + 1, startCol + 1, 38, 38);\n        ellipseMode(CENTER);\n        fill(color);\n        ellipse(startRow + 20, startCol + 20, 15, 15);\n    };\n\n\n    this.getNeighbor = function () {\n\n        // const neighborsIndices = [\n        //     [row - 1, col],\n        //     [row + 1, col],\n        //     [row, col - 1],\n        //     [row, col + 1]            \n        // ]\n        // console.log(row)\n        // console.log(col)\n        // console.log(grid)\n\n        const top = grid[row - 1];\n        const right = grid[row + 1];\n        const bottom = grid[row];\n        const left = grid[row];\n\n        const neighbors = []\n\n        if (top) {\n            neighbors.push(grid[row - 1][col]);\n        }\n\n        if (right) {\n            neighbors.push(grid[row + 1][col]);\n        }\n\n        if (bottom) {\n            neighbors.push(grid[row][col - 1]);\n        }\n\n        if (left) {\n            neighbors.push(grid[row][col + 1]);\n        }\n\n\n        // const neighbors = [\n        //     grid[row - 1][col],\n        //     grid[row + 1][col],\n        //     grid[row][col - 1],\n        //     grid[row][col + 1]\n        // ]\n        //  const neighborsIndices = [\n        //     [row - 1, col],\n        //     [row + 1, col],\n        //     [row, col - 1],\n        //     [row, col + 1]            \n        // ]\n\n        // const neighbors = [];\n\n        // const validateIdx = function (idx) {\n        //     idx >= 0 && idx < 20\n        // }\n        // for(let i = 0; i < neighborsIndices.length; i++){\n        //     if(validateIdx(neighborsIndices[i][0]) && validateIdx(neighborsIndices[i][1])){\n        //         neighbors.push(grid[neighborsIndices[i][0]][neighborsIndices[i][1]])\n        //     }\n        // }\n\n\n        // let top = [(row - 1), col];\n        // validateIdx(top);\n        // let right = [row, (col+1)];\n        // validateIdx(right);\n        // let bottom = [(row + 1), col];\n        // validateIdx(bottom);\n        // let left = [row, (col - 1)];\n        // validateIdx(left);\n        // console.log(\"neighbors\")\n        // console.log(neighbors)\n\n        const validNeighbors = [];\n\n        // for(let i = 0; i < neighbors.length; i++){\n        //     if ((neighbors[i][0] < 20 && neighbors[i][0] >= 0) && (neighbors[i][1] < 20 && neighbors[i][1] >= 0)) {\n        //         validNeighbors.push(neighbors[i]);\n        //     }\n        // }\n\n        // const validNeighbors = neighbors.filter(neighbor => {\n        //     // let x = neighbor[0];\n        //     // let y = neighbor[1];\n\n        //     if((neighbor[0] < 20 && neighbor[0] >= 0) && (neighbor[1] < 20 && neighbor[1] >= 0)){\n        //         return neighbor;\n        //     }\n        // }\n\n        // const validateNeighbors = function(neighbor) {\n        //     if(!neighbor){\n        //         return false;\n        //     }\n        //     // let x = neighbor[0];\n        //     // let y = neighbor[1];\n\n        //     if(neighbor.row < 20 || neighbor.row >=0){\n        //         return false;\n        //     } else if(neighbor.col < 20 || neighbor.col >= 0){\n        //         return false;\n        //     } else{\n        //         return true\n        //     }\n\n        // }\n\n        // const validateNeighbors = function(neighbor){\n        //     console.log(neighbor)\n        //     neighbor\n        // }\n\n        // const validNeighbors = neighbors.filter(validateNeighbors);\n\n        // for (let i = 0; i < neighbors.length; i++) {\n        //     if (neighbors[i] && !(neighbors[i].visited)) {\n        //         if(neighbors[i].row < 20 && neighbors[i].row >=0){\n        //             if(neighbors[i].col < 20 && neighbors[i].col >= 0){\n\n        //                 validNeighbors.push(neighbors[i])\n        //             }\n        //         }\n        //     }\n        // }\n\n        for (let i = 0; i < neighbors.length; i++) {\n            if (neighbors[i] && !(neighbors[i].visited)) {\n                // if(neighbors[i].row < 20 && neighbors[i].row >=0){\n                //     if(neighbors[i].col < 20 && neighbors[i].col >= 0){\n\n                validNeighbors.push(neighbors[i])\n                // }\n                // }\n            }\n        }\n\n\n        // console.log(\"valid\")\n        // console.log(validNeighbors)\n\n        let nextCell;\n\n        if (validNeighbors.length > 0) {\n            nextCell = this.chooseRandomNeighbor(validNeighbors);\n            return nextCell;\n        } else {\n            return undefined;\n        }\n        // let nextCell = \n\n        // //need to check if nextCell is true bc it could be undefined at the edges\n        // while(nextCell && nextCell.visited){\n        //     nextCell = this.chooseRandomNeighbor(neighbors)\n\n        //     if(nextCell && !nextCell.visited){\n        //         return nextCell\n        //     }\n        // }\n\n        // if (nextCell) {\n        //     rect(startRow, startCol, 40, 40)\n        //     fill(\"purple\");\n        // }\n        // console.log(nextCell)\n        // return nextCell;\n\n    }\n\n    this.chooseRandomNeighbor = function (validNeighbors) {\n        return validNeighbors[Math.floor(Math.random() * validNeighbors.length)]\n    }\n\n}\n\nmodule.exports = Cell;\n\n// const Wall = require('./wall');\n\n// function Cell(row, col, grid) {\n//     this.row = row;\n//     this.col = col;\n//     this.grid = grid;\n//     this.walls = [new Wall(), new Wall(), new Wall(), new Wall()];\n//     // this.walls = []\n//     this.visited = false;\n\n//     // [1, 2, 3, 4].forEach(() => this.walls.push(new Wall()));\n\n//     this.highlight = function(){\n//         // console.log(this.row, this.col);\n//         const startRow = this.row * 40;\n//         const startCol = this.col * 40;\n//         noStroke();\n//         fill(\"purple\");\n//         rect(startRow, startCol, 40, 40)\n//     }\n\n//     this.render = function () {\n//         const startRow = this.row * 40;\n//         const startCol = this.col * 40;\n\n//         // x, y, width, height\n//         // rect(startX, startY, 40, 40)\n//         // noFill();\n\n//         for (let i = 0; i < this.walls.length; i++) {\n//             if(this.walls[i].present){\n//                 this.walls[i].render(i, startRow, startCol);\n//             } else {\n//                 this.walls[i].derender(i, startRow, startCol);\n//             }\n//         }\n\n\n//         if (this.visited) {\n//             noStroke();\n//             fill(\"white\");\n//             rect(startRow+1, startCol+1, 38, 38)\n//         }\n\n\n//     }\n\n\n//     this.getNeighbor = function () {\n\n//         // const neighborsIndices = [\n//         //     [row - 1, col],\n//         //     [row + 1, col],\n//         //     [row, col - 1],\n//         //     [row, col + 1]            \n//         // ]\n//         // console.log(row)\n//         // console.log(col)\n//         // console.log(grid)\n\n//         const top = grid[row - 1];\n//         const right = grid[row + 1];\n//         const bottom = grid[row];\n//         const left = grid[row];\n\n//         const neighbors = []\n\n//         if(top){\n//             neighbors.push(grid[row - 1][col]);\n//         }\n\n//         if(right){\n//             neighbors.push(grid[row + 1][col]);\n//         }\n\n//         if (bottom) {\n//             neighbors.push(grid[row][col - 1]);\n//         }\n\n//         if (left) {\n//             neighbors.push(grid[row][col + 1]);\n//         }\n\n\n//         // const neighbors = [\n//         //     grid[row - 1][col],\n//         //     grid[row + 1][col],\n//         //     grid[row][col - 1],\n//         //     grid[row][col + 1]\n//         // ]\n//         //  const neighborsIndices = [\n//         //     [row - 1, col],\n//         //     [row + 1, col],\n//         //     [row, col - 1],\n//         //     [row, col + 1]            \n//         // ]\n\n//         // const neighbors = [];\n\n//         // const validateIdx = function (idx) {\n//         //     idx >= 0 && idx < 20\n//         // }\n//         // for(let i = 0; i < neighborsIndices.length; i++){\n//         //     if(validateIdx(neighborsIndices[i][0]) && validateIdx(neighborsIndices[i][1])){\n//         //         neighbors.push(grid[neighborsIndices[i][0]][neighborsIndices[i][1]])\n//         //     }\n//         // }\n\n\n//         // let top = [(row - 1), col];\n//         // validateIdx(top);\n//         // let right = [row, (col+1)];\n//         // validateIdx(right);\n//         // let bottom = [(row + 1), col];\n//         // validateIdx(bottom);\n//         // let left = [row, (col - 1)];\n//         // validateIdx(left);\n//         // console.log(\"neighbors\")\n//         // console.log(neighbors)\n\n//         const validNeighbors = [];\n\n//         // for(let i = 0; i < neighbors.length; i++){\n//         //     if ((neighbors[i][0] < 20 && neighbors[i][0] >= 0) && (neighbors[i][1] < 20 && neighbors[i][1] >= 0)) {\n//         //         validNeighbors.push(neighbors[i]);\n//         //     }\n//         // }\n\n//         // const validNeighbors = neighbors.filter(neighbor => {\n//         //     // let x = neighbor[0];\n//         //     // let y = neighbor[1];\n\n//         //     if((neighbor[0] < 20 && neighbor[0] >= 0) && (neighbor[1] < 20 && neighbor[1] >= 0)){\n//         //         return neighbor;\n//         //     }\n//         // }\n\n//         // const validateNeighbors = function(neighbor) {\n//         //     if(!neighbor){\n//         //         return false;\n//         //     }\n//         //     // let x = neighbor[0];\n//         //     // let y = neighbor[1];\n\n//         //     if(neighbor.row < 20 || neighbor.row >=0){\n//         //         return false;\n//         //     } else if(neighbor.col < 20 || neighbor.col >= 0){\n//         //         return false;\n//         //     } else{\n//         //         return true\n//         //     }\n\n//         // }\n\n//         // const validateNeighbors = function(neighbor){\n//         //     console.log(neighbor)\n//         //     neighbor\n//         // }\n\n//         // const validNeighbors = neighbors.filter(validateNeighbors);\n\n//         // for (let i = 0; i < neighbors.length; i++) {\n//         //     if (neighbors[i] && !(neighbors[i].visited)) {\n//         //         if(neighbors[i].row < 20 && neighbors[i].row >=0){\n//         //             if(neighbors[i].col < 20 && neighbors[i].col >= 0){\n\n//         //                 validNeighbors.push(neighbors[i])\n//         //             }\n//         //         }\n//         //     }\n//         // }\n\n//           for (let i = 0; i < neighbors.length; i++) {\n//             if (neighbors[i] && !(neighbors[i].visited)) {\n//                 // if(neighbors[i].row < 20 && neighbors[i].row >=0){\n//                 //     if(neighbors[i].col < 20 && neighbors[i].col >= 0){\n\n//                         validNeighbors.push(neighbors[i])\n//                     // }\n//                 // }\n//             }\n//         }\n\n\n//         // console.log(\"valid\")\n//         // console.log(validNeighbors)\n\n//         let nextCell;\n\n//         if (validNeighbors.length > 0) {\n//             nextCell = this.chooseRandomNeighbor(validNeighbors);\n//             return nextCell;\n//         } else{\n//             return undefined;\n//         }\n//         // let nextCell = \n\n//         // //need to check if nextCell is true bc it could be undefined at the edges\n//         // while(nextCell && nextCell.visited){\n//         //     nextCell = this.chooseRandomNeighbor(neighbors)\n\n//         //     if(nextCell && !nextCell.visited){\n//         //         return nextCell\n//         //     }\n//         // }\n\n//         // if (nextCell) {\n//         //     rect(startRow, startCol, 40, 40)\n//         //     fill(\"purple\");\n//         // }\n//         // console.log(nextCell)\n//         // return nextCell;\n\n//     }\n\n//     this.chooseRandomNeighbor = function (validNeighbors) {\n//         return validNeighbors[Math.floor(Math.random() * validNeighbors.length)]\n//     }\n\n// }\n\n// module.exports = Cell;\n\n\n// const Wall = require('./wall');\n\n// function Cell(row, col, grid) {\n//     grid = grid || 0\n//     // userColor = userColor || 0\n\n//     this.row = row;\n//     this.col = col;\n//     this.grid = grid;\n//     // this.userColor = userColor;\n//     this.walls = [new Wall(), new Wall(), new Wall(), new Wall()];\n//     // this.walls = []\n//     this.visited = false;\n//     this.hasUser = false;\n\n//     // [1, 2, 3, 4].forEach(() => this.walls.push(new Wall()));\n\n//     this.highlight = function () {\n//         // console.log(this.row, this.col);\n//         const startRow = this.row * 40;\n//         const startCol = this.col * 40;\n//         noStroke();\n//         fill(\"purple\");\n//         rect(startRow, startCol, 40, 40)\n//     }\n\n//     this.render = function () {\n\n//         const startRow = this.row * 40;\n//         const startCol = this.col * 40;\n\n//         // x, y, width, height\n//         // rect(startX, startY, 40, 40)\n//         // noFill();\n\n//         for (let i = 0; i < this.walls.length; i++) {\n//             if (this.walls[i].present) {\n//                 this.walls[i].render(i, startRow, startCol);\n//             } else {\n//                 this.walls[i].derender(i, startRow, startCol);\n//             }\n//         }\n\n\n//         if (this.visited) {\n//             noStroke();\n//             fill(\"white\");\n//             rect(startRow + 1, startCol + 1, 38, 38)\n//         }\n\n//     }\n\n//     this.rerender = function (color) {\n\n//         const startRow = this.row * 40;\n//         const startCol = this.col * 40;\n\n//         // x, y, width, height\n//         // rect(startX, startY, 40, 40)\n//         // noFill();\n\n//         for (let i = 0; i < this.walls.length; i++) {\n//             if (this.walls[i].present) {\n//                 this.walls[i].render(i, startRow, startCol);\n//             } else {\n//                 this.walls[i].derender(i, startRow, startCol);\n//             }\n//         }\n\n\n//         // if (this.visited) {\n//         //     noStroke();\n//         //     fill(\"white\");\n//         //     rect(startRow + 1, startCol + 1, 38, 38)\n//         // }\n\n//         if (this.hasUser) {\n//             noStroke();\n//             fill(\"white\");\n//             rect(startRow + 1, startCol + 1, 38, 38);\n//             ellipseMode(CENTER);\n//             fill(color);\n//             ellipse(startRow + 20, startCol + 20, 15, 15);\n//         }\n\n//     }\n\n//     // this.resetRender = function(){\n//     //     this.render()\n//     // }\n\n\n//     this.getNeighbor = function () {\n\n//         // const neighborsIndices = [\n//         //     [row - 1, col],\n//         //     [row + 1, col],\n//         //     [row, col - 1],\n//         //     [row, col + 1]            \n//         // ]\n//         // console.log(row)\n//         // console.log(col)\n//         // console.log(grid)\n\n//         const top = grid[row - 1];\n//         const right = grid[row + 1];\n//         const bottom = grid[row];\n//         const left = grid[row];\n\n//         const neighbors = []\n\n//         if (top) {\n//             neighbors.push(grid[row - 1][col]);\n//         }\n\n//         if (right) {\n//             neighbors.push(grid[row + 1][col]);\n//         }\n\n//         if (bottom) {\n//             neighbors.push(grid[row][col - 1]);\n//         }\n\n//         if (left) {\n//             neighbors.push(grid[row][col + 1]);\n//         }\n\n\n//         // const neighbors = [\n//         //     grid[row - 1][col],\n//         //     grid[row + 1][col],\n//         //     grid[row][col - 1],\n//         //     grid[row][col + 1]\n//         // ]\n//         //  const neighborsIndices = [\n//         //     [row - 1, col],\n//         //     [row + 1, col],\n//         //     [row, col - 1],\n//         //     [row, col + 1]            \n//         // ]\n\n//         // const neighbors = [];\n\n//         // const validateIdx = function (idx) {\n//         //     idx >= 0 && idx < 20\n//         // }\n//         // for(let i = 0; i < neighborsIndices.length; i++){\n//         //     if(validateIdx(neighborsIndices[i][0]) && validateIdx(neighborsIndices[i][1])){\n//         //         neighbors.push(grid[neighborsIndices[i][0]][neighborsIndices[i][1]])\n//         //     }\n//         // }\n\n\n//         // let top = [(row - 1), col];\n//         // validateIdx(top);\n//         // let right = [row, (col+1)];\n//         // validateIdx(right);\n//         // let bottom = [(row + 1), col];\n//         // validateIdx(bottom);\n//         // let left = [row, (col - 1)];\n//         // validateIdx(left);\n//         // console.log(\"neighbors\")\n//         // console.log(neighbors)\n\n//         const validNeighbors = [];\n\n//         // for(let i = 0; i < neighbors.length; i++){\n//         //     if ((neighbors[i][0] < 20 && neighbors[i][0] >= 0) && (neighbors[i][1] < 20 && neighbors[i][1] >= 0)) {\n//         //         validNeighbors.push(neighbors[i]);\n//         //     }\n//         // }\n\n//         // const validNeighbors = neighbors.filter(neighbor => {\n//         //     // let x = neighbor[0];\n//         //     // let y = neighbor[1];\n\n//         //     if((neighbor[0] < 20 && neighbor[0] >= 0) && (neighbor[1] < 20 && neighbor[1] >= 0)){\n//         //         return neighbor;\n//         //     }\n//         // }\n\n//         // const validateNeighbors = function(neighbor) {\n//         //     if(!neighbor){\n//         //         return false;\n//         //     }\n//         //     // let x = neighbor[0];\n//         //     // let y = neighbor[1];\n\n//         //     if(neighbor.row < 20 || neighbor.row >=0){\n//         //         return false;\n//         //     } else if(neighbor.col < 20 || neighbor.col >= 0){\n//         //         return false;\n//         //     } else{\n//         //         return true\n//         //     }\n\n//         // }\n\n//         // const validateNeighbors = function(neighbor){\n//         //     console.log(neighbor)\n//         //     neighbor\n//         // }\n\n//         // const validNeighbors = neighbors.filter(validateNeighbors);\n\n//         // for (let i = 0; i < neighbors.length; i++) {\n//         //     if (neighbors[i] && !(neighbors[i].visited)) {\n//         //         if(neighbors[i].row < 20 && neighbors[i].row >=0){\n//         //             if(neighbors[i].col < 20 && neighbors[i].col >= 0){\n\n//         //                 validNeighbors.push(neighbors[i])\n//         //             }\n//         //         }\n//         //     }\n//         // }\n\n//         for (let i = 0; i < neighbors.length; i++) {\n//             if (neighbors[i] && !(neighbors[i].visited)) {\n//                 // if(neighbors[i].row < 20 && neighbors[i].row >=0){\n//                 //     if(neighbors[i].col < 20 && neighbors[i].col >= 0){\n\n//                 validNeighbors.push(neighbors[i])\n//                 // }\n//                 // }\n//             }\n//         }\n\n\n//         // console.log(\"valid\")\n//         // console.log(validNeighbors)\n\n//         let nextCell;\n\n//         if (validNeighbors.length > 0) {\n//             nextCell = this.chooseRandomNeighbor(validNeighbors);\n//             return nextCell;\n//         } else {\n//             return undefined;\n//         }\n//         // let nextCell = \n\n//         // //need to check if nextCell is true bc it could be undefined at the edges\n//         // while(nextCell && nextCell.visited){\n//         //     nextCell = this.chooseRandomNeighbor(neighbors)\n\n//         //     if(nextCell && !nextCell.visited){\n//         //         return nextCell\n//         //     }\n//         // }\n\n//         // if (nextCell) {\n//         //     rect(startRow, startCol, 40, 40)\n//         //     fill(\"purple\");\n//         // }\n//         // console.log(nextCell)\n//         // return nextCell;\n\n//     }\n\n//     this.chooseRandomNeighbor = function (validNeighbors) {\n//         return validNeighbors[Math.floor(Math.random() * validNeighbors.length)]\n//     }\n\n//     this.renderUser = function(currentColor){\n//         this.hasUser = true;\n//         this.rerender(currentColor)\n//         // fill(this.userColor);\n//         // ellipse(20, 20, 15, 15);\n//     }\n\n// }\n\n// module.exports = Cell;\n\n// // const Wall = require('./wall');\n\n// // function Cell(row, col, grid) {\n// //     this.row = row;\n// //     this.col = col;\n// //     this.grid = grid;\n// //     this.walls = [new Wall(), new Wall(), new Wall(), new Wall()];\n// //     // this.walls = []\n// //     this.visited = false;\n\n// //     // [1, 2, 3, 4].forEach(() => this.walls.push(new Wall()));\n\n// //     this.highlight = function(){\n// //         // console.log(this.row, this.col);\n// //         const startRow = this.row * 40;\n// //         const startCol = this.col * 40;\n// //         noStroke();\n// //         fill(\"purple\");\n// //         rect(startRow, startCol, 40, 40)\n// //     }\n\n// //     this.render = function () {\n// //         const startRow = this.row * 40;\n// //         const startCol = this.col * 40;\n\n// //         // x, y, width, height\n// //         // rect(startX, startY, 40, 40)\n// //         // noFill();\n\n// //         for (let i = 0; i < this.walls.length; i++) {\n// //             if(this.walls[i].present){\n// //                 this.walls[i].render(i, startRow, startCol);\n// //             } else {\n// //                 this.walls[i].derender(i, startRow, startCol);\n// //             }\n// //         }\n\n\n// //         if (this.visited) {\n// //             noStroke();\n// //             fill(\"white\");\n// //             rect(startRow+1, startCol+1, 38, 38)\n// //         }\n\n\n// //     }\n\n\n// //     this.getNeighbor = function () {\n\n// //         // const neighborsIndices = [\n// //         //     [row - 1, col],\n// //         //     [row + 1, col],\n// //         //     [row, col - 1],\n// //         //     [row, col + 1]            \n// //         // ]\n// //         // console.log(row)\n// //         // console.log(col)\n// //         // console.log(grid)\n\n// //         const top = grid[row - 1];\n// //         const right = grid[row + 1];\n// //         const bottom = grid[row];\n// //         const left = grid[row];\n\n// //         const neighbors = []\n\n// //         if(top){\n// //             neighbors.push(grid[row - 1][col]);\n// //         }\n\n// //         if(right){\n// //             neighbors.push(grid[row + 1][col]);\n// //         }\n\n// //         if (bottom) {\n// //             neighbors.push(grid[row][col - 1]);\n// //         }\n\n// //         if (left) {\n// //             neighbors.push(grid[row][col + 1]);\n// //         }\n\n\n// //         // const neighbors = [\n// //         //     grid[row - 1][col],\n// //         //     grid[row + 1][col],\n// //         //     grid[row][col - 1],\n// //         //     grid[row][col + 1]\n// //         // ]\n// //         //  const neighborsIndices = [\n// //         //     [row - 1, col],\n// //         //     [row + 1, col],\n// //         //     [row, col - 1],\n// //         //     [row, col + 1]            \n// //         // ]\n\n// //         // const neighbors = [];\n\n// //         // const validateIdx = function (idx) {\n// //         //     idx >= 0 && idx < 20\n// //         // }\n// //         // for(let i = 0; i < neighborsIndices.length; i++){\n// //         //     if(validateIdx(neighborsIndices[i][0]) && validateIdx(neighborsIndices[i][1])){\n// //         //         neighbors.push(grid[neighborsIndices[i][0]][neighborsIndices[i][1]])\n// //         //     }\n// //         // }\n\n\n// //         // let top = [(row - 1), col];\n// //         // validateIdx(top);\n// //         // let right = [row, (col+1)];\n// //         // validateIdx(right);\n// //         // let bottom = [(row + 1), col];\n// //         // validateIdx(bottom);\n// //         // let left = [row, (col - 1)];\n// //         // validateIdx(left);\n// //         // console.log(\"neighbors\")\n// //         // console.log(neighbors)\n\n// //         const validNeighbors = [];\n\n// //         // for(let i = 0; i < neighbors.length; i++){\n// //         //     if ((neighbors[i][0] < 20 && neighbors[i][0] >= 0) && (neighbors[i][1] < 20 && neighbors[i][1] >= 0)) {\n// //         //         validNeighbors.push(neighbors[i]);\n// //         //     }\n// //         // }\n\n// //         // const validNeighbors = neighbors.filter(neighbor => {\n// //         //     // let x = neighbor[0];\n// //         //     // let y = neighbor[1];\n\n// //         //     if((neighbor[0] < 20 && neighbor[0] >= 0) && (neighbor[1] < 20 && neighbor[1] >= 0)){\n// //         //         return neighbor;\n// //         //     }\n// //         // }\n\n// //         // const validateNeighbors = function(neighbor) {\n// //         //     if(!neighbor){\n// //         //         return false;\n// //         //     }\n// //         //     // let x = neighbor[0];\n// //         //     // let y = neighbor[1];\n\n// //         //     if(neighbor.row < 20 || neighbor.row >=0){\n// //         //         return false;\n// //         //     } else if(neighbor.col < 20 || neighbor.col >= 0){\n// //         //         return false;\n// //         //     } else{\n// //         //         return true\n// //         //     }\n\n// //         // }\n\n// //         // const validateNeighbors = function(neighbor){\n// //         //     console.log(neighbor)\n// //         //     neighbor\n// //         // }\n\n// //         // const validNeighbors = neighbors.filter(validateNeighbors);\n\n// //         // for (let i = 0; i < neighbors.length; i++) {\n// //         //     if (neighbors[i] && !(neighbors[i].visited)) {\n// //         //         if(neighbors[i].row < 20 && neighbors[i].row >=0){\n// //         //             if(neighbors[i].col < 20 && neighbors[i].col >= 0){\n\n// //         //                 validNeighbors.push(neighbors[i])\n// //         //             }\n// //         //         }\n// //         //     }\n// //         // }\n\n// //           for (let i = 0; i < neighbors.length; i++) {\n// //             if (neighbors[i] && !(neighbors[i].visited)) {\n// //                 // if(neighbors[i].row < 20 && neighbors[i].row >=0){\n// //                 //     if(neighbors[i].col < 20 && neighbors[i].col >= 0){\n\n// //                         validNeighbors.push(neighbors[i])\n// //                     // }\n// //                 // }\n// //             }\n// //         }\n\n\n// //         // console.log(\"valid\")\n// //         // console.log(validNeighbors)\n\n// //         let nextCell;\n\n// //         if (validNeighbors.length > 0) {\n// //             nextCell = this.chooseRandomNeighbor(validNeighbors);\n// //             return nextCell;\n// //         } else{\n// //             return undefined;\n// //         }\n// //         // let nextCell = \n\n// //         // //need to check if nextCell is true bc it could be undefined at the edges\n// //         // while(nextCell && nextCell.visited){\n// //         //     nextCell = this.chooseRandomNeighbor(neighbors)\n\n// //         //     if(nextCell && !nextCell.visited){\n// //         //         return nextCell\n// //         //     }\n// //         // }\n\n// //         // if (nextCell) {\n// //         //     rect(startRow, startCol, 40, 40)\n// //         //     fill(\"purple\");\n// //         // }\n// //         // console.log(nextCell)\n// //         // return nextCell;\n\n// //     }\n\n// //     this.chooseRandomNeighbor = function (validNeighbors) {\n// //         return validNeighbors[Math.floor(Math.random() * validNeighbors.length)]\n// //     }\n\n// // }\n\n// // module.exports = Cell;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jZWxsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vY2VsbC5qcz9kYjFkIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFdhbGwgPSByZXF1aXJlKCcuL3dhbGwnKTtcblxuZnVuY3Rpb24gQ2VsbChyb3csIGNvbCwgZ3JpZCkge1xuICAgIHRoaXMucm93ID0gcm93O1xuICAgIHRoaXMuY29sID0gY29sO1xuICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG4gICAgdGhpcy53YWxscyA9IFtuZXcgV2FsbCgpLCBuZXcgV2FsbCgpLCBuZXcgV2FsbCgpLCBuZXcgV2FsbCgpXTtcbiAgICAvLyB0aGlzLndhbGxzID0gW11cbiAgICB0aGlzLnZpc2l0ZWQgPSBmYWxzZTtcblxuICAgIC8vIFsxLCAyLCAzLCA0XS5mb3JFYWNoKCgpID0+IHRoaXMud2FsbHMucHVzaChuZXcgV2FsbCgpKSk7XG5cbiAgICB0aGlzLmhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5yb3csIHRoaXMuY29sKTtcbiAgICAgICAgY29uc3Qgc3RhcnRSb3cgPSB0aGlzLnJvdyAqIDQwO1xuICAgICAgICBjb25zdCBzdGFydENvbCA9IHRoaXMuY29sICogNDA7XG4gICAgICAgIG5vU3Ryb2tlKCk7XG4gICAgICAgIGZpbGwoXCJwdXJwbGVcIik7XG4gICAgICAgIHJlY3Qoc3RhcnRSb3csIHN0YXJ0Q29sLCA0MCwgNDApXG4gICAgfVxuXG4gICAgdGhpcy5tYWtlV2FsbHNGYWxzZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy53YWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy53YWxsc1tpXSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgLy8gdGhpcy5tYWtlQmxhY2sgPSBmdW5jdGlvbigpe1xuICAgIC8vICAgICBjb25zdCBzdGFydFJvdyA9IHRoaXMucm93ICogNDA7XG4gICAgLy8gICAgIGNvbnN0IHN0YXJ0Q29sID0gdGhpcy5jb2wgKiA0MDtcbiAgICAvLyAgICAgbm9TdHJva2UoKTtcbiAgICAvLyAgICAgZmlsbChcImJsYWNrXCIpO1xuICAgIC8vICAgICByZWN0KHN0YXJ0Um93LCBzdGFydENvbCwgNDAsIDQwKVxuICAgIC8vIH1cblxuICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBzdGFydFJvdyA9IHRoaXMucm93ICogNDA7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q29sID0gdGhpcy5jb2wgKiA0MDtcblxuICAgICAgICAvLyB4LCB5LCB3aWR0aCwgaGVpZ2h0XG4gICAgICAgIC8vIHJlY3Qoc3RhcnRYLCBzdGFydFksIDQwLCA0MClcbiAgICAgICAgLy8gbm9GaWxsKCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndhbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53YWxsc1tpXS5wcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxsc1tpXS5yZW5kZXIoaSwgc3RhcnRSb3csIHN0YXJ0Q29sKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxsc1tpXS5kZXJlbmRlcihpLCBzdGFydFJvdywgc3RhcnRDb2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodGhpcy52aXNpdGVkKSB7XG4gICAgICAgICAgICBub1N0cm9rZSgpO1xuICAgICAgICAgICAgZmlsbChcIndoaXRlXCIpO1xuICAgICAgICAgICAgcmVjdChzdGFydFJvdyArIDEsIHN0YXJ0Q29sICsgMSwgMzgsIDM4KVxuICAgICAgICB9XG5cblxuICAgIH1cblxuICAgIHRoaXMucmVuZGVyVXNlciA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0Um93ID0gdGhpcy5yb3cgKiA0MDtcbiAgICAgICAgY29uc3Qgc3RhcnRDb2wgPSB0aGlzLmNvbCAqIDQwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy53YWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMud2FsbHNbaV0ucHJlc2VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMud2FsbHNbaV0ucmVuZGVyKGksIHN0YXJ0Um93LCBzdGFydENvbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMud2FsbHNbaV0uZGVyZW5kZXIoaSwgc3RhcnRSb3csIHN0YXJ0Q29sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5vU3Ryb2tlKCk7XG4gICAgICAgIGZpbGwoXCJ3aGl0ZVwiKTtcbiAgICAgICAgcmVjdChzdGFydFJvdyArIDEsIHN0YXJ0Q29sICsgMSwgMzgsIDM4KTtcbiAgICAgICAgZWxsaXBzZU1vZGUoQ0VOVEVSKTtcbiAgICAgICAgZmlsbChjb2xvcik7XG4gICAgICAgIGVsbGlwc2Uoc3RhcnRSb3cgKyAyMCwgc3RhcnRDb2wgKyAyMCwgMTUsIDE1KTtcbiAgICB9O1xuXG5cbiAgICB0aGlzLmdldE5laWdoYm9yID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8vIGNvbnN0IG5laWdoYm9yc0luZGljZXMgPSBbXG4gICAgICAgIC8vICAgICBbcm93IC0gMSwgY29sXSxcbiAgICAgICAgLy8gICAgIFtyb3cgKyAxLCBjb2xdLFxuICAgICAgICAvLyAgICAgW3JvdywgY29sIC0gMV0sXG4gICAgICAgIC8vICAgICBbcm93LCBjb2wgKyAxXSAgICAgICAgICAgIFxuICAgICAgICAvLyBdXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHJvdylcbiAgICAgICAgLy8gY29uc29sZS5sb2coY29sKVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhncmlkKVxuXG4gICAgICAgIGNvbnN0IHRvcCA9IGdyaWRbcm93IC0gMV07XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gZ3JpZFtyb3cgKyAxXTtcbiAgICAgICAgY29uc3QgYm90dG9tID0gZ3JpZFtyb3ddO1xuICAgICAgICBjb25zdCBsZWZ0ID0gZ3JpZFtyb3ddO1xuXG4gICAgICAgIGNvbnN0IG5laWdoYm9ycyA9IFtdXG5cbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goZ3JpZFtyb3cgLSAxXVtjb2xdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyaWdodCkge1xuICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goZ3JpZFtyb3cgKyAxXVtjb2xdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChib3R0b20pIHtcbiAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKGdyaWRbcm93XVtjb2wgLSAxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVmdCkge1xuICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goZ3JpZFtyb3ddW2NvbCArIDFdKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gY29uc3QgbmVpZ2hib3JzID0gW1xuICAgICAgICAvLyAgICAgZ3JpZFtyb3cgLSAxXVtjb2xdLFxuICAgICAgICAvLyAgICAgZ3JpZFtyb3cgKyAxXVtjb2xdLFxuICAgICAgICAvLyAgICAgZ3JpZFtyb3ddW2NvbCAtIDFdLFxuICAgICAgICAvLyAgICAgZ3JpZFtyb3ddW2NvbCArIDFdXG4gICAgICAgIC8vIF1cbiAgICAgICAgLy8gIGNvbnN0IG5laWdoYm9yc0luZGljZXMgPSBbXG4gICAgICAgIC8vICAgICBbcm93IC0gMSwgY29sXSxcbiAgICAgICAgLy8gICAgIFtyb3cgKyAxLCBjb2xdLFxuICAgICAgICAvLyAgICAgW3JvdywgY29sIC0gMV0sXG4gICAgICAgIC8vICAgICBbcm93LCBjb2wgKyAxXSAgICAgICAgICAgIFxuICAgICAgICAvLyBdXG5cbiAgICAgICAgLy8gY29uc3QgbmVpZ2hib3JzID0gW107XG5cbiAgICAgICAgLy8gY29uc3QgdmFsaWRhdGVJZHggPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIC8vICAgICBpZHggPj0gMCAmJiBpZHggPCAyMFxuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGZvcihsZXQgaSA9IDA7IGkgPCBuZWlnaGJvcnNJbmRpY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgLy8gICAgIGlmKHZhbGlkYXRlSWR4KG5laWdoYm9yc0luZGljZXNbaV1bMF0pICYmIHZhbGlkYXRlSWR4KG5laWdoYm9yc0luZGljZXNbaV1bMV0pKXtcbiAgICAgICAgLy8gICAgICAgICBuZWlnaGJvcnMucHVzaChncmlkW25laWdoYm9yc0luZGljZXNbaV1bMF1dW25laWdoYm9yc0luZGljZXNbaV1bMV1dKVxuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG5cblxuICAgICAgICAvLyBsZXQgdG9wID0gWyhyb3cgLSAxKSwgY29sXTtcbiAgICAgICAgLy8gdmFsaWRhdGVJZHgodG9wKTtcbiAgICAgICAgLy8gbGV0IHJpZ2h0ID0gW3JvdywgKGNvbCsxKV07XG4gICAgICAgIC8vIHZhbGlkYXRlSWR4KHJpZ2h0KTtcbiAgICAgICAgLy8gbGV0IGJvdHRvbSA9IFsocm93ICsgMSksIGNvbF07XG4gICAgICAgIC8vIHZhbGlkYXRlSWR4KGJvdHRvbSk7XG4gICAgICAgIC8vIGxldCBsZWZ0ID0gW3JvdywgKGNvbCAtIDEpXTtcbiAgICAgICAgLy8gdmFsaWRhdGVJZHgobGVmdCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwibmVpZ2hib3JzXCIpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKG5laWdoYm9ycylcblxuICAgICAgICBjb25zdCB2YWxpZE5laWdoYm9ycyA9IFtdO1xuXG4gICAgICAgIC8vIGZvcihsZXQgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAvLyAgICAgaWYgKChuZWlnaGJvcnNbaV1bMF0gPCAyMCAmJiBuZWlnaGJvcnNbaV1bMF0gPj0gMCkgJiYgKG5laWdoYm9yc1tpXVsxXSA8IDIwICYmIG5laWdoYm9yc1tpXVsxXSA+PSAwKSkge1xuICAgICAgICAvLyAgICAgICAgIHZhbGlkTmVpZ2hib3JzLnB1c2gobmVpZ2hib3JzW2ldKTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGNvbnN0IHZhbGlkTmVpZ2hib3JzID0gbmVpZ2hib3JzLmZpbHRlcihuZWlnaGJvciA9PiB7XG4gICAgICAgIC8vICAgICAvLyBsZXQgeCA9IG5laWdoYm9yWzBdO1xuICAgICAgICAvLyAgICAgLy8gbGV0IHkgPSBuZWlnaGJvclsxXTtcblxuICAgICAgICAvLyAgICAgaWYoKG5laWdoYm9yWzBdIDwgMjAgJiYgbmVpZ2hib3JbMF0gPj0gMCkgJiYgKG5laWdoYm9yWzFdIDwgMjAgJiYgbmVpZ2hib3JbMV0gPj0gMCkpe1xuICAgICAgICAvLyAgICAgICAgIHJldHVybiBuZWlnaGJvcjtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGNvbnN0IHZhbGlkYXRlTmVpZ2hib3JzID0gZnVuY3Rpb24obmVpZ2hib3IpIHtcbiAgICAgICAgLy8gICAgIGlmKCFuZWlnaGJvcil7XG4gICAgICAgIC8vICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyAgICAgLy8gbGV0IHggPSBuZWlnaGJvclswXTtcbiAgICAgICAgLy8gICAgIC8vIGxldCB5ID0gbmVpZ2hib3JbMV07XG5cbiAgICAgICAgLy8gICAgIGlmKG5laWdoYm9yLnJvdyA8IDIwIHx8IG5laWdoYm9yLnJvdyA+PTApe1xuICAgICAgICAvLyAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gICAgIH0gZWxzZSBpZihuZWlnaGJvci5jb2wgPCAyMCB8fCBuZWlnaGJvci5jb2wgPj0gMCl7XG4gICAgICAgIC8vICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyAgICAgfSBlbHNle1xuICAgICAgICAvLyAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIC8vICAgICB9XG5cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGNvbnN0IHZhbGlkYXRlTmVpZ2hib3JzID0gZnVuY3Rpb24obmVpZ2hib3Ipe1xuICAgICAgICAvLyAgICAgY29uc29sZS5sb2cobmVpZ2hib3IpXG4gICAgICAgIC8vICAgICBuZWlnaGJvclxuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gY29uc3QgdmFsaWROZWlnaGJvcnMgPSBuZWlnaGJvcnMuZmlsdGVyKHZhbGlkYXRlTmVpZ2hib3JzKTtcblxuICAgICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyAgICAgaWYgKG5laWdoYm9yc1tpXSAmJiAhKG5laWdoYm9yc1tpXS52aXNpdGVkKSkge1xuICAgICAgICAvLyAgICAgICAgIGlmKG5laWdoYm9yc1tpXS5yb3cgPCAyMCAmJiBuZWlnaGJvcnNbaV0ucm93ID49MCl7XG4gICAgICAgIC8vICAgICAgICAgICAgIGlmKG5laWdoYm9yc1tpXS5jb2wgPCAyMCAmJiBuZWlnaGJvcnNbaV0uY29sID49IDApe1xuXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB2YWxpZE5laWdoYm9ycy5wdXNoKG5laWdoYm9yc1tpXSlcbiAgICAgICAgLy8gICAgICAgICAgICAgfVxuICAgICAgICAvLyAgICAgICAgIH1cbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobmVpZ2hib3JzW2ldICYmICEobmVpZ2hib3JzW2ldLnZpc2l0ZWQpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYobmVpZ2hib3JzW2ldLnJvdyA8IDIwICYmIG5laWdoYm9yc1tpXS5yb3cgPj0wKXtcbiAgICAgICAgICAgICAgICAvLyAgICAgaWYobmVpZ2hib3JzW2ldLmNvbCA8IDIwICYmIG5laWdoYm9yc1tpXS5jb2wgPj0gMCl7XG5cbiAgICAgICAgICAgICAgICB2YWxpZE5laWdoYm9ycy5wdXNoKG5laWdoYm9yc1tpXSlcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcInZhbGlkXCIpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHZhbGlkTmVpZ2hib3JzKVxuXG4gICAgICAgIGxldCBuZXh0Q2VsbDtcblxuICAgICAgICBpZiAodmFsaWROZWlnaGJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbmV4dENlbGwgPSB0aGlzLmNob29zZVJhbmRvbU5laWdoYm9yKHZhbGlkTmVpZ2hib3JzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0Q2VsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGV0IG5leHRDZWxsID0gXG5cbiAgICAgICAgLy8gLy9uZWVkIHRvIGNoZWNrIGlmIG5leHRDZWxsIGlzIHRydWUgYmMgaXQgY291bGQgYmUgdW5kZWZpbmVkIGF0IHRoZSBlZGdlc1xuICAgICAgICAvLyB3aGlsZShuZXh0Q2VsbCAmJiBuZXh0Q2VsbC52aXNpdGVkKXtcbiAgICAgICAgLy8gICAgIG5leHRDZWxsID0gdGhpcy5jaG9vc2VSYW5kb21OZWlnaGJvcihuZWlnaGJvcnMpXG5cbiAgICAgICAgLy8gICAgIGlmKG5leHRDZWxsICYmICFuZXh0Q2VsbC52aXNpdGVkKXtcbiAgICAgICAgLy8gICAgICAgICByZXR1cm4gbmV4dENlbGxcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGlmIChuZXh0Q2VsbCkge1xuICAgICAgICAvLyAgICAgcmVjdChzdGFydFJvdywgc3RhcnRDb2wsIDQwLCA0MClcbiAgICAgICAgLy8gICAgIGZpbGwoXCJwdXJwbGVcIik7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2cobmV4dENlbGwpXG4gICAgICAgIC8vIHJldHVybiBuZXh0Q2VsbDtcblxuICAgIH1cblxuICAgIHRoaXMuY2hvb3NlUmFuZG9tTmVpZ2hib3IgPSBmdW5jdGlvbiAodmFsaWROZWlnaGJvcnMpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkTmVpZ2hib3JzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHZhbGlkTmVpZ2hib3JzLmxlbmd0aCldXG4gICAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2VsbDtcblxuLy8gY29uc3QgV2FsbCA9IHJlcXVpcmUoJy4vd2FsbCcpO1xuXG4vLyBmdW5jdGlvbiBDZWxsKHJvdywgY29sLCBncmlkKSB7XG4vLyAgICAgdGhpcy5yb3cgPSByb3c7XG4vLyAgICAgdGhpcy5jb2wgPSBjb2w7XG4vLyAgICAgdGhpcy5ncmlkID0gZ3JpZDtcbi8vICAgICB0aGlzLndhbGxzID0gW25ldyBXYWxsKCksIG5ldyBXYWxsKCksIG5ldyBXYWxsKCksIG5ldyBXYWxsKCldO1xuLy8gICAgIC8vIHRoaXMud2FsbHMgPSBbXVxuLy8gICAgIHRoaXMudmlzaXRlZCA9IGZhbHNlO1xuXG4vLyAgICAgLy8gWzEsIDIsIDMsIDRdLmZvckVhY2goKCkgPT4gdGhpcy53YWxscy5wdXNoKG5ldyBXYWxsKCkpKTtcblxuLy8gICAgIHRoaXMuaGlnaGxpZ2h0ID0gZnVuY3Rpb24oKXtcbi8vICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5yb3csIHRoaXMuY29sKTtcbi8vICAgICAgICAgY29uc3Qgc3RhcnRSb3cgPSB0aGlzLnJvdyAqIDQwO1xuLy8gICAgICAgICBjb25zdCBzdGFydENvbCA9IHRoaXMuY29sICogNDA7XG4vLyAgICAgICAgIG5vU3Ryb2tlKCk7XG4vLyAgICAgICAgIGZpbGwoXCJwdXJwbGVcIik7XG4vLyAgICAgICAgIHJlY3Qoc3RhcnRSb3csIHN0YXJ0Q29sLCA0MCwgNDApXG4vLyAgICAgfVxuXG4vLyAgICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgIGNvbnN0IHN0YXJ0Um93ID0gdGhpcy5yb3cgKiA0MDtcbi8vICAgICAgICAgY29uc3Qgc3RhcnRDb2wgPSB0aGlzLmNvbCAqIDQwO1xuXG4vLyAgICAgICAgIC8vIHgsIHksIHdpZHRoLCBoZWlnaHRcbi8vICAgICAgICAgLy8gcmVjdChzdGFydFgsIHN0YXJ0WSwgNDAsIDQwKVxuLy8gICAgICAgICAvLyBub0ZpbGwoKTtcblxuLy8gICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMud2FsbHMubGVuZ3RoOyBpKyspIHtcbi8vICAgICAgICAgICAgIGlmKHRoaXMud2FsbHNbaV0ucHJlc2VudCl7XG4vLyAgICAgICAgICAgICAgICAgdGhpcy53YWxsc1tpXS5yZW5kZXIoaSwgc3RhcnRSb3csIHN0YXJ0Q29sKTtcbi8vICAgICAgICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgdGhpcy53YWxsc1tpXS5kZXJlbmRlcihpLCBzdGFydFJvdywgc3RhcnRDb2wpO1xuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICB9XG5cblxuLy8gICAgICAgICBpZiAodGhpcy52aXNpdGVkKSB7XG4vLyAgICAgICAgICAgICBub1N0cm9rZSgpO1xuLy8gICAgICAgICAgICAgZmlsbChcIndoaXRlXCIpO1xuLy8gICAgICAgICAgICAgcmVjdChzdGFydFJvdysxLCBzdGFydENvbCsxLCAzOCwgMzgpXG4vLyAgICAgICAgIH1cblxuXG4vLyAgICAgfVxuXG5cbi8vICAgICB0aGlzLmdldE5laWdoYm9yID0gZnVuY3Rpb24gKCkge1xuXG4vLyAgICAgICAgIC8vIGNvbnN0IG5laWdoYm9yc0luZGljZXMgPSBbXG4vLyAgICAgICAgIC8vICAgICBbcm93IC0gMSwgY29sXSxcbi8vICAgICAgICAgLy8gICAgIFtyb3cgKyAxLCBjb2xdLFxuLy8gICAgICAgICAvLyAgICAgW3JvdywgY29sIC0gMV0sXG4vLyAgICAgICAgIC8vICAgICBbcm93LCBjb2wgKyAxXSAgICAgICAgICAgIFxuLy8gICAgICAgICAvLyBdXG4vLyAgICAgICAgIC8vIGNvbnNvbGUubG9nKHJvdylcbi8vICAgICAgICAgLy8gY29uc29sZS5sb2coY29sKVxuLy8gICAgICAgICAvLyBjb25zb2xlLmxvZyhncmlkKVxuXG4vLyAgICAgICAgIGNvbnN0IHRvcCA9IGdyaWRbcm93IC0gMV07XG4vLyAgICAgICAgIGNvbnN0IHJpZ2h0ID0gZ3JpZFtyb3cgKyAxXTtcbi8vICAgICAgICAgY29uc3QgYm90dG9tID0gZ3JpZFtyb3ddO1xuLy8gICAgICAgICBjb25zdCBsZWZ0ID0gZ3JpZFtyb3ddO1xuXG4vLyAgICAgICAgIGNvbnN0IG5laWdoYm9ycyA9IFtdXG5cbi8vICAgICAgICAgaWYodG9wKXtcbi8vICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKGdyaWRbcm93IC0gMV1bY29sXSk7XG4vLyAgICAgICAgIH1cblxuLy8gICAgICAgICBpZihyaWdodCl7XG4vLyAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChncmlkW3JvdyArIDFdW2NvbF0pO1xuLy8gICAgICAgICB9XG5cbi8vICAgICAgICAgaWYgKGJvdHRvbSkge1xuLy8gICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goZ3JpZFtyb3ddW2NvbCAtIDFdKTtcbi8vICAgICAgICAgfVxuXG4vLyAgICAgICAgIGlmIChsZWZ0KSB7XG4vLyAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChncmlkW3Jvd11bY29sICsgMV0pO1xuLy8gICAgICAgICB9XG5cblxuLy8gICAgICAgICAvLyBjb25zdCBuZWlnaGJvcnMgPSBbXG4vLyAgICAgICAgIC8vICAgICBncmlkW3JvdyAtIDFdW2NvbF0sXG4vLyAgICAgICAgIC8vICAgICBncmlkW3JvdyArIDFdW2NvbF0sXG4vLyAgICAgICAgIC8vICAgICBncmlkW3Jvd11bY29sIC0gMV0sXG4vLyAgICAgICAgIC8vICAgICBncmlkW3Jvd11bY29sICsgMV1cbi8vICAgICAgICAgLy8gXVxuLy8gICAgICAgICAvLyAgY29uc3QgbmVpZ2hib3JzSW5kaWNlcyA9IFtcbi8vICAgICAgICAgLy8gICAgIFtyb3cgLSAxLCBjb2xdLFxuLy8gICAgICAgICAvLyAgICAgW3JvdyArIDEsIGNvbF0sXG4vLyAgICAgICAgIC8vICAgICBbcm93LCBjb2wgLSAxXSxcbi8vICAgICAgICAgLy8gICAgIFtyb3csIGNvbCArIDFdICAgICAgICAgICAgXG4vLyAgICAgICAgIC8vIF1cblxuLy8gICAgICAgICAvLyBjb25zdCBuZWlnaGJvcnMgPSBbXTtcblxuLy8gICAgICAgICAvLyBjb25zdCB2YWxpZGF0ZUlkeCA9IGZ1bmN0aW9uIChpZHgpIHtcbi8vICAgICAgICAgLy8gICAgIGlkeCA+PSAwICYmIGlkeCA8IDIwXG4vLyAgICAgICAgIC8vIH1cbi8vICAgICAgICAgLy8gZm9yKGxldCBpID0gMDsgaSA8IG5laWdoYm9yc0luZGljZXMubGVuZ3RoOyBpKyspe1xuLy8gICAgICAgICAvLyAgICAgaWYodmFsaWRhdGVJZHgobmVpZ2hib3JzSW5kaWNlc1tpXVswXSkgJiYgdmFsaWRhdGVJZHgobmVpZ2hib3JzSW5kaWNlc1tpXVsxXSkpe1xuLy8gICAgICAgICAvLyAgICAgICAgIG5laWdoYm9ycy5wdXNoKGdyaWRbbmVpZ2hib3JzSW5kaWNlc1tpXVswXV1bbmVpZ2hib3JzSW5kaWNlc1tpXVsxXV0pXG4vLyAgICAgICAgIC8vICAgICB9XG4vLyAgICAgICAgIC8vIH1cblxuXG4vLyAgICAgICAgIC8vIGxldCB0b3AgPSBbKHJvdyAtIDEpLCBjb2xdO1xuLy8gICAgICAgICAvLyB2YWxpZGF0ZUlkeCh0b3ApO1xuLy8gICAgICAgICAvLyBsZXQgcmlnaHQgPSBbcm93LCAoY29sKzEpXTtcbi8vICAgICAgICAgLy8gdmFsaWRhdGVJZHgocmlnaHQpO1xuLy8gICAgICAgICAvLyBsZXQgYm90dG9tID0gWyhyb3cgKyAxKSwgY29sXTtcbi8vICAgICAgICAgLy8gdmFsaWRhdGVJZHgoYm90dG9tKTtcbi8vICAgICAgICAgLy8gbGV0IGxlZnQgPSBbcm93LCAoY29sIC0gMSldO1xuLy8gICAgICAgICAvLyB2YWxpZGF0ZUlkeChsZWZ0KTtcbi8vICAgICAgICAgLy8gY29uc29sZS5sb2coXCJuZWlnaGJvcnNcIilcbi8vICAgICAgICAgLy8gY29uc29sZS5sb2cobmVpZ2hib3JzKVxuXG4vLyAgICAgICAgIGNvbnN0IHZhbGlkTmVpZ2hib3JzID0gW107XG5cbi8vICAgICAgICAgLy8gZm9yKGxldCBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7IGkrKyl7XG4vLyAgICAgICAgIC8vICAgICBpZiAoKG5laWdoYm9yc1tpXVswXSA8IDIwICYmIG5laWdoYm9yc1tpXVswXSA+PSAwKSAmJiAobmVpZ2hib3JzW2ldWzFdIDwgMjAgJiYgbmVpZ2hib3JzW2ldWzFdID49IDApKSB7XG4vLyAgICAgICAgIC8vICAgICAgICAgdmFsaWROZWlnaGJvcnMucHVzaChuZWlnaGJvcnNbaV0pO1xuLy8gICAgICAgICAvLyAgICAgfVxuLy8gICAgICAgICAvLyB9XG5cbi8vICAgICAgICAgLy8gY29uc3QgdmFsaWROZWlnaGJvcnMgPSBuZWlnaGJvcnMuZmlsdGVyKG5laWdoYm9yID0+IHtcbi8vICAgICAgICAgLy8gICAgIC8vIGxldCB4ID0gbmVpZ2hib3JbMF07XG4vLyAgICAgICAgIC8vICAgICAvLyBsZXQgeSA9IG5laWdoYm9yWzFdO1xuXG4vLyAgICAgICAgIC8vICAgICBpZigobmVpZ2hib3JbMF0gPCAyMCAmJiBuZWlnaGJvclswXSA+PSAwKSAmJiAobmVpZ2hib3JbMV0gPCAyMCAmJiBuZWlnaGJvclsxXSA+PSAwKSl7XG4vLyAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIG5laWdoYm9yO1xuLy8gICAgICAgICAvLyAgICAgfVxuLy8gICAgICAgICAvLyB9XG5cbi8vICAgICAgICAgLy8gY29uc3QgdmFsaWRhdGVOZWlnaGJvcnMgPSBmdW5jdGlvbihuZWlnaGJvcikge1xuLy8gICAgICAgICAvLyAgICAgaWYoIW5laWdoYm9yKXtcbi8vICAgICAgICAgLy8gICAgICAgICByZXR1cm4gZmFsc2U7XG4vLyAgICAgICAgIC8vICAgICB9XG4vLyAgICAgICAgIC8vICAgICAvLyBsZXQgeCA9IG5laWdoYm9yWzBdO1xuLy8gICAgICAgICAvLyAgICAgLy8gbGV0IHkgPSBuZWlnaGJvclsxXTtcblxuLy8gICAgICAgICAvLyAgICAgaWYobmVpZ2hib3Iucm93IDwgMjAgfHwgbmVpZ2hib3Iucm93ID49MCl7XG4vLyAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIGZhbHNlO1xuLy8gICAgICAgICAvLyAgICAgfSBlbHNlIGlmKG5laWdoYm9yLmNvbCA8IDIwIHx8IG5laWdoYm9yLmNvbCA+PSAwKXtcbi8vICAgICAgICAgLy8gICAgICAgICByZXR1cm4gZmFsc2U7XG4vLyAgICAgICAgIC8vICAgICB9IGVsc2V7XG4vLyAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIHRydWVcbi8vICAgICAgICAgLy8gICAgIH1cblxuLy8gICAgICAgICAvLyB9XG5cbi8vICAgICAgICAgLy8gY29uc3QgdmFsaWRhdGVOZWlnaGJvcnMgPSBmdW5jdGlvbihuZWlnaGJvcil7XG4vLyAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhuZWlnaGJvcilcbi8vICAgICAgICAgLy8gICAgIG5laWdoYm9yXG4vLyAgICAgICAgIC8vIH1cblxuLy8gICAgICAgICAvLyBjb25zdCB2YWxpZE5laWdoYm9ycyA9IG5laWdoYm9ycy5maWx0ZXIodmFsaWRhdGVOZWlnaGJvcnMpO1xuXG4vLyAgICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSsrKSB7XG4vLyAgICAgICAgIC8vICAgICBpZiAobmVpZ2hib3JzW2ldICYmICEobmVpZ2hib3JzW2ldLnZpc2l0ZWQpKSB7XG4vLyAgICAgICAgIC8vICAgICAgICAgaWYobmVpZ2hib3JzW2ldLnJvdyA8IDIwICYmIG5laWdoYm9yc1tpXS5yb3cgPj0wKXtcbi8vICAgICAgICAgLy8gICAgICAgICAgICAgaWYobmVpZ2hib3JzW2ldLmNvbCA8IDIwICYmIG5laWdoYm9yc1tpXS5jb2wgPj0gMCl7XG5cbi8vICAgICAgICAgLy8gICAgICAgICAgICAgICAgIHZhbGlkTmVpZ2hib3JzLnB1c2gobmVpZ2hib3JzW2ldKVxuLy8gICAgICAgICAvLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIC8vICAgICAgICAgfVxuLy8gICAgICAgICAvLyAgICAgfVxuLy8gICAgICAgICAvLyB9XG5cbi8vICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7IGkrKykge1xuLy8gICAgICAgICAgICAgaWYgKG5laWdoYm9yc1tpXSAmJiAhKG5laWdoYm9yc1tpXS52aXNpdGVkKSkge1xuLy8gICAgICAgICAgICAgICAgIC8vIGlmKG5laWdoYm9yc1tpXS5yb3cgPCAyMCAmJiBuZWlnaGJvcnNbaV0ucm93ID49MCl7XG4vLyAgICAgICAgICAgICAgICAgLy8gICAgIGlmKG5laWdoYm9yc1tpXS5jb2wgPCAyMCAmJiBuZWlnaGJvcnNbaV0uY29sID49IDApe1xuXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZE5laWdoYm9ycy5wdXNoKG5laWdoYm9yc1tpXSlcbi8vICAgICAgICAgICAgICAgICAgICAgLy8gfVxuLy8gICAgICAgICAgICAgICAgIC8vIH1cbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgfVxuXG5cbi8vICAgICAgICAgLy8gY29uc29sZS5sb2coXCJ2YWxpZFwiKVxuLy8gICAgICAgICAvLyBjb25zb2xlLmxvZyh2YWxpZE5laWdoYm9ycylcblxuLy8gICAgICAgICBsZXQgbmV4dENlbGw7XG5cbi8vICAgICAgICAgaWYgKHZhbGlkTmVpZ2hib3JzLmxlbmd0aCA+IDApIHtcbi8vICAgICAgICAgICAgIG5leHRDZWxsID0gdGhpcy5jaG9vc2VSYW5kb21OZWlnaGJvcih2YWxpZE5laWdoYm9ycyk7XG4vLyAgICAgICAgICAgICByZXR1cm4gbmV4dENlbGw7XG4vLyAgICAgICAgIH0gZWxzZXtcbi8vICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4vLyAgICAgICAgIH1cbi8vICAgICAgICAgLy8gbGV0IG5leHRDZWxsID0gXG5cbi8vICAgICAgICAgLy8gLy9uZWVkIHRvIGNoZWNrIGlmIG5leHRDZWxsIGlzIHRydWUgYmMgaXQgY291bGQgYmUgdW5kZWZpbmVkIGF0IHRoZSBlZGdlc1xuLy8gICAgICAgICAvLyB3aGlsZShuZXh0Q2VsbCAmJiBuZXh0Q2VsbC52aXNpdGVkKXtcbi8vICAgICAgICAgLy8gICAgIG5leHRDZWxsID0gdGhpcy5jaG9vc2VSYW5kb21OZWlnaGJvcihuZWlnaGJvcnMpXG5cbi8vICAgICAgICAgLy8gICAgIGlmKG5leHRDZWxsICYmICFuZXh0Q2VsbC52aXNpdGVkKXtcbi8vICAgICAgICAgLy8gICAgICAgICByZXR1cm4gbmV4dENlbGxcbi8vICAgICAgICAgLy8gICAgIH1cbi8vICAgICAgICAgLy8gfVxuXG4vLyAgICAgICAgIC8vIGlmIChuZXh0Q2VsbCkge1xuLy8gICAgICAgICAvLyAgICAgcmVjdChzdGFydFJvdywgc3RhcnRDb2wsIDQwLCA0MClcbi8vICAgICAgICAgLy8gICAgIGZpbGwoXCJwdXJwbGVcIik7XG4vLyAgICAgICAgIC8vIH1cbi8vICAgICAgICAgLy8gY29uc29sZS5sb2cobmV4dENlbGwpXG4vLyAgICAgICAgIC8vIHJldHVybiBuZXh0Q2VsbDtcblxuLy8gICAgIH1cblxuLy8gICAgIHRoaXMuY2hvb3NlUmFuZG9tTmVpZ2hib3IgPSBmdW5jdGlvbiAodmFsaWROZWlnaGJvcnMpIHtcbi8vICAgICAgICAgcmV0dXJuIHZhbGlkTmVpZ2hib3JzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHZhbGlkTmVpZ2hib3JzLmxlbmd0aCldXG4vLyAgICAgfVxuXG4vLyB9XG5cbi8vIG1vZHVsZS5leHBvcnRzID0gQ2VsbDtcblxuXG4vLyBjb25zdCBXYWxsID0gcmVxdWlyZSgnLi93YWxsJyk7XG5cbi8vIGZ1bmN0aW9uIENlbGwocm93LCBjb2wsIGdyaWQpIHtcbi8vICAgICBncmlkID0gZ3JpZCB8fCAwXG4vLyAgICAgLy8gdXNlckNvbG9yID0gdXNlckNvbG9yIHx8IDBcblxuLy8gICAgIHRoaXMucm93ID0gcm93O1xuLy8gICAgIHRoaXMuY29sID0gY29sO1xuLy8gICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG4vLyAgICAgLy8gdGhpcy51c2VyQ29sb3IgPSB1c2VyQ29sb3I7XG4vLyAgICAgdGhpcy53YWxscyA9IFtuZXcgV2FsbCgpLCBuZXcgV2FsbCgpLCBuZXcgV2FsbCgpLCBuZXcgV2FsbCgpXTtcbi8vICAgICAvLyB0aGlzLndhbGxzID0gW11cbi8vICAgICB0aGlzLnZpc2l0ZWQgPSBmYWxzZTtcbi8vICAgICB0aGlzLmhhc1VzZXIgPSBmYWxzZTtcblxuLy8gICAgIC8vIFsxLCAyLCAzLCA0XS5mb3JFYWNoKCgpID0+IHRoaXMud2FsbHMucHVzaChuZXcgV2FsbCgpKSk7XG5cbi8vICAgICB0aGlzLmhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5yb3csIHRoaXMuY29sKTtcbi8vICAgICAgICAgY29uc3Qgc3RhcnRSb3cgPSB0aGlzLnJvdyAqIDQwO1xuLy8gICAgICAgICBjb25zdCBzdGFydENvbCA9IHRoaXMuY29sICogNDA7XG4vLyAgICAgICAgIG5vU3Ryb2tlKCk7XG4vLyAgICAgICAgIGZpbGwoXCJwdXJwbGVcIik7XG4vLyAgICAgICAgIHJlY3Qoc3RhcnRSb3csIHN0YXJ0Q29sLCA0MCwgNDApXG4vLyAgICAgfVxuXG4vLyAgICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cbi8vICAgICAgICAgY29uc3Qgc3RhcnRSb3cgPSB0aGlzLnJvdyAqIDQwO1xuLy8gICAgICAgICBjb25zdCBzdGFydENvbCA9IHRoaXMuY29sICogNDA7XG5cbi8vICAgICAgICAgLy8geCwgeSwgd2lkdGgsIGhlaWdodFxuLy8gICAgICAgICAvLyByZWN0KHN0YXJ0WCwgc3RhcnRZLCA0MCwgNDApXG4vLyAgICAgICAgIC8vIG5vRmlsbCgpO1xuXG4vLyAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy53YWxscy5sZW5ndGg7IGkrKykge1xuLy8gICAgICAgICAgICAgaWYgKHRoaXMud2FsbHNbaV0ucHJlc2VudCkge1xuLy8gICAgICAgICAgICAgICAgIHRoaXMud2FsbHNbaV0ucmVuZGVyKGksIHN0YXJ0Um93LCBzdGFydENvbCk7XG4vLyAgICAgICAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAgICAgICAgIHRoaXMud2FsbHNbaV0uZGVyZW5kZXIoaSwgc3RhcnRSb3csIHN0YXJ0Q29sKTtcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgfVxuXG5cbi8vICAgICAgICAgaWYgKHRoaXMudmlzaXRlZCkge1xuLy8gICAgICAgICAgICAgbm9TdHJva2UoKTtcbi8vICAgICAgICAgICAgIGZpbGwoXCJ3aGl0ZVwiKTtcbi8vICAgICAgICAgICAgIHJlY3Qoc3RhcnRSb3cgKyAxLCBzdGFydENvbCArIDEsIDM4LCAzOClcbi8vICAgICAgICAgfVxuXG4vLyAgICAgfVxuXG4vLyAgICAgdGhpcy5yZXJlbmRlciA9IGZ1bmN0aW9uIChjb2xvcikge1xuXG4vLyAgICAgICAgIGNvbnN0IHN0YXJ0Um93ID0gdGhpcy5yb3cgKiA0MDtcbi8vICAgICAgICAgY29uc3Qgc3RhcnRDb2wgPSB0aGlzLmNvbCAqIDQwO1xuXG4vLyAgICAgICAgIC8vIHgsIHksIHdpZHRoLCBoZWlnaHRcbi8vICAgICAgICAgLy8gcmVjdChzdGFydFgsIHN0YXJ0WSwgNDAsIDQwKVxuLy8gICAgICAgICAvLyBub0ZpbGwoKTtcblxuLy8gICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMud2FsbHMubGVuZ3RoOyBpKyspIHtcbi8vICAgICAgICAgICAgIGlmICh0aGlzLndhbGxzW2ldLnByZXNlbnQpIHtcbi8vICAgICAgICAgICAgICAgICB0aGlzLndhbGxzW2ldLnJlbmRlcihpLCBzdGFydFJvdywgc3RhcnRDb2wpO1xuLy8gICAgICAgICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgICAgICAgICB0aGlzLndhbGxzW2ldLmRlcmVuZGVyKGksIHN0YXJ0Um93LCBzdGFydENvbCk7XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH1cblxuXG4vLyAgICAgICAgIC8vIGlmICh0aGlzLnZpc2l0ZWQpIHtcbi8vICAgICAgICAgLy8gICAgIG5vU3Ryb2tlKCk7XG4vLyAgICAgICAgIC8vICAgICBmaWxsKFwid2hpdGVcIik7XG4vLyAgICAgICAgIC8vICAgICByZWN0KHN0YXJ0Um93ICsgMSwgc3RhcnRDb2wgKyAxLCAzOCwgMzgpXG4vLyAgICAgICAgIC8vIH1cblxuLy8gICAgICAgICBpZiAodGhpcy5oYXNVc2VyKSB7XG4vLyAgICAgICAgICAgICBub1N0cm9rZSgpO1xuLy8gICAgICAgICAgICAgZmlsbChcIndoaXRlXCIpO1xuLy8gICAgICAgICAgICAgcmVjdChzdGFydFJvdyArIDEsIHN0YXJ0Q29sICsgMSwgMzgsIDM4KTtcbi8vICAgICAgICAgICAgIGVsbGlwc2VNb2RlKENFTlRFUik7XG4vLyAgICAgICAgICAgICBmaWxsKGNvbG9yKTtcbi8vICAgICAgICAgICAgIGVsbGlwc2Uoc3RhcnRSb3cgKyAyMCwgc3RhcnRDb2wgKyAyMCwgMTUsIDE1KTtcbi8vICAgICAgICAgfVxuXG4vLyAgICAgfVxuXG4vLyAgICAgLy8gdGhpcy5yZXNldFJlbmRlciA9IGZ1bmN0aW9uKCl7XG4vLyAgICAgLy8gICAgIHRoaXMucmVuZGVyKClcbi8vICAgICAvLyB9XG5cblxuLy8gICAgIHRoaXMuZ2V0TmVpZ2hib3IgPSBmdW5jdGlvbiAoKSB7XG5cbi8vICAgICAgICAgLy8gY29uc3QgbmVpZ2hib3JzSW5kaWNlcyA9IFtcbi8vICAgICAgICAgLy8gICAgIFtyb3cgLSAxLCBjb2xdLFxuLy8gICAgICAgICAvLyAgICAgW3JvdyArIDEsIGNvbF0sXG4vLyAgICAgICAgIC8vICAgICBbcm93LCBjb2wgLSAxXSxcbi8vICAgICAgICAgLy8gICAgIFtyb3csIGNvbCArIDFdICAgICAgICAgICAgXG4vLyAgICAgICAgIC8vIF1cbi8vICAgICAgICAgLy8gY29uc29sZS5sb2cocm93KVxuLy8gICAgICAgICAvLyBjb25zb2xlLmxvZyhjb2wpXG4vLyAgICAgICAgIC8vIGNvbnNvbGUubG9nKGdyaWQpXG5cbi8vICAgICAgICAgY29uc3QgdG9wID0gZ3JpZFtyb3cgLSAxXTtcbi8vICAgICAgICAgY29uc3QgcmlnaHQgPSBncmlkW3JvdyArIDFdO1xuLy8gICAgICAgICBjb25zdCBib3R0b20gPSBncmlkW3Jvd107XG4vLyAgICAgICAgIGNvbnN0IGxlZnQgPSBncmlkW3Jvd107XG5cbi8vICAgICAgICAgY29uc3QgbmVpZ2hib3JzID0gW11cblxuLy8gICAgICAgICBpZiAodG9wKSB7XG4vLyAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChncmlkW3JvdyAtIDFdW2NvbF0pO1xuLy8gICAgICAgICB9XG5cbi8vICAgICAgICAgaWYgKHJpZ2h0KSB7XG4vLyAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChncmlkW3JvdyArIDFdW2NvbF0pO1xuLy8gICAgICAgICB9XG5cbi8vICAgICAgICAgaWYgKGJvdHRvbSkge1xuLy8gICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goZ3JpZFtyb3ddW2NvbCAtIDFdKTtcbi8vICAgICAgICAgfVxuXG4vLyAgICAgICAgIGlmIChsZWZ0KSB7XG4vLyAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChncmlkW3Jvd11bY29sICsgMV0pO1xuLy8gICAgICAgICB9XG5cblxuLy8gICAgICAgICAvLyBjb25zdCBuZWlnaGJvcnMgPSBbXG4vLyAgICAgICAgIC8vICAgICBncmlkW3JvdyAtIDFdW2NvbF0sXG4vLyAgICAgICAgIC8vICAgICBncmlkW3JvdyArIDFdW2NvbF0sXG4vLyAgICAgICAgIC8vICAgICBncmlkW3Jvd11bY29sIC0gMV0sXG4vLyAgICAgICAgIC8vICAgICBncmlkW3Jvd11bY29sICsgMV1cbi8vICAgICAgICAgLy8gXVxuLy8gICAgICAgICAvLyAgY29uc3QgbmVpZ2hib3JzSW5kaWNlcyA9IFtcbi8vICAgICAgICAgLy8gICAgIFtyb3cgLSAxLCBjb2xdLFxuLy8gICAgICAgICAvLyAgICAgW3JvdyArIDEsIGNvbF0sXG4vLyAgICAgICAgIC8vICAgICBbcm93LCBjb2wgLSAxXSxcbi8vICAgICAgICAgLy8gICAgIFtyb3csIGNvbCArIDFdICAgICAgICAgICAgXG4vLyAgICAgICAgIC8vIF1cblxuLy8gICAgICAgICAvLyBjb25zdCBuZWlnaGJvcnMgPSBbXTtcblxuLy8gICAgICAgICAvLyBjb25zdCB2YWxpZGF0ZUlkeCA9IGZ1bmN0aW9uIChpZHgpIHtcbi8vICAgICAgICAgLy8gICAgIGlkeCA+PSAwICYmIGlkeCA8IDIwXG4vLyAgICAgICAgIC8vIH1cbi8vICAgICAgICAgLy8gZm9yKGxldCBpID0gMDsgaSA8IG5laWdoYm9yc0luZGljZXMubGVuZ3RoOyBpKyspe1xuLy8gICAgICAgICAvLyAgICAgaWYodmFsaWRhdGVJZHgobmVpZ2hib3JzSW5kaWNlc1tpXVswXSkgJiYgdmFsaWRhdGVJZHgobmVpZ2hib3JzSW5kaWNlc1tpXVsxXSkpe1xuLy8gICAgICAgICAvLyAgICAgICAgIG5laWdoYm9ycy5wdXNoKGdyaWRbbmVpZ2hib3JzSW5kaWNlc1tpXVswXV1bbmVpZ2hib3JzSW5kaWNlc1tpXVsxXV0pXG4vLyAgICAgICAgIC8vICAgICB9XG4vLyAgICAgICAgIC8vIH1cblxuXG4vLyAgICAgICAgIC8vIGxldCB0b3AgPSBbKHJvdyAtIDEpLCBjb2xdO1xuLy8gICAgICAgICAvLyB2YWxpZGF0ZUlkeCh0b3ApO1xuLy8gICAgICAgICAvLyBsZXQgcmlnaHQgPSBbcm93LCAoY29sKzEpXTtcbi8vICAgICAgICAgLy8gdmFsaWRhdGVJZHgocmlnaHQpO1xuLy8gICAgICAgICAvLyBsZXQgYm90dG9tID0gWyhyb3cgKyAxKSwgY29sXTtcbi8vICAgICAgICAgLy8gdmFsaWRhdGVJZHgoYm90dG9tKTtcbi8vICAgICAgICAgLy8gbGV0IGxlZnQgPSBbcm93LCAoY29sIC0gMSldO1xuLy8gICAgICAgICAvLyB2YWxpZGF0ZUlkeChsZWZ0KTtcbi8vICAgICAgICAgLy8gY29uc29sZS5sb2coXCJuZWlnaGJvcnNcIilcbi8vICAgICAgICAgLy8gY29uc29sZS5sb2cobmVpZ2hib3JzKVxuXG4vLyAgICAgICAgIGNvbnN0IHZhbGlkTmVpZ2hib3JzID0gW107XG5cbi8vICAgICAgICAgLy8gZm9yKGxldCBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7IGkrKyl7XG4vLyAgICAgICAgIC8vICAgICBpZiAoKG5laWdoYm9yc1tpXVswXSA8IDIwICYmIG5laWdoYm9yc1tpXVswXSA+PSAwKSAmJiAobmVpZ2hib3JzW2ldWzFdIDwgMjAgJiYgbmVpZ2hib3JzW2ldWzFdID49IDApKSB7XG4vLyAgICAgICAgIC8vICAgICAgICAgdmFsaWROZWlnaGJvcnMucHVzaChuZWlnaGJvcnNbaV0pO1xuLy8gICAgICAgICAvLyAgICAgfVxuLy8gICAgICAgICAvLyB9XG5cbi8vICAgICAgICAgLy8gY29uc3QgdmFsaWROZWlnaGJvcnMgPSBuZWlnaGJvcnMuZmlsdGVyKG5laWdoYm9yID0+IHtcbi8vICAgICAgICAgLy8gICAgIC8vIGxldCB4ID0gbmVpZ2hib3JbMF07XG4vLyAgICAgICAgIC8vICAgICAvLyBsZXQgeSA9IG5laWdoYm9yWzFdO1xuXG4vLyAgICAgICAgIC8vICAgICBpZigobmVpZ2hib3JbMF0gPCAyMCAmJiBuZWlnaGJvclswXSA+PSAwKSAmJiAobmVpZ2hib3JbMV0gPCAyMCAmJiBuZWlnaGJvclsxXSA+PSAwKSl7XG4vLyAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIG5laWdoYm9yO1xuLy8gICAgICAgICAvLyAgICAgfVxuLy8gICAgICAgICAvLyB9XG5cbi8vICAgICAgICAgLy8gY29uc3QgdmFsaWRhdGVOZWlnaGJvcnMgPSBmdW5jdGlvbihuZWlnaGJvcikge1xuLy8gICAgICAgICAvLyAgICAgaWYoIW5laWdoYm9yKXtcbi8vICAgICAgICAgLy8gICAgICAgICByZXR1cm4gZmFsc2U7XG4vLyAgICAgICAgIC8vICAgICB9XG4vLyAgICAgICAgIC8vICAgICAvLyBsZXQgeCA9IG5laWdoYm9yWzBdO1xuLy8gICAgICAgICAvLyAgICAgLy8gbGV0IHkgPSBuZWlnaGJvclsxXTtcblxuLy8gICAgICAgICAvLyAgICAgaWYobmVpZ2hib3Iucm93IDwgMjAgfHwgbmVpZ2hib3Iucm93ID49MCl7XG4vLyAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIGZhbHNlO1xuLy8gICAgICAgICAvLyAgICAgfSBlbHNlIGlmKG5laWdoYm9yLmNvbCA8IDIwIHx8IG5laWdoYm9yLmNvbCA+PSAwKXtcbi8vICAgICAgICAgLy8gICAgICAgICByZXR1cm4gZmFsc2U7XG4vLyAgICAgICAgIC8vICAgICB9IGVsc2V7XG4vLyAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIHRydWVcbi8vICAgICAgICAgLy8gICAgIH1cblxuLy8gICAgICAgICAvLyB9XG5cbi8vICAgICAgICAgLy8gY29uc3QgdmFsaWRhdGVOZWlnaGJvcnMgPSBmdW5jdGlvbihuZWlnaGJvcil7XG4vLyAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhuZWlnaGJvcilcbi8vICAgICAgICAgLy8gICAgIG5laWdoYm9yXG4vLyAgICAgICAgIC8vIH1cblxuLy8gICAgICAgICAvLyBjb25zdCB2YWxpZE5laWdoYm9ycyA9IG5laWdoYm9ycy5maWx0ZXIodmFsaWRhdGVOZWlnaGJvcnMpO1xuXG4vLyAgICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSsrKSB7XG4vLyAgICAgICAgIC8vICAgICBpZiAobmVpZ2hib3JzW2ldICYmICEobmVpZ2hib3JzW2ldLnZpc2l0ZWQpKSB7XG4vLyAgICAgICAgIC8vICAgICAgICAgaWYobmVpZ2hib3JzW2ldLnJvdyA8IDIwICYmIG5laWdoYm9yc1tpXS5yb3cgPj0wKXtcbi8vICAgICAgICAgLy8gICAgICAgICAgICAgaWYobmVpZ2hib3JzW2ldLmNvbCA8IDIwICYmIG5laWdoYm9yc1tpXS5jb2wgPj0gMCl7XG5cbi8vICAgICAgICAgLy8gICAgICAgICAgICAgICAgIHZhbGlkTmVpZ2hib3JzLnB1c2gobmVpZ2hib3JzW2ldKVxuLy8gICAgICAgICAvLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIC8vICAgICAgICAgfVxuLy8gICAgICAgICAvLyAgICAgfVxuLy8gICAgICAgICAvLyB9XG5cbi8vICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKyspIHtcbi8vICAgICAgICAgICAgIGlmIChuZWlnaGJvcnNbaV0gJiYgIShuZWlnaGJvcnNbaV0udmlzaXRlZCkpIHtcbi8vICAgICAgICAgICAgICAgICAvLyBpZihuZWlnaGJvcnNbaV0ucm93IDwgMjAgJiYgbmVpZ2hib3JzW2ldLnJvdyA+PTApe1xuLy8gICAgICAgICAgICAgICAgIC8vICAgICBpZihuZWlnaGJvcnNbaV0uY29sIDwgMjAgJiYgbmVpZ2hib3JzW2ldLmNvbCA+PSAwKXtcblxuLy8gICAgICAgICAgICAgICAgIHZhbGlkTmVpZ2hib3JzLnB1c2gobmVpZ2hib3JzW2ldKVxuLy8gICAgICAgICAgICAgICAgIC8vIH1cbi8vICAgICAgICAgICAgICAgICAvLyB9XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH1cblxuXG4vLyAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwidmFsaWRcIilcbi8vICAgICAgICAgLy8gY29uc29sZS5sb2codmFsaWROZWlnaGJvcnMpXG5cbi8vICAgICAgICAgbGV0IG5leHRDZWxsO1xuXG4vLyAgICAgICAgIGlmICh2YWxpZE5laWdoYm9ycy5sZW5ndGggPiAwKSB7XG4vLyAgICAgICAgICAgICBuZXh0Q2VsbCA9IHRoaXMuY2hvb3NlUmFuZG9tTmVpZ2hib3IodmFsaWROZWlnaGJvcnMpO1xuLy8gICAgICAgICAgICAgcmV0dXJuIG5leHRDZWxsO1xuLy8gICAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbi8vICAgICAgICAgfVxuLy8gICAgICAgICAvLyBsZXQgbmV4dENlbGwgPSBcblxuLy8gICAgICAgICAvLyAvL25lZWQgdG8gY2hlY2sgaWYgbmV4dENlbGwgaXMgdHJ1ZSBiYyBpdCBjb3VsZCBiZSB1bmRlZmluZWQgYXQgdGhlIGVkZ2VzXG4vLyAgICAgICAgIC8vIHdoaWxlKG5leHRDZWxsICYmIG5leHRDZWxsLnZpc2l0ZWQpe1xuLy8gICAgICAgICAvLyAgICAgbmV4dENlbGwgPSB0aGlzLmNob29zZVJhbmRvbU5laWdoYm9yKG5laWdoYm9ycylcblxuLy8gICAgICAgICAvLyAgICAgaWYobmV4dENlbGwgJiYgIW5leHRDZWxsLnZpc2l0ZWQpe1xuLy8gICAgICAgICAvLyAgICAgICAgIHJldHVybiBuZXh0Q2VsbFxuLy8gICAgICAgICAvLyAgICAgfVxuLy8gICAgICAgICAvLyB9XG5cbi8vICAgICAgICAgLy8gaWYgKG5leHRDZWxsKSB7XG4vLyAgICAgICAgIC8vICAgICByZWN0KHN0YXJ0Um93LCBzdGFydENvbCwgNDAsIDQwKVxuLy8gICAgICAgICAvLyAgICAgZmlsbChcInB1cnBsZVwiKTtcbi8vICAgICAgICAgLy8gfVxuLy8gICAgICAgICAvLyBjb25zb2xlLmxvZyhuZXh0Q2VsbClcbi8vICAgICAgICAgLy8gcmV0dXJuIG5leHRDZWxsO1xuXG4vLyAgICAgfVxuXG4vLyAgICAgdGhpcy5jaG9vc2VSYW5kb21OZWlnaGJvciA9IGZ1bmN0aW9uICh2YWxpZE5laWdoYm9ycykge1xuLy8gICAgICAgICByZXR1cm4gdmFsaWROZWlnaGJvcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdmFsaWROZWlnaGJvcnMubGVuZ3RoKV1cbi8vICAgICB9XG5cbi8vICAgICB0aGlzLnJlbmRlclVzZXIgPSBmdW5jdGlvbihjdXJyZW50Q29sb3Ipe1xuLy8gICAgICAgICB0aGlzLmhhc1VzZXIgPSB0cnVlO1xuLy8gICAgICAgICB0aGlzLnJlcmVuZGVyKGN1cnJlbnRDb2xvcilcbi8vICAgICAgICAgLy8gZmlsbCh0aGlzLnVzZXJDb2xvcik7XG4vLyAgICAgICAgIC8vIGVsbGlwc2UoMjAsIDIwLCAxNSwgMTUpO1xuLy8gICAgIH1cblxuLy8gfVxuXG4vLyBtb2R1bGUuZXhwb3J0cyA9IENlbGw7XG5cbi8vIC8vIGNvbnN0IFdhbGwgPSByZXF1aXJlKCcuL3dhbGwnKTtcblxuLy8gLy8gZnVuY3Rpb24gQ2VsbChyb3csIGNvbCwgZ3JpZCkge1xuLy8gLy8gICAgIHRoaXMucm93ID0gcm93O1xuLy8gLy8gICAgIHRoaXMuY29sID0gY29sO1xuLy8gLy8gICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG4vLyAvLyAgICAgdGhpcy53YWxscyA9IFtuZXcgV2FsbCgpLCBuZXcgV2FsbCgpLCBuZXcgV2FsbCgpLCBuZXcgV2FsbCgpXTtcbi8vIC8vICAgICAvLyB0aGlzLndhbGxzID0gW11cbi8vIC8vICAgICB0aGlzLnZpc2l0ZWQgPSBmYWxzZTtcblxuLy8gLy8gICAgIC8vIFsxLCAyLCAzLCA0XS5mb3JFYWNoKCgpID0+IHRoaXMud2FsbHMucHVzaChuZXcgV2FsbCgpKSk7XG5cbi8vIC8vICAgICB0aGlzLmhpZ2hsaWdodCA9IGZ1bmN0aW9uKCl7XG4vLyAvLyAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMucm93LCB0aGlzLmNvbCk7XG4vLyAvLyAgICAgICAgIGNvbnN0IHN0YXJ0Um93ID0gdGhpcy5yb3cgKiA0MDtcbi8vIC8vICAgICAgICAgY29uc3Qgc3RhcnRDb2wgPSB0aGlzLmNvbCAqIDQwO1xuLy8gLy8gICAgICAgICBub1N0cm9rZSgpO1xuLy8gLy8gICAgICAgICBmaWxsKFwicHVycGxlXCIpO1xuLy8gLy8gICAgICAgICByZWN0KHN0YXJ0Um93LCBzdGFydENvbCwgNDAsIDQwKVxuLy8gLy8gICAgIH1cblxuLy8gLy8gICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuLy8gLy8gICAgICAgICBjb25zdCBzdGFydFJvdyA9IHRoaXMucm93ICogNDA7XG4vLyAvLyAgICAgICAgIGNvbnN0IHN0YXJ0Q29sID0gdGhpcy5jb2wgKiA0MDtcblxuLy8gLy8gICAgICAgICAvLyB4LCB5LCB3aWR0aCwgaGVpZ2h0XG4vLyAvLyAgICAgICAgIC8vIHJlY3Qoc3RhcnRYLCBzdGFydFksIDQwLCA0MClcbi8vIC8vICAgICAgICAgLy8gbm9GaWxsKCk7XG5cbi8vIC8vICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndhbGxzLmxlbmd0aDsgaSsrKSB7XG4vLyAvLyAgICAgICAgICAgICBpZih0aGlzLndhbGxzW2ldLnByZXNlbnQpe1xuLy8gLy8gICAgICAgICAgICAgICAgIHRoaXMud2FsbHNbaV0ucmVuZGVyKGksIHN0YXJ0Um93LCBzdGFydENvbCk7XG4vLyAvLyAgICAgICAgICAgICB9IGVsc2Uge1xuLy8gLy8gICAgICAgICAgICAgICAgIHRoaXMud2FsbHNbaV0uZGVyZW5kZXIoaSwgc3RhcnRSb3csIHN0YXJ0Q29sKTtcbi8vIC8vICAgICAgICAgICAgIH1cbi8vIC8vICAgICAgICAgfVxuXG5cbi8vIC8vICAgICAgICAgaWYgKHRoaXMudmlzaXRlZCkge1xuLy8gLy8gICAgICAgICAgICAgbm9TdHJva2UoKTtcbi8vIC8vICAgICAgICAgICAgIGZpbGwoXCJ3aGl0ZVwiKTtcbi8vIC8vICAgICAgICAgICAgIHJlY3Qoc3RhcnRSb3crMSwgc3RhcnRDb2wrMSwgMzgsIDM4KVxuLy8gLy8gICAgICAgICB9XG5cblxuLy8gLy8gICAgIH1cblxuXG4vLyAvLyAgICAgdGhpcy5nZXROZWlnaGJvciA9IGZ1bmN0aW9uICgpIHtcblxuLy8gLy8gICAgICAgICAvLyBjb25zdCBuZWlnaGJvcnNJbmRpY2VzID0gW1xuLy8gLy8gICAgICAgICAvLyAgICAgW3JvdyAtIDEsIGNvbF0sXG4vLyAvLyAgICAgICAgIC8vICAgICBbcm93ICsgMSwgY29sXSxcbi8vIC8vICAgICAgICAgLy8gICAgIFtyb3csIGNvbCAtIDFdLFxuLy8gLy8gICAgICAgICAvLyAgICAgW3JvdywgY29sICsgMV0gICAgICAgICAgICBcbi8vIC8vICAgICAgICAgLy8gXVxuLy8gLy8gICAgICAgICAvLyBjb25zb2xlLmxvZyhyb3cpXG4vLyAvLyAgICAgICAgIC8vIGNvbnNvbGUubG9nKGNvbClcbi8vIC8vICAgICAgICAgLy8gY29uc29sZS5sb2coZ3JpZClcblxuLy8gLy8gICAgICAgICBjb25zdCB0b3AgPSBncmlkW3JvdyAtIDFdO1xuLy8gLy8gICAgICAgICBjb25zdCByaWdodCA9IGdyaWRbcm93ICsgMV07XG4vLyAvLyAgICAgICAgIGNvbnN0IGJvdHRvbSA9IGdyaWRbcm93XTtcbi8vIC8vICAgICAgICAgY29uc3QgbGVmdCA9IGdyaWRbcm93XTtcblxuLy8gLy8gICAgICAgICBjb25zdCBuZWlnaGJvcnMgPSBbXVxuXG4vLyAvLyAgICAgICAgIGlmKHRvcCl7XG4vLyAvLyAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChncmlkW3JvdyAtIDFdW2NvbF0pO1xuLy8gLy8gICAgICAgICB9XG5cbi8vIC8vICAgICAgICAgaWYocmlnaHQpe1xuLy8gLy8gICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goZ3JpZFtyb3cgKyAxXVtjb2xdKTtcbi8vIC8vICAgICAgICAgfVxuXG4vLyAvLyAgICAgICAgIGlmIChib3R0b20pIHtcbi8vIC8vICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKGdyaWRbcm93XVtjb2wgLSAxXSk7XG4vLyAvLyAgICAgICAgIH1cblxuLy8gLy8gICAgICAgICBpZiAobGVmdCkge1xuLy8gLy8gICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goZ3JpZFtyb3ddW2NvbCArIDFdKTtcbi8vIC8vICAgICAgICAgfVxuXG5cbi8vIC8vICAgICAgICAgLy8gY29uc3QgbmVpZ2hib3JzID0gW1xuLy8gLy8gICAgICAgICAvLyAgICAgZ3JpZFtyb3cgLSAxXVtjb2xdLFxuLy8gLy8gICAgICAgICAvLyAgICAgZ3JpZFtyb3cgKyAxXVtjb2xdLFxuLy8gLy8gICAgICAgICAvLyAgICAgZ3JpZFtyb3ddW2NvbCAtIDFdLFxuLy8gLy8gICAgICAgICAvLyAgICAgZ3JpZFtyb3ddW2NvbCArIDFdXG4vLyAvLyAgICAgICAgIC8vIF1cbi8vIC8vICAgICAgICAgLy8gIGNvbnN0IG5laWdoYm9yc0luZGljZXMgPSBbXG4vLyAvLyAgICAgICAgIC8vICAgICBbcm93IC0gMSwgY29sXSxcbi8vIC8vICAgICAgICAgLy8gICAgIFtyb3cgKyAxLCBjb2xdLFxuLy8gLy8gICAgICAgICAvLyAgICAgW3JvdywgY29sIC0gMV0sXG4vLyAvLyAgICAgICAgIC8vICAgICBbcm93LCBjb2wgKyAxXSAgICAgICAgICAgIFxuLy8gLy8gICAgICAgICAvLyBdXG5cbi8vIC8vICAgICAgICAgLy8gY29uc3QgbmVpZ2hib3JzID0gW107XG5cbi8vIC8vICAgICAgICAgLy8gY29uc3QgdmFsaWRhdGVJZHggPSBmdW5jdGlvbiAoaWR4KSB7XG4vLyAvLyAgICAgICAgIC8vICAgICBpZHggPj0gMCAmJiBpZHggPCAyMFxuLy8gLy8gICAgICAgICAvLyB9XG4vLyAvLyAgICAgICAgIC8vIGZvcihsZXQgaSA9IDA7IGkgPCBuZWlnaGJvcnNJbmRpY2VzLmxlbmd0aDsgaSsrKXtcbi8vIC8vICAgICAgICAgLy8gICAgIGlmKHZhbGlkYXRlSWR4KG5laWdoYm9yc0luZGljZXNbaV1bMF0pICYmIHZhbGlkYXRlSWR4KG5laWdoYm9yc0luZGljZXNbaV1bMV0pKXtcbi8vIC8vICAgICAgICAgLy8gICAgICAgICBuZWlnaGJvcnMucHVzaChncmlkW25laWdoYm9yc0luZGljZXNbaV1bMF1dW25laWdoYm9yc0luZGljZXNbaV1bMV1dKVxuLy8gLy8gICAgICAgICAvLyAgICAgfVxuLy8gLy8gICAgICAgICAvLyB9XG5cblxuLy8gLy8gICAgICAgICAvLyBsZXQgdG9wID0gWyhyb3cgLSAxKSwgY29sXTtcbi8vIC8vICAgICAgICAgLy8gdmFsaWRhdGVJZHgodG9wKTtcbi8vIC8vICAgICAgICAgLy8gbGV0IHJpZ2h0ID0gW3JvdywgKGNvbCsxKV07XG4vLyAvLyAgICAgICAgIC8vIHZhbGlkYXRlSWR4KHJpZ2h0KTtcbi8vIC8vICAgICAgICAgLy8gbGV0IGJvdHRvbSA9IFsocm93ICsgMSksIGNvbF07XG4vLyAvLyAgICAgICAgIC8vIHZhbGlkYXRlSWR4KGJvdHRvbSk7XG4vLyAvLyAgICAgICAgIC8vIGxldCBsZWZ0ID0gW3JvdywgKGNvbCAtIDEpXTtcbi8vIC8vICAgICAgICAgLy8gdmFsaWRhdGVJZHgobGVmdCk7XG4vLyAvLyAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwibmVpZ2hib3JzXCIpXG4vLyAvLyAgICAgICAgIC8vIGNvbnNvbGUubG9nKG5laWdoYm9ycylcblxuLy8gLy8gICAgICAgICBjb25zdCB2YWxpZE5laWdoYm9ycyA9IFtdO1xuXG4vLyAvLyAgICAgICAgIC8vIGZvcihsZXQgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKyspe1xuLy8gLy8gICAgICAgICAvLyAgICAgaWYgKChuZWlnaGJvcnNbaV1bMF0gPCAyMCAmJiBuZWlnaGJvcnNbaV1bMF0gPj0gMCkgJiYgKG5laWdoYm9yc1tpXVsxXSA8IDIwICYmIG5laWdoYm9yc1tpXVsxXSA+PSAwKSkge1xuLy8gLy8gICAgICAgICAvLyAgICAgICAgIHZhbGlkTmVpZ2hib3JzLnB1c2gobmVpZ2hib3JzW2ldKTtcbi8vIC8vICAgICAgICAgLy8gICAgIH1cbi8vIC8vICAgICAgICAgLy8gfVxuXG4vLyAvLyAgICAgICAgIC8vIGNvbnN0IHZhbGlkTmVpZ2hib3JzID0gbmVpZ2hib3JzLmZpbHRlcihuZWlnaGJvciA9PiB7XG4vLyAvLyAgICAgICAgIC8vICAgICAvLyBsZXQgeCA9IG5laWdoYm9yWzBdO1xuLy8gLy8gICAgICAgICAvLyAgICAgLy8gbGV0IHkgPSBuZWlnaGJvclsxXTtcblxuLy8gLy8gICAgICAgICAvLyAgICAgaWYoKG5laWdoYm9yWzBdIDwgMjAgJiYgbmVpZ2hib3JbMF0gPj0gMCkgJiYgKG5laWdoYm9yWzFdIDwgMjAgJiYgbmVpZ2hib3JbMV0gPj0gMCkpe1xuLy8gLy8gICAgICAgICAvLyAgICAgICAgIHJldHVybiBuZWlnaGJvcjtcbi8vIC8vICAgICAgICAgLy8gICAgIH1cbi8vIC8vICAgICAgICAgLy8gfVxuXG4vLyAvLyAgICAgICAgIC8vIGNvbnN0IHZhbGlkYXRlTmVpZ2hib3JzID0gZnVuY3Rpb24obmVpZ2hib3IpIHtcbi8vIC8vICAgICAgICAgLy8gICAgIGlmKCFuZWlnaGJvcil7XG4vLyAvLyAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIGZhbHNlO1xuLy8gLy8gICAgICAgICAvLyAgICAgfVxuLy8gLy8gICAgICAgICAvLyAgICAgLy8gbGV0IHggPSBuZWlnaGJvclswXTtcbi8vIC8vICAgICAgICAgLy8gICAgIC8vIGxldCB5ID0gbmVpZ2hib3JbMV07XG5cbi8vIC8vICAgICAgICAgLy8gICAgIGlmKG5laWdoYm9yLnJvdyA8IDIwIHx8IG5laWdoYm9yLnJvdyA+PTApe1xuLy8gLy8gICAgICAgICAvLyAgICAgICAgIHJldHVybiBmYWxzZTtcbi8vIC8vICAgICAgICAgLy8gICAgIH0gZWxzZSBpZihuZWlnaGJvci5jb2wgPCAyMCB8fCBuZWlnaGJvci5jb2wgPj0gMCl7XG4vLyAvLyAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIGZhbHNlO1xuLy8gLy8gICAgICAgICAvLyAgICAgfSBlbHNle1xuLy8gLy8gICAgICAgICAvLyAgICAgICAgIHJldHVybiB0cnVlXG4vLyAvLyAgICAgICAgIC8vICAgICB9XG5cbi8vIC8vICAgICAgICAgLy8gfVxuXG4vLyAvLyAgICAgICAgIC8vIGNvbnN0IHZhbGlkYXRlTmVpZ2hib3JzID0gZnVuY3Rpb24obmVpZ2hib3Ipe1xuLy8gLy8gICAgICAgICAvLyAgICAgY29uc29sZS5sb2cobmVpZ2hib3IpXG4vLyAvLyAgICAgICAgIC8vICAgICBuZWlnaGJvclxuLy8gLy8gICAgICAgICAvLyB9XG5cbi8vIC8vICAgICAgICAgLy8gY29uc3QgdmFsaWROZWlnaGJvcnMgPSBuZWlnaGJvcnMuZmlsdGVyKHZhbGlkYXRlTmVpZ2hib3JzKTtcblxuLy8gLy8gICAgICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7IGkrKykge1xuLy8gLy8gICAgICAgICAvLyAgICAgaWYgKG5laWdoYm9yc1tpXSAmJiAhKG5laWdoYm9yc1tpXS52aXNpdGVkKSkge1xuLy8gLy8gICAgICAgICAvLyAgICAgICAgIGlmKG5laWdoYm9yc1tpXS5yb3cgPCAyMCAmJiBuZWlnaGJvcnNbaV0ucm93ID49MCl7XG4vLyAvLyAgICAgICAgIC8vICAgICAgICAgICAgIGlmKG5laWdoYm9yc1tpXS5jb2wgPCAyMCAmJiBuZWlnaGJvcnNbaV0uY29sID49IDApe1xuXG4vLyAvLyAgICAgICAgIC8vICAgICAgICAgICAgICAgICB2YWxpZE5laWdoYm9ycy5wdXNoKG5laWdoYm9yc1tpXSlcbi8vIC8vICAgICAgICAgLy8gICAgICAgICAgICAgfVxuLy8gLy8gICAgICAgICAvLyAgICAgICAgIH1cbi8vIC8vICAgICAgICAgLy8gICAgIH1cbi8vIC8vICAgICAgICAgLy8gfVxuXG4vLyAvLyAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKyspIHtcbi8vIC8vICAgICAgICAgICAgIGlmIChuZWlnaGJvcnNbaV0gJiYgIShuZWlnaGJvcnNbaV0udmlzaXRlZCkpIHtcbi8vIC8vICAgICAgICAgICAgICAgICAvLyBpZihuZWlnaGJvcnNbaV0ucm93IDwgMjAgJiYgbmVpZ2hib3JzW2ldLnJvdyA+PTApe1xuLy8gLy8gICAgICAgICAgICAgICAgIC8vICAgICBpZihuZWlnaGJvcnNbaV0uY29sIDwgMjAgJiYgbmVpZ2hib3JzW2ldLmNvbCA+PSAwKXtcblxuLy8gLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWROZWlnaGJvcnMucHVzaChuZWlnaGJvcnNbaV0pXG4vLyAvLyAgICAgICAgICAgICAgICAgICAgIC8vIH1cbi8vIC8vICAgICAgICAgICAgICAgICAvLyB9XG4vLyAvLyAgICAgICAgICAgICB9XG4vLyAvLyAgICAgICAgIH1cblxuXG4vLyAvLyAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwidmFsaWRcIilcbi8vIC8vICAgICAgICAgLy8gY29uc29sZS5sb2codmFsaWROZWlnaGJvcnMpXG5cbi8vIC8vICAgICAgICAgbGV0IG5leHRDZWxsO1xuXG4vLyAvLyAgICAgICAgIGlmICh2YWxpZE5laWdoYm9ycy5sZW5ndGggPiAwKSB7XG4vLyAvLyAgICAgICAgICAgICBuZXh0Q2VsbCA9IHRoaXMuY2hvb3NlUmFuZG9tTmVpZ2hib3IodmFsaWROZWlnaGJvcnMpO1xuLy8gLy8gICAgICAgICAgICAgcmV0dXJuIG5leHRDZWxsO1xuLy8gLy8gICAgICAgICB9IGVsc2V7XG4vLyAvLyAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuLy8gLy8gICAgICAgICB9XG4vLyAvLyAgICAgICAgIC8vIGxldCBuZXh0Q2VsbCA9IFxuXG4vLyAvLyAgICAgICAgIC8vIC8vbmVlZCB0byBjaGVjayBpZiBuZXh0Q2VsbCBpcyB0cnVlIGJjIGl0IGNvdWxkIGJlIHVuZGVmaW5lZCBhdCB0aGUgZWRnZXNcbi8vIC8vICAgICAgICAgLy8gd2hpbGUobmV4dENlbGwgJiYgbmV4dENlbGwudmlzaXRlZCl7XG4vLyAvLyAgICAgICAgIC8vICAgICBuZXh0Q2VsbCA9IHRoaXMuY2hvb3NlUmFuZG9tTmVpZ2hib3IobmVpZ2hib3JzKVxuXG4vLyAvLyAgICAgICAgIC8vICAgICBpZihuZXh0Q2VsbCAmJiAhbmV4dENlbGwudmlzaXRlZCl7XG4vLyAvLyAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIG5leHRDZWxsXG4vLyAvLyAgICAgICAgIC8vICAgICB9XG4vLyAvLyAgICAgICAgIC8vIH1cblxuLy8gLy8gICAgICAgICAvLyBpZiAobmV4dENlbGwpIHtcbi8vIC8vICAgICAgICAgLy8gICAgIHJlY3Qoc3RhcnRSb3csIHN0YXJ0Q29sLCA0MCwgNDApXG4vLyAvLyAgICAgICAgIC8vICAgICBmaWxsKFwicHVycGxlXCIpO1xuLy8gLy8gICAgICAgICAvLyB9XG4vLyAvLyAgICAgICAgIC8vIGNvbnNvbGUubG9nKG5leHRDZWxsKVxuLy8gLy8gICAgICAgICAvLyByZXR1cm4gbmV4dENlbGw7XG5cbi8vIC8vICAgICB9XG5cbi8vIC8vICAgICB0aGlzLmNob29zZVJhbmRvbU5laWdoYm9yID0gZnVuY3Rpb24gKHZhbGlkTmVpZ2hib3JzKSB7XG4vLyAvLyAgICAgICAgIHJldHVybiB2YWxpZE5laWdoYm9yc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB2YWxpZE5laWdoYm9ycy5sZW5ndGgpXVxuLy8gLy8gICAgIH1cblxuLy8gLy8gfVxuXG4vLyAvLyBtb2R1bGUuZXhwb3J0cyA9IENlbGw7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./cell.js\n");

/***/ }),

/***/ "./game.js":
/*!*****************!*\
  !*** ./game.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const User = __webpack_require__(/*! ./user */ \"./user.js\");\n\nfunction Game(grid) {\n    this.end = [19, 19];\n    this.grid = grid;\n    this.user = new User(this.grid);\n    this.renderCell = [0, 0];\n    // this.lastInput = new Date();\n    // this.userPos = [0, 0];\n    this.startTime = new Date();\n\n\n    this.userRender = function () {\n        this.user.render(this.user.pos[0], this.user.pos[1]);\n    }\n\n    // this.play = function () {\n    //     this.userMove();\n    // }\n\n    this.end = function () {\n        this.renderCell === [19, 19]\n    }\n    \n    this.userMove = function () {\n        \n        this.user.render(0,0);\n\n        // console.log(this.renderCell)\n        \n        let userPos = this.user.pos;\n        let x = userPos[0];\n        let y = userPos[1];\n        let gridPos = this.user.gridPos;\n        let prevGridPosCell = this.grid[gridPos[0]][gridPos[1]];\n        let renderCellBox = this.grid[this.renderCell[0]][this.renderCell[1]];\n        // renderCellBox.highlight();\n        let endTime = new Date();\n        console.log(\"prevcell\")\n        console.log(prevGridPosCell)\n        console.log(key)\n\n        if (keyIsPressed && key === 'ArrowUp' && endTime - this.startTime > 100) {\n            this.startTime = endTime;\n            if (prevGridPosCell.walls[0].color === \"white\") {\n              // if (renderCellBox.walls[2].color === \"white\") {\n              this.user.updateGridPos([\"y\", -1], userPos);\n              this.renderCell = this.user.gridPos;\n              // let renderCellBox = this.grid[this.renderCell[0]][this.renderCell[1]];\n\n              // if(renderCellBox.walls[0] === false){\n              // console.log(\"rendercell\");\n              // console.log(this.renderCell);\n              // debugger\n              this.user.render(this.renderCell[0], this.renderCell[1]);\n            }\n        }\n\n        if (keyIsPressed && key === \"ArrowDown\" && endTime - this.startTime > 100) {\n            this.startTime = endTime;\n          if (prevGridPosCell.walls[1].color === \"white\") {\n            this.user.updateGridPos([\"y\", 1], userPos);\n            this.renderCell = this.user.gridPos;\n            // console.log(\"rendercell\");\n            // console.log(this.renderCell);\n            // debugger;\n            this.user.render(this.renderCell[0], this.renderCell[1]);\n          }\n        }\n\n        if (keyIsPressed && key === \"ArrowLeft\" && endTime - this.startTime > 100) {\n            this.startTime = endTime;\n          if (prevGridPosCell.walls[0].color === \"white\") {\n            this.user.updateGridPos([\"x\", -1], userPos);\n            this.renderCell = this.user.gridPos;\n            // console.log(\"rendercell\");\n            // console.log(this.renderCell);\n            // debugger;\n            this.user.render(this.renderCell[0], this.renderCell[1]);\n          }\n        }\n\n        if (keyIsPressed && key === \"ArrowRight\" && endTime - this.startTime > 100) {\n            this.startTime = endTime;\n          if (prevGridPosCell.walls[2].color === \"white\") {\n            this.user.updateGridPos([\"x\", 1], userPos);\n            this.renderCell = this.user.gridPos;\n            // console.log(\"rendercell\");\n            // console.log(this.renderCell);\n            // debugger;\n            this.user.render(this.renderCell[0], this.renderCell[1]);\n          }\n        }\n\n        \n        // this.user.update();\n        // this.user.display();\n        // const colors = [\"lightcoral\", \"orange\", \"Chartreuse\", \"darkcyan\", \"darkorchid\"];\n        // let currentColor = colors[Math.floor(Math.random() * colors.length)];\n\n        // fill(currentColor);\n        // ellipse(19, 19, 15, 15);\n    }\n\n}\n\nmodule.exports = Game;\n//     this.xDimen = 900;\n//     this.yDimen = 900;\n//     this.cells = [];\n// }\n\n// Game.prototype.render = function(canvas){\n//     Game.setUp()\n// })\n\n// Game.prototype.setUp = function(mazeCanvas){\n//     const canvas = mazeCanvas.getContext(\"2d\");\n\n//     canvas.fillStyle = \"purple\";\n//     //x, y, width, height\n//     canvas.fillRect(0, 0, 800, 800);\n\n//     cols = 10; //each will be 8 x 8\n//     rows = 10;\n\n//     for(let rowNum = 0; rowNum < rows; rowNum++){\n//         for (let colNum = 0; colNum < cols, colNum++){\n//             cells.push(new Cell(rowNum, colNum))\n//         }\n//     }\n\n//     for(let i = 0; i < this.cells.length; i++){\n\n//     }\n\n\n// const User = require('./user');\n\n// function Game(){\n//     this.user = new User();\n//     this.end = [19, 19];\n//     // this.userPos = [0, 0];\n\n//     this.userRender = function(){\n//         this.user.render(this.user.pos[0], this.user.pos[1]);\n//     }\n\n//     // this.play = function(){\n//     //     this.userMove();\n//     // }\n\n//     this.end = function(userPos){\n//         this.user.pos === this.end\n//     }\n\n//     this.userMove = function(){\n//         if (keyIsDown(LEFT_ARROW)) {\n//             this.user.updatePos([\"y\", -40]);\n//             this.user.render();\n//         }\n\n//         if (keyIsDown(RIGHT_ARROW)) {\n//             this.user.updatePos([\"y\", 40]);\n//             this.user.render();\n//         }\n\n//         if (keyIsDown(UP_ARROW)) {\n//             this.user.updatePos([\"x\", -40]);\n//             this.user.render();\n//         }\n\n//         if (keyIsDown(DOWN_ARROW)) {\n//             this.user.updatePos([\"x\", 40]);\n//             this.user.render();\n//         }\n\n//         const colors = [\"lightcoral\", \"orange\", \"Chartreuse\", \"darkcyan\", \"darkorchid\"];\n//         let currentColor = colors[Math.floor(Math.random() * colors.length)];\n//         fill(currentColor);\n//         ellipse(19, 19, 15, 15);\n//     }\n\n// }\n\n// module.exports = Game;\n// //     this.xDimen = 900;\n// //     this.yDimen = 900;\n// //     this.cells = [];\n// // }\n\n// // Game.prototype.render = function(canvas){\n// //     Game.setUp()\n// // })\n\n// // Game.prototype.setUp = function(mazeCanvas){\n// //     const canvas = mazeCanvas.getContext(\"2d\");\n\n// //     canvas.fillStyle = \"purple\";\n// //     //x, y, width, height\n// //     canvas.fillRect(0, 0, 800, 800);\n\n// //     cols = 10; //each will be 8 x 8\n// //     rows = 10;\n\n// //     for(let rowNum = 0; rowNum < rows; rowNum++){\n// //         for (let colNum = 0; colNum < cols, colNum++){\n// //             cells.push(new Cell(rowNum, colNum))\n// //         }\n// //     }\n\n// //     for(let i = 0; i < this.cells.length; i++){\n\n// //     }\n\n\n\n// const User = require('./user');\n\n// function Game(grid) {\n//     this.user = new User(grid);\n//     this.end = [19, 19];\n//     this.grid = grid;\n//     // this.userPos = [0, 0];\n\n//     this.firstUserRender = function(){\n//         this.user.display()\n//     }\n\n//     this.userRender = function () {\n//         this.user.persistantDisplay(this.user.pos[0], this.user.pos[1]);\n//     }\n\n//     // this.play = function () {\n//     //     this.userMove();\n//     // }\n\n//     this.end = function (userPos) {\n//         this.user.pos === this.end\n//     }\n\n//     this.userMove = function () {\n\n//         let prevPos = this.user.pos;\n//         let x = prevPos[0];\n//         let y = prevPos[1];\n//         let prevCell = grid[prevPos[0]][prevPos[1]];\n//         // const keypress = event.keyCode;\n//         // console.log(event);\n//         if (keyIsDown(LEFT_ARROW)) {\n//             // console.log(this.user.pos)\n//             this.user.updatePos([\"y\", -40]);\n//             // this.user.updatePos([\"y\", -1], prevPos);\n//             this.user.render();\n//             // prevCell.resetRender();\n//             this.user.display(this.user.pos)\n//         }\n\n//         if (keyIsDown(RIGHT_ARROW)) {\n//             this.user.updatePos([\"y\", 40]);\n//             // this.user.updatePos([\"y\", 1], prevPos);\n//             this.user.render();\n//             // prevCell.resetRender();\n//         }\n\n//         if (keyIsDown(UP_ARROW)) {\n//             this.user.updatePos([\"x\", -40]);\n//             // this.user.updatePos([\"x\", -1], prevPos);\n//             this.user.render();\n//             // prevCell.resetRender();\n//         }\n\n//         if (keyIsDown(DOWN_ARROW)) {\n//             this.user.updatePos([\"x\", 40]);\n//             // this.user.updatePos([\"x\", 1], prevPos);\n//             this.user.render();\n//             // prevCell.resetRender();\n//         }\n\n//         // this.user.update();\n//         // this.user.display();\n//         // const colors = [\"lightcoral\", \"orange\", \"Chartreuse\", \"darkcyan\", \"darkorchid\"];\n//         // let currentColor = colors[Math.floor(Math.random() * colors.length)];\n\n//         // fill(currentColor);\n//         // ellipse(19, 19, 15, 15);\n//     }\n\n// }\n\n// module.exports = Game;\n// //     this.xDimen = 900;\n// //     this.yDimen = 900;\n// //     this.cells = [];\n// // }\n\n// // Game.prototype.render = function(canvas){\n// //     Game.setUp()\n// // })\n\n// // Game.prototype.setUp = function(mazeCanvas){\n// //     const canvas = mazeCanvas.getContext(\"2d\");\n\n// //     canvas.fillStyle = \"purple\";\n// //     //x, y, width, height\n// //     canvas.fillRect(0, 0, 800, 800);\n\n// //     cols = 10; //each will be 8 x 8\n// //     rows = 10;\n\n// //     for(let rowNum = 0; rowNum < rows; rowNum++){\n// //         for (let colNum = 0; colNum < cols, colNum++){\n// //             cells.push(new Cell(rowNum, colNum))\n// //         }\n// //     }\n\n// //     for(let i = 0; i < this.cells.length; i++){\n\n// //     }\n\n\n// // const User = require('./user');\n\n// // function Game(){\n// //     this.user = new User();\n// //     this.end = [19, 19];\n// //     // this.userPos = [0, 0];\n\n// //     this.userRender = function(){\n// //         this.user.render(this.user.pos[0], this.user.pos[1]);\n// //     }\n\n// //     // this.play = function(){\n// //     //     this.userMove();\n// //     // }\n\n// //     this.end = function(userPos){\n// //         this.user.pos === this.end\n// //     }\n\n// //     this.userMove = function(){\n// //         if (keyIsDown(LEFT_ARROW)) {\n// //             this.user.updatePos([\"y\", -40]);\n// //             this.user.render();\n// //         }\n\n// //         if (keyIsDown(RIGHT_ARROW)) {\n// //             this.user.updatePos([\"y\", 40]);\n// //             this.user.render();\n// //         }\n\n// //         if (keyIsDown(UP_ARROW)) {\n// //             this.user.updatePos([\"x\", -40]);\n// //             this.user.render();\n// //         }\n\n// //         if (keyIsDown(DOWN_ARROW)) {\n// //             this.user.updatePos([\"x\", 40]);\n// //             this.user.render();\n// //         }\n\n// //         const colors = [\"lightcoral\", \"orange\", \"Chartreuse\", \"darkcyan\", \"darkorchid\"];\n// //         let currentColor = colors[Math.floor(Math.random() * colors.length)];\n// //         fill(currentColor);\n// //         ellipse(19, 19, 15, 15);\n// //     }\n\n// // }\n\n// // module.exports = Game;\n// // //     this.xDimen = 900;\n// // //     this.yDimen = 900;\n// // //     this.cells = [];\n// // // }\n\n// // // Game.prototype.render = function(canvas){\n// // //     Game.setUp()\n// // // })\n\n// // // Game.prototype.setUp = function(mazeCanvas){\n// // //     const canvas = mazeCanvas.getContext(\"2d\");\n\n// // //     canvas.fillStyle = \"purple\";\n// // //     //x, y, width, height\n// // //     canvas.fillRect(0, 0, 800, 800);\n\n// // //     cols = 10; //each will be 8 x 8\n// // //     rows = 10;\n\n// // //     for(let rowNum = 0; rowNum < rows; rowNum++){\n// // //         for (let colNum = 0; colNum < cols, colNum++){\n// // //             cells.push(new Cell(rowNum, colNum))\n// // //         }\n// // //     }\n\n// // //     for(let i = 0; i < this.cells.length; i++){\n\n// // //     }\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9nYW1lLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZ2FtZS5qcz8zNjU3Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFVzZXIgPSByZXF1aXJlKCcuL3VzZXInKTtcblxuZnVuY3Rpb24gR2FtZShncmlkKSB7XG4gICAgdGhpcy5lbmQgPSBbMTksIDE5XTtcbiAgICB0aGlzLmdyaWQgPSBncmlkO1xuICAgIHRoaXMudXNlciA9IG5ldyBVc2VyKHRoaXMuZ3JpZCk7XG4gICAgdGhpcy5yZW5kZXJDZWxsID0gWzAsIDBdO1xuICAgIC8vIHRoaXMubGFzdElucHV0ID0gbmV3IERhdGUoKTtcbiAgICAvLyB0aGlzLnVzZXJQb3MgPSBbMCwgMF07XG4gICAgdGhpcy5zdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuXG5cbiAgICB0aGlzLnVzZXJSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXNlci5yZW5kZXIodGhpcy51c2VyLnBvc1swXSwgdGhpcy51c2VyLnBvc1sxXSk7XG4gICAgfVxuXG4gICAgLy8gdGhpcy5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vICAgICB0aGlzLnVzZXJNb3ZlKCk7XG4gICAgLy8gfVxuXG4gICAgdGhpcy5lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyQ2VsbCA9PT0gWzE5LCAxOV1cbiAgICB9XG4gICAgXG4gICAgdGhpcy51c2VyTW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgXG4gICAgICAgIHRoaXMudXNlci5yZW5kZXIoMCwwKTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnJlbmRlckNlbGwpXG4gICAgICAgIFxuICAgICAgICBsZXQgdXNlclBvcyA9IHRoaXMudXNlci5wb3M7XG4gICAgICAgIGxldCB4ID0gdXNlclBvc1swXTtcbiAgICAgICAgbGV0IHkgPSB1c2VyUG9zWzFdO1xuICAgICAgICBsZXQgZ3JpZFBvcyA9IHRoaXMudXNlci5ncmlkUG9zO1xuICAgICAgICBsZXQgcHJldkdyaWRQb3NDZWxsID0gdGhpcy5ncmlkW2dyaWRQb3NbMF1dW2dyaWRQb3NbMV1dO1xuICAgICAgICBsZXQgcmVuZGVyQ2VsbEJveCA9IHRoaXMuZ3JpZFt0aGlzLnJlbmRlckNlbGxbMF1dW3RoaXMucmVuZGVyQ2VsbFsxXV07XG4gICAgICAgIC8vIHJlbmRlckNlbGxCb3guaGlnaGxpZ2h0KCk7XG4gICAgICAgIGxldCBlbmRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJwcmV2Y2VsbFwiKVxuICAgICAgICBjb25zb2xlLmxvZyhwcmV2R3JpZFBvc0NlbGwpXG4gICAgICAgIGNvbnNvbGUubG9nKGtleSlcblxuICAgICAgICBpZiAoa2V5SXNQcmVzc2VkICYmIGtleSA9PT0gJ0Fycm93VXAnICYmIGVuZFRpbWUgLSB0aGlzLnN0YXJ0VGltZSA+IDEwMCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBlbmRUaW1lO1xuICAgICAgICAgICAgaWYgKHByZXZHcmlkUG9zQ2VsbC53YWxsc1swXS5jb2xvciA9PT0gXCJ3aGl0ZVwiKSB7XG4gICAgICAgICAgICAgIC8vIGlmIChyZW5kZXJDZWxsQm94LndhbGxzWzJdLmNvbG9yID09PSBcIndoaXRlXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy51c2VyLnVwZGF0ZUdyaWRQb3MoW1wieVwiLCAtMV0sIHVzZXJQb3MpO1xuICAgICAgICAgICAgICB0aGlzLnJlbmRlckNlbGwgPSB0aGlzLnVzZXIuZ3JpZFBvcztcbiAgICAgICAgICAgICAgLy8gbGV0IHJlbmRlckNlbGxCb3ggPSB0aGlzLmdyaWRbdGhpcy5yZW5kZXJDZWxsWzBdXVt0aGlzLnJlbmRlckNlbGxbMV1dO1xuXG4gICAgICAgICAgICAgIC8vIGlmKHJlbmRlckNlbGxCb3gud2FsbHNbMF0gPT09IGZhbHNlKXtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJyZW5kZXJjZWxsXCIpO1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnJlbmRlckNlbGwpO1xuICAgICAgICAgICAgICAvLyBkZWJ1Z2dlclxuICAgICAgICAgICAgICB0aGlzLnVzZXIucmVuZGVyKHRoaXMucmVuZGVyQ2VsbFswXSwgdGhpcy5yZW5kZXJDZWxsWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXlJc1ByZXNzZWQgJiYga2V5ID09PSBcIkFycm93RG93blwiICYmIGVuZFRpbWUgLSB0aGlzLnN0YXJ0VGltZSA+IDEwMCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBlbmRUaW1lO1xuICAgICAgICAgIGlmIChwcmV2R3JpZFBvc0NlbGwud2FsbHNbMV0uY29sb3IgPT09IFwid2hpdGVcIikge1xuICAgICAgICAgICAgdGhpcy51c2VyLnVwZGF0ZUdyaWRQb3MoW1wieVwiLCAxXSwgdXNlclBvcyk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckNlbGwgPSB0aGlzLnVzZXIuZ3JpZFBvcztcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwicmVuZGVyY2VsbFwiKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMucmVuZGVyQ2VsbCk7XG4gICAgICAgICAgICAvLyBkZWJ1Z2dlcjtcbiAgICAgICAgICAgIHRoaXMudXNlci5yZW5kZXIodGhpcy5yZW5kZXJDZWxsWzBdLCB0aGlzLnJlbmRlckNlbGxbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXlJc1ByZXNzZWQgJiYga2V5ID09PSBcIkFycm93TGVmdFwiICYmIGVuZFRpbWUgLSB0aGlzLnN0YXJ0VGltZSA+IDEwMCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBlbmRUaW1lO1xuICAgICAgICAgIGlmIChwcmV2R3JpZFBvc0NlbGwud2FsbHNbMF0uY29sb3IgPT09IFwid2hpdGVcIikge1xuICAgICAgICAgICAgdGhpcy51c2VyLnVwZGF0ZUdyaWRQb3MoW1wieFwiLCAtMV0sIHVzZXJQb3MpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJDZWxsID0gdGhpcy51c2VyLmdyaWRQb3M7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInJlbmRlcmNlbGxcIik7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnJlbmRlckNlbGwpO1xuICAgICAgICAgICAgLy8gZGVidWdnZXI7XG4gICAgICAgICAgICB0aGlzLnVzZXIucmVuZGVyKHRoaXMucmVuZGVyQ2VsbFswXSwgdGhpcy5yZW5kZXJDZWxsWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5SXNQcmVzc2VkICYmIGtleSA9PT0gXCJBcnJvd1JpZ2h0XCIgJiYgZW5kVGltZSAtIHRoaXMuc3RhcnRUaW1lID4gMTAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IGVuZFRpbWU7XG4gICAgICAgICAgaWYgKHByZXZHcmlkUG9zQ2VsbC53YWxsc1syXS5jb2xvciA9PT0gXCJ3aGl0ZVwiKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXIudXBkYXRlR3JpZFBvcyhbXCJ4XCIsIDFdLCB1c2VyUG9zKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2VsbCA9IHRoaXMudXNlci5ncmlkUG9zO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJyZW5kZXJjZWxsXCIpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5yZW5kZXJDZWxsKTtcbiAgICAgICAgICAgIC8vIGRlYnVnZ2VyO1xuICAgICAgICAgICAgdGhpcy51c2VyLnJlbmRlcih0aGlzLnJlbmRlckNlbGxbMF0sIHRoaXMucmVuZGVyQ2VsbFsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgXG4gICAgICAgIC8vIHRoaXMudXNlci51cGRhdGUoKTtcbiAgICAgICAgLy8gdGhpcy51c2VyLmRpc3BsYXkoKTtcbiAgICAgICAgLy8gY29uc3QgY29sb3JzID0gW1wibGlnaHRjb3JhbFwiLCBcIm9yYW5nZVwiLCBcIkNoYXJ0cmV1c2VcIiwgXCJkYXJrY3lhblwiLCBcImRhcmtvcmNoaWRcIl07XG4gICAgICAgIC8vIGxldCBjdXJyZW50Q29sb3IgPSBjb2xvcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY29sb3JzLmxlbmd0aCldO1xuXG4gICAgICAgIC8vIGZpbGwoY3VycmVudENvbG9yKTtcbiAgICAgICAgLy8gZWxsaXBzZSgxOSwgMTksIDE1LCAxNSk7XG4gICAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gR2FtZTtcbi8vICAgICB0aGlzLnhEaW1lbiA9IDkwMDtcbi8vICAgICB0aGlzLnlEaW1lbiA9IDkwMDtcbi8vICAgICB0aGlzLmNlbGxzID0gW107XG4vLyB9XG5cbi8vIEdhbWUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKGNhbnZhcyl7XG4vLyAgICAgR2FtZS5zZXRVcCgpXG4vLyB9KVxuXG4vLyBHYW1lLnByb3RvdHlwZS5zZXRVcCA9IGZ1bmN0aW9uKG1hemVDYW52YXMpe1xuLy8gICAgIGNvbnN0IGNhbnZhcyA9IG1hemVDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4vLyAgICAgY2FudmFzLmZpbGxTdHlsZSA9IFwicHVycGxlXCI7XG4vLyAgICAgLy94LCB5LCB3aWR0aCwgaGVpZ2h0XG4vLyAgICAgY2FudmFzLmZpbGxSZWN0KDAsIDAsIDgwMCwgODAwKTtcblxuLy8gICAgIGNvbHMgPSAxMDsgLy9lYWNoIHdpbGwgYmUgOCB4IDhcbi8vICAgICByb3dzID0gMTA7XG5cbi8vICAgICBmb3IobGV0IHJvd051bSA9IDA7IHJvd051bSA8IHJvd3M7IHJvd051bSsrKXtcbi8vICAgICAgICAgZm9yIChsZXQgY29sTnVtID0gMDsgY29sTnVtIDwgY29scywgY29sTnVtKyspe1xuLy8gICAgICAgICAgICAgY2VsbHMucHVzaChuZXcgQ2VsbChyb3dOdW0sIGNvbE51bSkpXG4vLyAgICAgICAgIH1cbi8vICAgICB9XG5cbi8vICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5jZWxscy5sZW5ndGg7IGkrKyl7XG5cbi8vICAgICB9XG5cblxuLy8gY29uc3QgVXNlciA9IHJlcXVpcmUoJy4vdXNlcicpO1xuXG4vLyBmdW5jdGlvbiBHYW1lKCl7XG4vLyAgICAgdGhpcy51c2VyID0gbmV3IFVzZXIoKTtcbi8vICAgICB0aGlzLmVuZCA9IFsxOSwgMTldO1xuLy8gICAgIC8vIHRoaXMudXNlclBvcyA9IFswLCAwXTtcblxuLy8gICAgIHRoaXMudXNlclJlbmRlciA9IGZ1bmN0aW9uKCl7XG4vLyAgICAgICAgIHRoaXMudXNlci5yZW5kZXIodGhpcy51c2VyLnBvc1swXSwgdGhpcy51c2VyLnBvc1sxXSk7XG4vLyAgICAgfVxuXG4vLyAgICAgLy8gdGhpcy5wbGF5ID0gZnVuY3Rpb24oKXtcbi8vICAgICAvLyAgICAgdGhpcy51c2VyTW92ZSgpO1xuLy8gICAgIC8vIH1cblxuLy8gICAgIHRoaXMuZW5kID0gZnVuY3Rpb24odXNlclBvcyl7XG4vLyAgICAgICAgIHRoaXMudXNlci5wb3MgPT09IHRoaXMuZW5kXG4vLyAgICAgfVxuXG4vLyAgICAgdGhpcy51c2VyTW92ZSA9IGZ1bmN0aW9uKCl7XG4vLyAgICAgICAgIGlmIChrZXlJc0Rvd24oTEVGVF9BUlJPVykpIHtcbi8vICAgICAgICAgICAgIHRoaXMudXNlci51cGRhdGVQb3MoW1wieVwiLCAtNDBdKTtcbi8vICAgICAgICAgICAgIHRoaXMudXNlci5yZW5kZXIoKTtcbi8vICAgICAgICAgfVxuXG4vLyAgICAgICAgIGlmIChrZXlJc0Rvd24oUklHSFRfQVJST1cpKSB7XG4vLyAgICAgICAgICAgICB0aGlzLnVzZXIudXBkYXRlUG9zKFtcInlcIiwgNDBdKTtcbi8vICAgICAgICAgICAgIHRoaXMudXNlci5yZW5kZXIoKTtcbi8vICAgICAgICAgfVxuXG4vLyAgICAgICAgIGlmIChrZXlJc0Rvd24oVVBfQVJST1cpKSB7XG4vLyAgICAgICAgICAgICB0aGlzLnVzZXIudXBkYXRlUG9zKFtcInhcIiwgLTQwXSk7XG4vLyAgICAgICAgICAgICB0aGlzLnVzZXIucmVuZGVyKCk7XG4vLyAgICAgICAgIH1cblxuLy8gICAgICAgICBpZiAoa2V5SXNEb3duKERPV05fQVJST1cpKSB7XG4vLyAgICAgICAgICAgICB0aGlzLnVzZXIudXBkYXRlUG9zKFtcInhcIiwgNDBdKTtcbi8vICAgICAgICAgICAgIHRoaXMudXNlci5yZW5kZXIoKTtcbi8vICAgICAgICAgfVxuXG4vLyAgICAgICAgIGNvbnN0IGNvbG9ycyA9IFtcImxpZ2h0Y29yYWxcIiwgXCJvcmFuZ2VcIiwgXCJDaGFydHJldXNlXCIsIFwiZGFya2N5YW5cIiwgXCJkYXJrb3JjaGlkXCJdO1xuLy8gICAgICAgICBsZXQgY3VycmVudENvbG9yID0gY29sb3JzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNvbG9ycy5sZW5ndGgpXTtcbi8vICAgICAgICAgZmlsbChjdXJyZW50Q29sb3IpO1xuLy8gICAgICAgICBlbGxpcHNlKDE5LCAxOSwgMTUsIDE1KTtcbi8vICAgICB9XG5cbi8vIH1cblxuLy8gbW9kdWxlLmV4cG9ydHMgPSBHYW1lO1xuLy8gLy8gICAgIHRoaXMueERpbWVuID0gOTAwO1xuLy8gLy8gICAgIHRoaXMueURpbWVuID0gOTAwO1xuLy8gLy8gICAgIHRoaXMuY2VsbHMgPSBbXTtcbi8vIC8vIH1cblxuLy8gLy8gR2FtZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oY2FudmFzKXtcbi8vIC8vICAgICBHYW1lLnNldFVwKClcbi8vIC8vIH0pXG5cbi8vIC8vIEdhbWUucHJvdG90eXBlLnNldFVwID0gZnVuY3Rpb24obWF6ZUNhbnZhcyl7XG4vLyAvLyAgICAgY29uc3QgY2FudmFzID0gbWF6ZUNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbi8vIC8vICAgICBjYW52YXMuZmlsbFN0eWxlID0gXCJwdXJwbGVcIjtcbi8vIC8vICAgICAvL3gsIHksIHdpZHRoLCBoZWlnaHRcbi8vIC8vICAgICBjYW52YXMuZmlsbFJlY3QoMCwgMCwgODAwLCA4MDApO1xuXG4vLyAvLyAgICAgY29scyA9IDEwOyAvL2VhY2ggd2lsbCBiZSA4IHggOFxuLy8gLy8gICAgIHJvd3MgPSAxMDtcblxuLy8gLy8gICAgIGZvcihsZXQgcm93TnVtID0gMDsgcm93TnVtIDwgcm93czsgcm93TnVtKyspe1xuLy8gLy8gICAgICAgICBmb3IgKGxldCBjb2xOdW0gPSAwOyBjb2xOdW0gPCBjb2xzLCBjb2xOdW0rKyl7XG4vLyAvLyAgICAgICAgICAgICBjZWxscy5wdXNoKG5ldyBDZWxsKHJvd051bSwgY29sTnVtKSlcbi8vIC8vICAgICAgICAgfVxuLy8gLy8gICAgIH1cblxuLy8gLy8gICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmNlbGxzLmxlbmd0aDsgaSsrKXtcblxuLy8gLy8gICAgIH1cblxuXG5cbi8vIGNvbnN0IFVzZXIgPSByZXF1aXJlKCcuL3VzZXInKTtcblxuLy8gZnVuY3Rpb24gR2FtZShncmlkKSB7XG4vLyAgICAgdGhpcy51c2VyID0gbmV3IFVzZXIoZ3JpZCk7XG4vLyAgICAgdGhpcy5lbmQgPSBbMTksIDE5XTtcbi8vICAgICB0aGlzLmdyaWQgPSBncmlkO1xuLy8gICAgIC8vIHRoaXMudXNlclBvcyA9IFswLCAwXTtcblxuLy8gICAgIHRoaXMuZmlyc3RVc2VyUmVuZGVyID0gZnVuY3Rpb24oKXtcbi8vICAgICAgICAgdGhpcy51c2VyLmRpc3BsYXkoKVxuLy8gICAgIH1cblxuLy8gICAgIHRoaXMudXNlclJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgdGhpcy51c2VyLnBlcnNpc3RhbnREaXNwbGF5KHRoaXMudXNlci5wb3NbMF0sIHRoaXMudXNlci5wb3NbMV0pO1xuLy8gICAgIH1cblxuLy8gICAgIC8vIHRoaXMucGxheSA9IGZ1bmN0aW9uICgpIHtcbi8vICAgICAvLyAgICAgdGhpcy51c2VyTW92ZSgpO1xuLy8gICAgIC8vIH1cblxuLy8gICAgIHRoaXMuZW5kID0gZnVuY3Rpb24gKHVzZXJQb3MpIHtcbi8vICAgICAgICAgdGhpcy51c2VyLnBvcyA9PT0gdGhpcy5lbmRcbi8vICAgICB9XG5cbi8vICAgICB0aGlzLnVzZXJNb3ZlID0gZnVuY3Rpb24gKCkge1xuXG4vLyAgICAgICAgIGxldCBwcmV2UG9zID0gdGhpcy51c2VyLnBvcztcbi8vICAgICAgICAgbGV0IHggPSBwcmV2UG9zWzBdO1xuLy8gICAgICAgICBsZXQgeSA9IHByZXZQb3NbMV07XG4vLyAgICAgICAgIGxldCBwcmV2Q2VsbCA9IGdyaWRbcHJldlBvc1swXV1bcHJldlBvc1sxXV07XG4vLyAgICAgICAgIC8vIGNvbnN0IGtleXByZXNzID0gZXZlbnQua2V5Q29kZTtcbi8vICAgICAgICAgLy8gY29uc29sZS5sb2coZXZlbnQpO1xuLy8gICAgICAgICBpZiAoa2V5SXNEb3duKExFRlRfQVJST1cpKSB7XG4vLyAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnVzZXIucG9zKVxuLy8gICAgICAgICAgICAgdGhpcy51c2VyLnVwZGF0ZVBvcyhbXCJ5XCIsIC00MF0pO1xuLy8gICAgICAgICAgICAgLy8gdGhpcy51c2VyLnVwZGF0ZVBvcyhbXCJ5XCIsIC0xXSwgcHJldlBvcyk7XG4vLyAgICAgICAgICAgICB0aGlzLnVzZXIucmVuZGVyKCk7XG4vLyAgICAgICAgICAgICAvLyBwcmV2Q2VsbC5yZXNldFJlbmRlcigpO1xuLy8gICAgICAgICAgICAgdGhpcy51c2VyLmRpc3BsYXkodGhpcy51c2VyLnBvcylcbi8vICAgICAgICAgfVxuXG4vLyAgICAgICAgIGlmIChrZXlJc0Rvd24oUklHSFRfQVJST1cpKSB7XG4vLyAgICAgICAgICAgICB0aGlzLnVzZXIudXBkYXRlUG9zKFtcInlcIiwgNDBdKTtcbi8vICAgICAgICAgICAgIC8vIHRoaXMudXNlci51cGRhdGVQb3MoW1wieVwiLCAxXSwgcHJldlBvcyk7XG4vLyAgICAgICAgICAgICB0aGlzLnVzZXIucmVuZGVyKCk7XG4vLyAgICAgICAgICAgICAvLyBwcmV2Q2VsbC5yZXNldFJlbmRlcigpO1xuLy8gICAgICAgICB9XG5cbi8vICAgICAgICAgaWYgKGtleUlzRG93bihVUF9BUlJPVykpIHtcbi8vICAgICAgICAgICAgIHRoaXMudXNlci51cGRhdGVQb3MoW1wieFwiLCAtNDBdKTtcbi8vICAgICAgICAgICAgIC8vIHRoaXMudXNlci51cGRhdGVQb3MoW1wieFwiLCAtMV0sIHByZXZQb3MpO1xuLy8gICAgICAgICAgICAgdGhpcy51c2VyLnJlbmRlcigpO1xuLy8gICAgICAgICAgICAgLy8gcHJldkNlbGwucmVzZXRSZW5kZXIoKTtcbi8vICAgICAgICAgfVxuXG4vLyAgICAgICAgIGlmIChrZXlJc0Rvd24oRE9XTl9BUlJPVykpIHtcbi8vICAgICAgICAgICAgIHRoaXMudXNlci51cGRhdGVQb3MoW1wieFwiLCA0MF0pO1xuLy8gICAgICAgICAgICAgLy8gdGhpcy51c2VyLnVwZGF0ZVBvcyhbXCJ4XCIsIDFdLCBwcmV2UG9zKTtcbi8vICAgICAgICAgICAgIHRoaXMudXNlci5yZW5kZXIoKTtcbi8vICAgICAgICAgICAgIC8vIHByZXZDZWxsLnJlc2V0UmVuZGVyKCk7XG4vLyAgICAgICAgIH1cblxuLy8gICAgICAgICAvLyB0aGlzLnVzZXIudXBkYXRlKCk7XG4vLyAgICAgICAgIC8vIHRoaXMudXNlci5kaXNwbGF5KCk7XG4vLyAgICAgICAgIC8vIGNvbnN0IGNvbG9ycyA9IFtcImxpZ2h0Y29yYWxcIiwgXCJvcmFuZ2VcIiwgXCJDaGFydHJldXNlXCIsIFwiZGFya2N5YW5cIiwgXCJkYXJrb3JjaGlkXCJdO1xuLy8gICAgICAgICAvLyBsZXQgY3VycmVudENvbG9yID0gY29sb3JzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNvbG9ycy5sZW5ndGgpXTtcblxuLy8gICAgICAgICAvLyBmaWxsKGN1cnJlbnRDb2xvcik7XG4vLyAgICAgICAgIC8vIGVsbGlwc2UoMTksIDE5LCAxNSwgMTUpO1xuLy8gICAgIH1cblxuLy8gfVxuXG4vLyBtb2R1bGUuZXhwb3J0cyA9IEdhbWU7XG4vLyAvLyAgICAgdGhpcy54RGltZW4gPSA5MDA7XG4vLyAvLyAgICAgdGhpcy55RGltZW4gPSA5MDA7XG4vLyAvLyAgICAgdGhpcy5jZWxscyA9IFtdO1xuLy8gLy8gfVxuXG4vLyAvLyBHYW1lLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihjYW52YXMpe1xuLy8gLy8gICAgIEdhbWUuc2V0VXAoKVxuLy8gLy8gfSlcblxuLy8gLy8gR2FtZS5wcm90b3R5cGUuc2V0VXAgPSBmdW5jdGlvbihtYXplQ2FudmFzKXtcbi8vIC8vICAgICBjb25zdCBjYW52YXMgPSBtYXplQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuLy8gLy8gICAgIGNhbnZhcy5maWxsU3R5bGUgPSBcInB1cnBsZVwiO1xuLy8gLy8gICAgIC8veCwgeSwgd2lkdGgsIGhlaWdodFxuLy8gLy8gICAgIGNhbnZhcy5maWxsUmVjdCgwLCAwLCA4MDAsIDgwMCk7XG5cbi8vIC8vICAgICBjb2xzID0gMTA7IC8vZWFjaCB3aWxsIGJlIDggeCA4XG4vLyAvLyAgICAgcm93cyA9IDEwO1xuXG4vLyAvLyAgICAgZm9yKGxldCByb3dOdW0gPSAwOyByb3dOdW0gPCByb3dzOyByb3dOdW0rKyl7XG4vLyAvLyAgICAgICAgIGZvciAobGV0IGNvbE51bSA9IDA7IGNvbE51bSA8IGNvbHMsIGNvbE51bSsrKXtcbi8vIC8vICAgICAgICAgICAgIGNlbGxzLnB1c2gobmV3IENlbGwocm93TnVtLCBjb2xOdW0pKVxuLy8gLy8gICAgICAgICB9XG4vLyAvLyAgICAgfVxuXG4vLyAvLyAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuY2VsbHMubGVuZ3RoOyBpKyspe1xuXG4vLyAvLyAgICAgfVxuXG5cbi8vIC8vIGNvbnN0IFVzZXIgPSByZXF1aXJlKCcuL3VzZXInKTtcblxuLy8gLy8gZnVuY3Rpb24gR2FtZSgpe1xuLy8gLy8gICAgIHRoaXMudXNlciA9IG5ldyBVc2VyKCk7XG4vLyAvLyAgICAgdGhpcy5lbmQgPSBbMTksIDE5XTtcbi8vIC8vICAgICAvLyB0aGlzLnVzZXJQb3MgPSBbMCwgMF07XG5cbi8vIC8vICAgICB0aGlzLnVzZXJSZW5kZXIgPSBmdW5jdGlvbigpe1xuLy8gLy8gICAgICAgICB0aGlzLnVzZXIucmVuZGVyKHRoaXMudXNlci5wb3NbMF0sIHRoaXMudXNlci5wb3NbMV0pO1xuLy8gLy8gICAgIH1cblxuLy8gLy8gICAgIC8vIHRoaXMucGxheSA9IGZ1bmN0aW9uKCl7XG4vLyAvLyAgICAgLy8gICAgIHRoaXMudXNlck1vdmUoKTtcbi8vIC8vICAgICAvLyB9XG5cbi8vIC8vICAgICB0aGlzLmVuZCA9IGZ1bmN0aW9uKHVzZXJQb3Mpe1xuLy8gLy8gICAgICAgICB0aGlzLnVzZXIucG9zID09PSB0aGlzLmVuZFxuLy8gLy8gICAgIH1cblxuLy8gLy8gICAgIHRoaXMudXNlck1vdmUgPSBmdW5jdGlvbigpe1xuLy8gLy8gICAgICAgICBpZiAoa2V5SXNEb3duKExFRlRfQVJST1cpKSB7XG4vLyAvLyAgICAgICAgICAgICB0aGlzLnVzZXIudXBkYXRlUG9zKFtcInlcIiwgLTQwXSk7XG4vLyAvLyAgICAgICAgICAgICB0aGlzLnVzZXIucmVuZGVyKCk7XG4vLyAvLyAgICAgICAgIH1cblxuLy8gLy8gICAgICAgICBpZiAoa2V5SXNEb3duKFJJR0hUX0FSUk9XKSkge1xuLy8gLy8gICAgICAgICAgICAgdGhpcy51c2VyLnVwZGF0ZVBvcyhbXCJ5XCIsIDQwXSk7XG4vLyAvLyAgICAgICAgICAgICB0aGlzLnVzZXIucmVuZGVyKCk7XG4vLyAvLyAgICAgICAgIH1cblxuLy8gLy8gICAgICAgICBpZiAoa2V5SXNEb3duKFVQX0FSUk9XKSkge1xuLy8gLy8gICAgICAgICAgICAgdGhpcy51c2VyLnVwZGF0ZVBvcyhbXCJ4XCIsIC00MF0pO1xuLy8gLy8gICAgICAgICAgICAgdGhpcy51c2VyLnJlbmRlcigpO1xuLy8gLy8gICAgICAgICB9XG5cbi8vIC8vICAgICAgICAgaWYgKGtleUlzRG93bihET1dOX0FSUk9XKSkge1xuLy8gLy8gICAgICAgICAgICAgdGhpcy51c2VyLnVwZGF0ZVBvcyhbXCJ4XCIsIDQwXSk7XG4vLyAvLyAgICAgICAgICAgICB0aGlzLnVzZXIucmVuZGVyKCk7XG4vLyAvLyAgICAgICAgIH1cblxuLy8gLy8gICAgICAgICBjb25zdCBjb2xvcnMgPSBbXCJsaWdodGNvcmFsXCIsIFwib3JhbmdlXCIsIFwiQ2hhcnRyZXVzZVwiLCBcImRhcmtjeWFuXCIsIFwiZGFya29yY2hpZFwiXTtcbi8vIC8vICAgICAgICAgbGV0IGN1cnJlbnRDb2xvciA9IGNvbG9yc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjb2xvcnMubGVuZ3RoKV07XG4vLyAvLyAgICAgICAgIGZpbGwoY3VycmVudENvbG9yKTtcbi8vIC8vICAgICAgICAgZWxsaXBzZSgxOSwgMTksIDE1LCAxNSk7XG4vLyAvLyAgICAgfVxuXG4vLyAvLyB9XG5cbi8vIC8vIG1vZHVsZS5leHBvcnRzID0gR2FtZTtcbi8vIC8vIC8vICAgICB0aGlzLnhEaW1lbiA9IDkwMDtcbi8vIC8vIC8vICAgICB0aGlzLnlEaW1lbiA9IDkwMDtcbi8vIC8vIC8vICAgICB0aGlzLmNlbGxzID0gW107XG4vLyAvLyAvLyB9XG5cbi8vIC8vIC8vIEdhbWUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKGNhbnZhcyl7XG4vLyAvLyAvLyAgICAgR2FtZS5zZXRVcCgpXG4vLyAvLyAvLyB9KVxuXG4vLyAvLyAvLyBHYW1lLnByb3RvdHlwZS5zZXRVcCA9IGZ1bmN0aW9uKG1hemVDYW52YXMpe1xuLy8gLy8gLy8gICAgIGNvbnN0IGNhbnZhcyA9IG1hemVDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4vLyAvLyAvLyAgICAgY2FudmFzLmZpbGxTdHlsZSA9IFwicHVycGxlXCI7XG4vLyAvLyAvLyAgICAgLy94LCB5LCB3aWR0aCwgaGVpZ2h0XG4vLyAvLyAvLyAgICAgY2FudmFzLmZpbGxSZWN0KDAsIDAsIDgwMCwgODAwKTtcblxuLy8gLy8gLy8gICAgIGNvbHMgPSAxMDsgLy9lYWNoIHdpbGwgYmUgOCB4IDhcbi8vIC8vIC8vICAgICByb3dzID0gMTA7XG5cbi8vIC8vIC8vICAgICBmb3IobGV0IHJvd051bSA9IDA7IHJvd051bSA8IHJvd3M7IHJvd051bSsrKXtcbi8vIC8vIC8vICAgICAgICAgZm9yIChsZXQgY29sTnVtID0gMDsgY29sTnVtIDwgY29scywgY29sTnVtKyspe1xuLy8gLy8gLy8gICAgICAgICAgICAgY2VsbHMucHVzaChuZXcgQ2VsbChyb3dOdW0sIGNvbE51bSkpXG4vLyAvLyAvLyAgICAgICAgIH1cbi8vIC8vIC8vICAgICB9XG5cbi8vIC8vIC8vICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5jZWxscy5sZW5ndGg7IGkrKyl7XG5cbi8vIC8vIC8vICAgICB9XG5cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./game.js\n");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nconst Cell = __webpack_require__(/*! ./cell */ \"./cell.js\");\n// const MovingObject = require('./moving_objects');\n// const User = require('./user');\nconst Game = __webpack_require__(/*! ./game */ \"./game.js\");\nconst Maze = __webpack_require__(/*! ./maze */ \"./maze.js\");\n\n// window.MovingObject = MovingObject;\n\nconst grid = [];\n\nlet current;\n\nconst stack = [];\n\nlet game;\nwindow.addEventListener(\"keypress\", (event) => (game.userMove(event)));\n\n\nlet maze;\n\nlet mapComplete = false;\n\n// const user = new User();\nlet title;\nlet canvas;\n\nfunction setup() {\n    title = createElement(\"h1\", \"ColorOut\");\n    title.position(1000, 20);\n\n    canvas = createCanvas(800, 800);\n    canvas.position(100, 90);\n\n    //   cols = 10;\n    //   rows = 10;\n\n    for (let x = 0; x < 20; x++) {\n        grid[x] = [];\n        for (let y = 0; y < 20; y++) {\n            grid[x].push(new Cell(x, y, grid, stack))\n        }\n    }\n\n    let current_row = Math.floor(Math.random() * 20);\n    let current_col = Math.floor(Math.random() * 20);\n\n    current = grid[current_row][current_col];\n    game = new Game(grid);\n    maze = new Maze(current, grid, game)\n\n    //   console.log(\"current\")\n    //   console.log(current)\n    // game.renderUser(this.user.color);\n\n    frameRate(100);\n\n \n\n}\n\n// const maze = new Maze(current, grid);\n\nfunction draw() {\n    // if(!mapComplete){\n    // game.userRender();\n\n    maze.draw();\n    // mapComplete = maze.mapComplete();\n    // }\n    // console.log(\"finish maze\")\n    // play(game)\n\n    \n    game.userMove();\n\n    if(game.end){\n        console.log(\"congrats\")\n    }\n\n    // game.userRender();\n\n    // game.userRender(0, 0);\n\n    // const keypress = event.keyCode;\n    // console.log(event);\n\n\n    // game.userMove();\n    // game.user.draw();\n\n    // loop();\n    // background(51)\n\n    // if(!map && !gameEnd){\n    //     if (current) {\n    //         current.visited = true;\n    //     // current.highlight();\n    //         stack.push(current);\n    //     }\n\n\n    //     // let nextCell = current.getNextCell(current.row, current.col);\n    //     let nextCell = current.getNeighbor();\n\n    //     // console.log(\"nextcell\")\n    //     // console.log(nextCell);\n\n    //     this.removeWalls = function(current, next, grid){\n    //         const changeX = current.row - next.row;\n    //         const changeY = current.col - next.col;\n\n\n    //         switch(changeX){\n    //             case 1:\n    //                 current.walls[0].present = false;  \n    //                 next.walls[2].present = false;\n    //                 break;\n    //             case -1:\n    //                 current.walls[2].present = false;\n    //                 next.walls[0].present = false;\n    //                 break;\n    //         }\n\n    //         switch (changeY) {\n    //             case 1:\n    //                 current.walls[3].present = false;\n    //                 next.walls[1].present = false;\n    //                 break;\n    //             case -1:\n    //                 current.walls[1].present = false;\n    //                 next.walls[3].present = false;\n    //                 break;\n    //         }\n\n    //         // const firstRow = grid[0];\n    //         // const lastRow = grid[19];\n\n    //         // for (let i = 0; i < firstRow.length; i++) {\n    //         //     firstRow[i].walls[3].present = true\n    //         // }\n\n    //         // for (let i = 0; i < lastRow.length; i++) {\n    //         //     lastRow[i].walls[1].present = true\n    //         // }\n\n    //         // const firstCol = grid.filter((cell) => {\n    //         //     return cell.col === 0\n    //         // })\n\n    //         // const lastCol = grid.filter((cell) => {\n    //         //     return cell.col === 19\n    //         // })\n\n    //         // for (let i = 0; i < firstCol.length; i++) {\n    //         //     firstCol[i].walls[2].present = true;\n    //         // }\n\n    //         // for (let i = 0; i < lastCol.length; i++) {\n    //         //     lastCol[i].walls[0].present = true;\n    //         // }\n    //     } \n\n    //     if(nextCell){\n    //         nextCell.visited = true;\n    //         this.removeWalls(current, nextCell, grid);\n    //         current = nextCell;\n    //         // console.log(\"stack\")\n    //         // console.log(stack);\n    //     } else if(stack.length > 0){\n    //         potentialRestart = stack.pop()\n    //             while (potentialRestart && !potentialRestart.getNeighbor()){\n    //                 if(!stack.length){\n    //                     potentialRestart.visited = true\n    //                     map = true;\n    //                     noLoop();\n    //                     break;\n    //                 } else {\n    //                     potentialRestart = stack.pop();\n    //                 }\n    //             }\n    //             current = potentialRestart;\n    //             // console.log(current)\n    //     // } else if(allVisited) {\n    //     //     noLoop();\n    //     }\n\n\n    //     for (let i = 0; i < grid.length; i++) {\n    //         for (let j = 0; j < grid[i].length; j++) {\n    //             grid[i][j].render();\n    //         }\n    //     }\n\n    //     game.userRender();\n    // } else if(map && !gameEnd){\n    //     // loop()\n    //     console.log(\"hi\")\n    //     game.userRender();\n    //     // game.userMove();\n    //     keyPressed();\n\n    //     for (let i = 0; i < grid.length; i++) {\n    //         for (let j = 0; j < grid[i].length; j++) {\n    //             grid[i][j].render();\n    //         }\n    //     }\n\n    // }\n\n    // // current.highlight();\n\n    // function keyPressed(){\n    //     // loop();\n    //     game.userMove();\n    //     // loop()        \n    //     return false;\n    // }\n\n    // keyPressed();\n\n    // // user.render();\n\n\n\n    // // redraw();\n\n    // // while (!game.end()){\n    // //     game.userMove()\n    // // }\n\n}\n\nfunction play(game){\n    game.userRender();\n    // redraw();\n}\n\n// function Cell(row, col) {\n//     this.row = row;\n//     this.col = col;\n//     this.walls = [new Wall(), new Wall(), new Wall(), new Wall()];\n//     this.visited = false;\n\n//     this.render = function () {\n//         const startRow = this.row * 40;\n//         const startCol = this.col * 40;\n\n//         // x, y, width, height\n//         // rect(startX, startY, 40, 40)\n//         // noFill();\n//         for(let i = 0; i < this.walls.length; i++){\n//             this.walls[i].render(i, startRow, startCol);\n//         }\n\n//         if(this.visited){\n//             rect(startRow, startCol, 40, 40)\n//             fill(\"green\");\n//         }\n\n//     }\n\n//     this.getNeighbor = function(){\n\n//         // const neighborsIndices = [\n//         //     [row - 1, col],\n//         //     [row + 1, col],\n//         //     [row, col - 1],\n//         //     [row, col + 1]            \n//         // ]\n\n//         const neighbors = [\n//             grid[row - 1][col],\n//             grid[row + 1][col],\n//             grid[row][col - 1],\n//             grid[row][col + 1]            \n//         ]\n\n//         // const neighbors = [];\n\n//         // const validateIdx = function (idxArr) {\n//         //     if(idxArr.every((idx) => {\n//         //         return idx < 20 && idx >= 0}\n//         //         )){\n\n//         //         neighbors.push(idxArr);\n//         //     }\n//         // }\n\n//         // let top = [(row - 1), col];\n//         // validateIdx(top);\n//         // let right = [row, (col+1)];\n//         // validateIdx(right);\n//         // let bottom = [(row + 1), col];\n//         // validateIdx(bottom);\n//         // let left = [row, (col - 1)];\n//         // validateIdx(left);\n\n//         console.log(neighbors)\n\n//         const validNeighbors = [];\n\n//         // for(let i = 0; i < neighbors.length; i++){\n//         //     if ((neighbors[i][0] < 20 && neighbors[i][0] >= 0) && (neighbors[i][1] < 20 && neighbors[i][1] >= 0)) {\n//         //         validNeighbors.push(neighbors[i]);\n//         //     }\n//         // }\n\n//         // const validNeighbors = neighbors.filter(neighbor => {\n//         //     // let x = neighbor[0];\n//         //     // let y = neighbor[1];\n\n//         //     if((neighbor[0] < 20 && neighbor[0] >= 0) && (neighbor[1] < 20 && neighbor[1] >= 0)){\n//         //         return neighbor;\n//         //     }\n//         // }\n\n//         // const validateNeighbors = function(neighbor) {\n//         //     if(!neighbor){\n//         //         return false;\n//         //     }\n//         //     // let x = neighbor[0];\n//         //     // let y = neighbor[1];\n\n//         //     if(neighbor.row < 20 || neighbor.row >=0){\n//         //         return false;\n//         //     } else if(neighbor.col < 20 || neighbor.col >= 0){\n//         //         return false;\n//         //     } else{\n//         //         return true\n//         //     }\n\n//         // }\n\n//         // const validateNeighbors = function(neighbor){\n//         //     console.log(neighbor)\n//         //     neighbor\n//         // }\n\n//         // const validNeighbors = neighbors.filter(validateNeighbors);\n\n//         for(let i = 0; i < neighbors.length; i++){\n//             if(neighbors[i] && !(neighbors[i].visited)){\n//                 validNeighbors.push(neighbors[i])\n//             }\n//         }\n\n\n//         console.log(\"valid\") \n//         console.log(validNeighbors)\n\n//         let nextCell;\n\n//         if(validNeighbors.length > 0){\n//             nextCell = this.chooseRandomNeighbor(validNeighbors);\n//             return nextCell;\n//         }\n//         // let nextCell = \n\n//         // //need to check if nextCell is true bc it could be undefined at the edges\n//         // while(nextCell && nextCell.visited){\n//             //     nextCell = this.chooseRandomNeighbor(neighbors)\n\n//             //     if(nextCell && !nextCell.visited){\n//                 //         return nextCell\n//                 //     }\n//                 // }\n\n//                 // if (nextCell) {\n//                     //     rect(startRow, startCol, 40, 40)\n//                     //     fill(\"purple\");\n//                     // }\n//                     // console.log(nextCell)\n//                     // return nextCell;\n\n//     }\n\n//     this.chooseRandomNeighbor = function(validNeighbors) {\n//        return validNeighbors[Math.floor(Math.random() * validNeighbors.length)] \n//     }\n\n// }\n\n// function Wall(){\n//     this.present = true;\n\n//     this.render = function(i, x, y){\n//         stroke(255);\n//         switch(i){\n//             case 0: \n//                 line(x, y, x, y + 40)\n//             case 1:\n//                 line(x, y + 40, x + 40, y + 40)\n//             case 2: \n//                 line(x + 40, y + 40, x + 40, y)\n//             case 3:\n//                 line(x + 40, y, x, y)\n//         }\n//     }\n// }\n\nwindow.setup = setup;\n\nwindow.draw = draw;\n\n//p5 cannot find the functions, \n//so we need to set it to the window so the fx can be found \n\n// const Cell = require('./cell');\n// // const MovingObject = require('./moving_objects');\n// // const User = require('./user');\n// const Game = require('./game');\n\n// // window.MovingObject = MovingObject;\n\n// const grid = [];\n\n// let current;\n\n// const stack = [];\n\n// let game = new Game();\n\n// let map = false;\n\n// let gameEnd = false;\n\n// // const user = new User();\n\n// function setup() {\n//   createCanvas(800, 800);\n// //   cols = 10;\n// //   rows = 10;\n\n//   for(let x = 0; x < 20; x++){\n//       grid[x] = [];\n//       for(let y = 0; y < 20; y++){\n//         grid[x].push(new Cell(x, y, grid, stack))\n//       }\n//   }\n\n//   let current_row = Math.floor(Math.random() * 20);\n//   let current_col = Math.floor(Math.random() * 20);\n\n//   current = grid[current_row][current_col];\n\n//   //   console.log(\"current\")\n// //   console.log(current)\n\n//   frameRate(100);\n\n// }\n\n// function draw() {\n//     background(51)\n\n//     if(!map && !gameEnd){\n//         if (current) {\n//             current.visited = true;\n//         // current.highlight();\n//             stack.push(current);\n//         }\n\n\n//         // let nextCell = current.getNextCell(current.row, current.col);\n//         let nextCell = current.getNeighbor();\n\n//         // console.log(\"nextcell\")\n//         // console.log(nextCell);\n\n//         this.removeWalls = function(current, next, grid){\n//             const changeX = current.row - next.row;\n//             const changeY = current.col - next.col;\n\n//             // current.walls.forEach(wall => wall.present = false)\n\n\n//             switch(changeX){\n//                 case 1:\n//                     current.walls[0].present = false;  \n//                     next.walls[2].present = false;\n//                     break;\n//                 case -1:\n//                     current.walls[2].present = false;\n//                     next.walls[0].present = false;\n//                     break;\n//             }\n\n//             switch (changeY) {\n//                 case 1:\n//                     current.walls[3].present = false;\n//                     next.walls[1].present = false;\n//                     break;\n//                 case -1:\n//                     current.walls[1].present = false;\n//                     next.walls[3].present = false;\n//                     break;\n//             }\n\n//             // const firstRow = grid[0];\n//             // const lastRow = grid[19];\n\n//             // for (let i = 0; i < firstRow.length; i++) {\n//             //     firstRow[i].walls[3].present = true\n//             // }\n\n//             // for (let i = 0; i < lastRow.length; i++) {\n//             //     lastRow[i].walls[1].present = true\n//             // }\n\n//             // const firstCol = grid.filter((cell) => {\n//             //     return cell.col === 0\n//             // })\n\n//             // const lastCol = grid.filter((cell) => {\n//             //     return cell.col === 19\n//             // })\n\n//             // for (let i = 0; i < firstCol.length; i++) {\n//             //     firstCol[i].walls[2].present = true;\n//             // }\n\n//             // for (let i = 0; i < lastCol.length; i++) {\n//             //     lastCol[i].walls[0].present = true;\n//             // }\n//         } \n\n//         if(nextCell){\n//             nextCell.visited = true;\n//             this.removeWalls(current, nextCell, grid);\n//             current = nextCell;\n//             // console.log(\"stack\")\n//             // console.log(stack);\n//         } else if(stack.length > 0){\n//             potentialRestart = stack.pop()\n//                 while (potentialRestart && !potentialRestart.getNeighbor()){\n//                     if(!stack.length){\n//                         potentialRestart.visited = true\n//                         map = true;\n//                         noLoop();\n//                         break;\n//                     } else {\n//                         potentialRestart = stack.pop();\n//                     }\n//                 }\n//                 current = potentialRestart;\n//                 // console.log(current)\n//         // } else if(allVisited) {\n//         //     noLoop();\n//         }\n\n\n//         for (let i = 0; i < grid.length; i++) {\n//             for (let j = 0; j < grid[i].length; j++) {\n//                 grid[i][j].render();\n//             }\n//         }\n\n//         game.userRender();\n//     } else if(map && !gameEnd){\n//         // loop()\n//         console.log(\"hi\")\n//         game.userRender();\n//         // game.userMove();\n//         keyPressed();\n\n//     }\n\n//     // current.highlight();\n\n//     function keyPressed(){\n//         // loop();\n//         game.userMove();\n//         // loop()        \n//         return false;\n//     }\n\n//     keyPressed();\n\n//     // user.render();\n\n\n\n//     // redraw();\n\n//     // while (!game.end()){\n//     //     game.userMove()\n//     // }\n\n// }\n\n// // function Cell(row, col) {\n// //     this.row = row;\n// //     this.col = col;\n// //     this.walls = [new Wall(), new Wall(), new Wall(), new Wall()];\n// //     this.visited = false;\n\n// //     this.render = function () {\n// //         const startRow = this.row * 40;\n// //         const startCol = this.col * 40;\n\n// //         // x, y, width, height\n// //         // rect(startX, startY, 40, 40)\n// //         // noFill();\n// //         for(let i = 0; i < this.walls.length; i++){\n// //             this.walls[i].render(i, startRow, startCol);\n// //         }\n\n// //         if(this.visited){\n// //             rect(startRow, startCol, 40, 40)\n// //             fill(\"green\");\n// //         }\n\n// //     }\n\n// //     this.getNeighbor = function(){\n\n// //         // const neighborsIndices = [\n// //         //     [row - 1, col],\n// //         //     [row + 1, col],\n// //         //     [row, col - 1],\n// //         //     [row, col + 1]            \n// //         // ]\n\n// //         const neighbors = [\n// //             grid[row - 1][col],\n// //             grid[row + 1][col],\n// //             grid[row][col - 1],\n// //             grid[row][col + 1]            \n// //         ]\n\n// //         // const neighbors = [];\n\n// //         // const validateIdx = function (idxArr) {\n// //         //     if(idxArr.every((idx) => {\n// //         //         return idx < 20 && idx >= 0}\n// //         //         )){\n\n// //         //         neighbors.push(idxArr);\n// //         //     }\n// //         // }\n\n// //         // let top = [(row - 1), col];\n// //         // validateIdx(top);\n// //         // let right = [row, (col+1)];\n// //         // validateIdx(right);\n// //         // let bottom = [(row + 1), col];\n// //         // validateIdx(bottom);\n// //         // let left = [row, (col - 1)];\n// //         // validateIdx(left);\n\n// //         console.log(neighbors)\n\n// //         const validNeighbors = [];\n\n// //         // for(let i = 0; i < neighbors.length; i++){\n// //         //     if ((neighbors[i][0] < 20 && neighbors[i][0] >= 0) && (neighbors[i][1] < 20 && neighbors[i][1] >= 0)) {\n// //         //         validNeighbors.push(neighbors[i]);\n// //         //     }\n// //         // }\n\n// //         // const validNeighbors = neighbors.filter(neighbor => {\n// //         //     // let x = neighbor[0];\n// //         //     // let y = neighbor[1];\n\n// //         //     if((neighbor[0] < 20 && neighbor[0] >= 0) && (neighbor[1] < 20 && neighbor[1] >= 0)){\n// //         //         return neighbor;\n// //         //     }\n// //         // }\n\n// //         // const validateNeighbors = function(neighbor) {\n// //         //     if(!neighbor){\n// //         //         return false;\n// //         //     }\n// //         //     // let x = neighbor[0];\n// //         //     // let y = neighbor[1];\n\n// //         //     if(neighbor.row < 20 || neighbor.row >=0){\n// //         //         return false;\n// //         //     } else if(neighbor.col < 20 || neighbor.col >= 0){\n// //         //         return false;\n// //         //     } else{\n// //         //         return true\n// //         //     }\n\n// //         // }\n\n// //         // const validateNeighbors = function(neighbor){\n// //         //     console.log(neighbor)\n// //         //     neighbor\n// //         // }\n\n// //         // const validNeighbors = neighbors.filter(validateNeighbors);\n\n// //         for(let i = 0; i < neighbors.length; i++){\n// //             if(neighbors[i] && !(neighbors[i].visited)){\n// //                 validNeighbors.push(neighbors[i])\n// //             }\n// //         }\n\n\n// //         console.log(\"valid\") \n// //         console.log(validNeighbors)\n\n// //         let nextCell;\n\n// //         if(validNeighbors.length > 0){\n// //             nextCell = this.chooseRandomNeighbor(validNeighbors);\n// //             return nextCell;\n// //         }\n// //         // let nextCell = \n\n// //         // //need to check if nextCell is true bc it could be undefined at the edges\n// //         // while(nextCell && nextCell.visited){\n// //             //     nextCell = this.chooseRandomNeighbor(neighbors)\n\n// //             //     if(nextCell && !nextCell.visited){\n// //                 //         return nextCell\n// //                 //     }\n// //                 // }\n\n// //                 // if (nextCell) {\n// //                     //     rect(startRow, startCol, 40, 40)\n// //                     //     fill(\"purple\");\n// //                     // }\n// //                     // console.log(nextCell)\n// //                     // return nextCell;\n\n// //     }\n\n// //     this.chooseRandomNeighbor = function(validNeighbors) {\n// //        return validNeighbors[Math.floor(Math.random() * validNeighbors.length)] \n// //     }\n\n// // }\n\n// // function Wall(){\n// //     this.present = true;\n\n// //     this.render = function(i, x, y){\n// //         stroke(255);\n// //         switch(i){\n// //             case 0: \n// //                 line(x, y, x, y + 40)\n// //             case 1:\n// //                 line(x, y + 40, x + 40, y + 40)\n// //             case 2: \n// //                 line(x + 40, y + 40, x + 40, y)\n// //             case 3:\n// //                 line(x + 40, y, x, y)\n// //         }\n// //     }\n// // }\n\n// window.setup = setup;\n\n// window.draw = draw;\n\n// //p5 cannot find the functions, \n// //so we need to set it to the window so the fx can be found \n\n// const Cell = require('./cell');\n// // const MovingObject = require('./moving_objects');\n// // const User = require('./user');\n// const Game = require('./game');\n// const Maze = require('./maze');\n\n// // window.MovingObject = MovingObject;\n\n// const grid = [];\n\n// let current;\n\n// const stack = [];\n\n// let game;\n// window.addEventListener(\"keypress\", (event) => (game.userMove(event)));\n\n\n// let maze;\n\n// let mapComplete = false;\n\n// // const user = new User();\n\n// function setup() {\n//     createCanvas(800, 800);\n//     //   cols = 10;\n//     //   rows = 10;\n\n//     for (let x = 0; x < 20; x++) {\n//         grid[x] = [];\n//         for (let y = 0; y < 20; y++) {\n//             grid[x].push(new Cell(x, y, grid, stack))\n//         }\n//     }\n\n//     let current_row = Math.floor(Math.random() * 20);\n//     let current_col = Math.floor(Math.random() * 20);\n\n//     current = grid[current_row][current_col];\n//     game = new Game(grid);\n//     maze = new Maze(current, grid, game);\n\n//     //   console.log(\"current\")\n//     //   console.log(current)\n\n//     frameRate(100);\n\n// }\n\n// // const maze = new Maze(current, grid);\n\n// function draw() {\n//     // if(!mapComplete){\n//     game.firstUserRender();\n//     maze.draw();\n//     // mapComplete = maze.mapComplete();\n//     // }\n//     // console.log(\"finish maze\")\n//     game.userMove();\n//     game.userRender();\n//     // console.log(game.user.pos)\n//     // game.userRender(0, 0);\n\n//     // const keypress = event.keyCode;\n//     // console.log(event);\n\n\n//     // game.userMove();\n//     // game.user.draw();\n\n//     // loop();\n//     // background(51)\n\n//     // if(!map && !gameEnd){\n//     //     if (current) {\n//     //         current.visited = true;\n//     //     // current.highlight();\n//     //         stack.push(current);\n//     //     }\n\n\n//     //     // let nextCell = current.getNextCell(current.row, current.col);\n//     //     let nextCell = current.getNeighbor();\n\n//     //     // console.log(\"nextcell\")\n//     //     // console.log(nextCell);\n\n//     //     this.removeWalls = function(current, next, grid){\n//     //         const changeX = current.row - next.row;\n//     //         const changeY = current.col - next.col;\n\n\n//     //         switch(changeX){\n//     //             case 1:\n//     //                 current.walls[0].present = false;  \n//     //                 next.walls[2].present = false;\n//     //                 break;\n//     //             case -1:\n//     //                 current.walls[2].present = false;\n//     //                 next.walls[0].present = false;\n//     //                 break;\n//     //         }\n\n//     //         switch (changeY) {\n//     //             case 1:\n//     //                 current.walls[3].present = false;\n//     //                 next.walls[1].present = false;\n//     //                 break;\n//     //             case -1:\n//     //                 current.walls[1].present = false;\n//     //                 next.walls[3].present = false;\n//     //                 break;\n//     //         }\n\n//     //         // const firstRow = grid[0];\n//     //         // const lastRow = grid[19];\n\n//     //         // for (let i = 0; i < firstRow.length; i++) {\n//     //         //     firstRow[i].walls[3].present = true\n//     //         // }\n\n//     //         // for (let i = 0; i < lastRow.length; i++) {\n//     //         //     lastRow[i].walls[1].present = true\n//     //         // }\n\n//     //         // const firstCol = grid.filter((cell) => {\n//     //         //     return cell.col === 0\n//     //         // })\n\n//     //         // const lastCol = grid.filter((cell) => {\n//     //         //     return cell.col === 19\n//     //         // })\n\n//     //         // for (let i = 0; i < firstCol.length; i++) {\n//     //         //     firstCol[i].walls[2].present = true;\n//     //         // }\n\n//     //         // for (let i = 0; i < lastCol.length; i++) {\n//     //         //     lastCol[i].walls[0].present = true;\n//     //         // }\n//     //     } \n\n//     //     if(nextCell){\n//     //         nextCell.visited = true;\n//     //         this.removeWalls(current, nextCell, grid);\n//     //         current = nextCell;\n//     //         // console.log(\"stack\")\n//     //         // console.log(stack);\n//     //     } else if(stack.length > 0){\n//     //         potentialRestart = stack.pop()\n//     //             while (potentialRestart && !potentialRestart.getNeighbor()){\n//     //                 if(!stack.length){\n//     //                     potentialRestart.visited = true\n//     //                     map = true;\n//     //                     noLoop();\n//     //                     break;\n//     //                 } else {\n//     //                     potentialRestart = stack.pop();\n//     //                 }\n//     //             }\n//     //             current = potentialRestart;\n//     //             // console.log(current)\n//     //     // } else if(allVisited) {\n//     //     //     noLoop();\n//     //     }\n\n\n//     //     for (let i = 0; i < grid.length; i++) {\n//     //         for (let j = 0; j < grid[i].length; j++) {\n//     //             grid[i][j].render();\n//     //         }\n//     //     }\n\n//     //     game.userRender();\n//     // } else if(map && !gameEnd){\n//     //     // loop()\n//     //     console.log(\"hi\")\n//     //     game.userRender();\n//     //     // game.userMove();\n//     //     keyPressed();\n\n//     //     for (let i = 0; i < grid.length; i++) {\n//     //         for (let j = 0; j < grid[i].length; j++) {\n//     //             grid[i][j].render();\n//     //         }\n//     //     }\n\n//     // }\n\n//     // // current.highlight();\n\n//     // function keyPressed(){\n//     //     // loop();\n//     //     game.userMove();\n//     //     // loop()        \n//     //     return false;\n//     // }\n\n//     // keyPressed();\n\n//     // // user.render();\n\n\n\n//     // // redraw();\n\n//     // // while (!game.end()){\n//     // //     game.userMove()\n//     // // }\n\n// }\n\n\n// // function Cell(row, col) {\n// //     this.row = row;\n// //     this.col = col;\n// //     this.walls = [new Wall(), new Wall(), new Wall(), new Wall()];\n// //     this.visited = false;\n\n// //     this.render = function () {\n// //         const startRow = this.row * 40;\n// //         const startCol = this.col * 40;\n\n// //         // x, y, width, height\n// //         // rect(startX, startY, 40, 40)\n// //         // noFill();\n// //         for(let i = 0; i < this.walls.length; i++){\n// //             this.walls[i].render(i, startRow, startCol);\n// //         }\n\n// //         if(this.visited){\n// //             rect(startRow, startCol, 40, 40)\n// //             fill(\"green\");\n// //         }\n\n// //     }\n\n// //     this.getNeighbor = function(){\n\n// //         // const neighborsIndices = [\n// //         //     [row - 1, col],\n// //         //     [row + 1, col],\n// //         //     [row, col - 1],\n// //         //     [row, col + 1]            \n// //         // ]\n\n// //         const neighbors = [\n// //             grid[row - 1][col],\n// //             grid[row + 1][col],\n// //             grid[row][col - 1],\n// //             grid[row][col + 1]            \n// //         ]\n\n// //         // const neighbors = [];\n\n// //         // const validateIdx = function (idxArr) {\n// //         //     if(idxArr.every((idx) => {\n// //         //         return idx < 20 && idx >= 0}\n// //         //         )){\n\n// //         //         neighbors.push(idxArr);\n// //         //     }\n// //         // }\n\n// //         // let top = [(row - 1), col];\n// //         // validateIdx(top);\n// //         // let right = [row, (col+1)];\n// //         // validateIdx(right);\n// //         // let bottom = [(row + 1), col];\n// //         // validateIdx(bottom);\n// //         // let left = [row, (col - 1)];\n// //         // validateIdx(left);\n\n// //         console.log(neighbors)\n\n// //         const validNeighbors = [];\n\n// //         // for(let i = 0; i < neighbors.length; i++){\n// //         //     if ((neighbors[i][0] < 20 && neighbors[i][0] >= 0) && (neighbors[i][1] < 20 && neighbors[i][1] >= 0)) {\n// //         //         validNeighbors.push(neighbors[i]);\n// //         //     }\n// //         // }\n\n// //         // const validNeighbors = neighbors.filter(neighbor => {\n// //         //     // let x = neighbor[0];\n// //         //     // let y = neighbor[1];\n\n// //         //     if((neighbor[0] < 20 && neighbor[0] >= 0) && (neighbor[1] < 20 && neighbor[1] >= 0)){\n// //         //         return neighbor;\n// //         //     }\n// //         // }\n\n// //         // const validateNeighbors = function(neighbor) {\n// //         //     if(!neighbor){\n// //         //         return false;\n// //         //     }\n// //         //     // let x = neighbor[0];\n// //         //     // let y = neighbor[1];\n\n// //         //     if(neighbor.row < 20 || neighbor.row >=0){\n// //         //         return false;\n// //         //     } else if(neighbor.col < 20 || neighbor.col >= 0){\n// //         //         return false;\n// //         //     } else{\n// //         //         return true\n// //         //     }\n\n// //         // }\n\n// //         // const validateNeighbors = function(neighbor){\n// //         //     console.log(neighbor)\n// //         //     neighbor\n// //         // }\n\n// //         // const validNeighbors = neighbors.filter(validateNeighbors);\n\n// //         for(let i = 0; i < neighbors.length; i++){\n// //             if(neighbors[i] && !(neighbors[i].visited)){\n// //                 validNeighbors.push(neighbors[i])\n// //             }\n// //         }\n\n\n// //         console.log(\"valid\") \n// //         console.log(validNeighbors)\n\n// //         let nextCell;\n\n// //         if(validNeighbors.length > 0){\n// //             nextCell = this.chooseRandomNeighbor(validNeighbors);\n// //             return nextCell;\n// //         }\n// //         // let nextCell = \n\n// //         // //need to check if nextCell is true bc it could be undefined at the edges\n// //         // while(nextCell && nextCell.visited){\n// //             //     nextCell = this.chooseRandomNeighbor(neighbors)\n\n// //             //     if(nextCell && !nextCell.visited){\n// //                 //         return nextCell\n// //                 //     }\n// //                 // }\n\n// //                 // if (nextCell) {\n// //                     //     rect(startRow, startCol, 40, 40)\n// //                     //     fill(\"purple\");\n// //                     // }\n// //                     // console.log(nextCell)\n// //                     // return nextCell;\n\n// //     }\n\n// //     this.chooseRandomNeighbor = function(validNeighbors) {\n// //        return validNeighbors[Math.floor(Math.random() * validNeighbors.length)] \n// //     }\n\n// // }\n\n// // function Wall(){\n// //     this.present = true;\n\n// //     this.render = function(i, x, y){\n// //         stroke(255);\n// //         switch(i){\n// //             case 0: \n// //                 line(x, y, x, y + 40)\n// //             case 1:\n// //                 line(x, y + 40, x + 40, y + 40)\n// //             case 2: \n// //                 line(x + 40, y + 40, x + 40, y)\n// //             case 3:\n// //                 line(x + 40, y, x, y)\n// //         }\n// //     }\n// // }\n\n// window.setup = setup;\n\n// window.draw = draw;\n\n// //p5 cannot find the functions, \n// //so we need to set it to the window so the fx can be found \n\n// // const Cell = require('./cell');\n// // // const MovingObject = require('./moving_objects');\n// // // const User = require('./user');\n// // const Game = require('./game');\n\n// // // window.MovingObject = MovingObject;\n\n// // const grid = [];\n\n// // let current;\n\n// // const stack = [];\n\n// // let game = new Game();\n\n// // let map = false;\n\n// // let gameEnd = false;\n\n// // // const user = new User();\n\n// // function setup() {\n// //   createCanvas(800, 800);\n// // //   cols = 10;\n// // //   rows = 10;\n\n// //   for(let x = 0; x < 20; x++){\n// //       grid[x] = [];\n// //       for(let y = 0; y < 20; y++){\n// //         grid[x].push(new Cell(x, y, grid, stack))\n// //       }\n// //   }\n\n// //   let current_row = Math.floor(Math.random() * 20);\n// //   let current_col = Math.floor(Math.random() * 20);\n\n// //   current = grid[current_row][current_col];\n\n// //   //   console.log(\"current\")\n// // //   console.log(current)\n\n// //   frameRate(100);\n\n// // }\n\n// // function draw() {\n// //     background(51)\n\n// //     if(!map && !gameEnd){\n// //         if (current) {\n// //             current.visited = true;\n// //         // current.highlight();\n// //             stack.push(current);\n// //         }\n\n\n// //         // let nextCell = current.getNextCell(current.row, current.col);\n// //         let nextCell = current.getNeighbor();\n\n// //         // console.log(\"nextcell\")\n// //         // console.log(nextCell);\n\n// //         this.removeWalls = function(current, next, grid){\n// //             const changeX = current.row - next.row;\n// //             const changeY = current.col - next.col;\n\n// //             // current.walls.forEach(wall => wall.present = false)\n\n\n// //             switch(changeX){\n// //                 case 1:\n// //                     current.walls[0].present = false;  \n// //                     next.walls[2].present = false;\n// //                     break;\n// //                 case -1:\n// //                     current.walls[2].present = false;\n// //                     next.walls[0].present = false;\n// //                     break;\n// //             }\n\n// //             switch (changeY) {\n// //                 case 1:\n// //                     current.walls[3].present = false;\n// //                     next.walls[1].present = false;\n// //                     break;\n// //                 case -1:\n// //                     current.walls[1].present = false;\n// //                     next.walls[3].present = false;\n// //                     break;\n// //             }\n\n// //             // const firstRow = grid[0];\n// //             // const lastRow = grid[19];\n\n// //             // for (let i = 0; i < firstRow.length; i++) {\n// //             //     firstRow[i].walls[3].present = true\n// //             // }\n\n// //             // for (let i = 0; i < lastRow.length; i++) {\n// //             //     lastRow[i].walls[1].present = true\n// //             // }\n\n// //             // const firstCol = grid.filter((cell) => {\n// //             //     return cell.col === 0\n// //             // })\n\n// //             // const lastCol = grid.filter((cell) => {\n// //             //     return cell.col === 19\n// //             // })\n\n// //             // for (let i = 0; i < firstCol.length; i++) {\n// //             //     firstCol[i].walls[2].present = true;\n// //             // }\n\n// //             // for (let i = 0; i < lastCol.length; i++) {\n// //             //     lastCol[i].walls[0].present = true;\n// //             // }\n// //         } \n\n// //         if(nextCell){\n// //             nextCell.visited = true;\n// //             this.removeWalls(current, nextCell, grid);\n// //             current = nextCell;\n// //             // console.log(\"stack\")\n// //             // console.log(stack);\n// //         } else if(stack.length > 0){\n// //             potentialRestart = stack.pop()\n// //                 while (potentialRestart && !potentialRestart.getNeighbor()){\n// //                     if(!stack.length){\n// //                         potentialRestart.visited = true\n// //                         map = true;\n// //                         noLoop();\n// //                         break;\n// //                     } else {\n// //                         potentialRestart = stack.pop();\n// //                     }\n// //                 }\n// //                 current = potentialRestart;\n// //                 // console.log(current)\n// //         // } else if(allVisited) {\n// //         //     noLoop();\n// //         }\n\n\n// //         for (let i = 0; i < grid.length; i++) {\n// //             for (let j = 0; j < grid[i].length; j++) {\n// //                 grid[i][j].render();\n// //             }\n// //         }\n\n// //         game.userRender();\n// //     } else if(map && !gameEnd){\n// //         // loop()\n// //         console.log(\"hi\")\n// //         game.userRender();\n// //         // game.userMove();\n// //         keyPressed();\n\n// //     }\n\n// //     // current.highlight();\n\n// //     function keyPressed(){\n// //         // loop();\n// //         game.userMove();\n// //         // loop()        \n// //         return false;\n// //     }\n\n// //     keyPressed();\n\n// //     // user.render();\n\n\n\n// //     // redraw();\n\n// //     // while (!game.end()){\n// //     //     game.userMove()\n// //     // }\n\n// // }\n\n// // // function Cell(row, col) {\n// // //     this.row = row;\n// // //     this.col = col;\n// // //     this.walls = [new Wall(), new Wall(), new Wall(), new Wall()];\n// // //     this.visited = false;\n\n// // //     this.render = function () {\n// // //         const startRow = this.row * 40;\n// // //         const startCol = this.col * 40;\n\n// // //         // x, y, width, height\n// // //         // rect(startX, startY, 40, 40)\n// // //         // noFill();\n// // //         for(let i = 0; i < this.walls.length; i++){\n// // //             this.walls[i].render(i, startRow, startCol);\n// // //         }\n\n// // //         if(this.visited){\n// // //             rect(startRow, startCol, 40, 40)\n// // //             fill(\"green\");\n// // //         }\n\n// // //     }\n\n// // //     this.getNeighbor = function(){\n\n// // //         // const neighborsIndices = [\n// // //         //     [row - 1, col],\n// // //         //     [row + 1, col],\n// // //         //     [row, col - 1],\n// // //         //     [row, col + 1]            \n// // //         // ]\n\n// // //         const neighbors = [\n// // //             grid[row - 1][col],\n// // //             grid[row + 1][col],\n// // //             grid[row][col - 1],\n// // //             grid[row][col + 1]            \n// // //         ]\n\n// // //         // const neighbors = [];\n\n// // //         // const validateIdx = function (idxArr) {\n// // //         //     if(idxArr.every((idx) => {\n// // //         //         return idx < 20 && idx >= 0}\n// // //         //         )){\n\n// // //         //         neighbors.push(idxArr);\n// // //         //     }\n// // //         // }\n\n// // //         // let top = [(row - 1), col];\n// // //         // validateIdx(top);\n// // //         // let right = [row, (col+1)];\n// // //         // validateIdx(right);\n// // //         // let bottom = [(row + 1), col];\n// // //         // validateIdx(bottom);\n// // //         // let left = [row, (col - 1)];\n// // //         // validateIdx(left);\n\n// // //         console.log(neighbors)\n\n// // //         const validNeighbors = [];\n\n// // //         // for(let i = 0; i < neighbors.length; i++){\n// // //         //     if ((neighbors[i][0] < 20 && neighbors[i][0] >= 0) && (neighbors[i][1] < 20 && neighbors[i][1] >= 0)) {\n// // //         //         validNeighbors.push(neighbors[i]);\n// // //         //     }\n// // //         // }\n\n// // //         // const validNeighbors = neighbors.filter(neighbor => {\n// // //         //     // let x = neighbor[0];\n// // //         //     // let y = neighbor[1];\n\n// // //         //     if((neighbor[0] < 20 && neighbor[0] >= 0) && (neighbor[1] < 20 && neighbor[1] >= 0)){\n// // //         //         return neighbor;\n// // //         //     }\n// // //         // }\n\n// // //         // const validateNeighbors = function(neighbor) {\n// // //         //     if(!neighbor){\n// // //         //         return false;\n// // //         //     }\n// // //         //     // let x = neighbor[0];\n// // //         //     // let y = neighbor[1];\n\n// // //         //     if(neighbor.row < 20 || neighbor.row >=0){\n// // //         //         return false;\n// // //         //     } else if(neighbor.col < 20 || neighbor.col >= 0){\n// // //         //         return false;\n// // //         //     } else{\n// // //         //         return true\n// // //         //     }\n\n// // //         // }\n\n// // //         // const validateNeighbors = function(neighbor){\n// // //         //     console.log(neighbor)\n// // //         //     neighbor\n// // //         // }\n\n// // //         // const validNeighbors = neighbors.filter(validateNeighbors);\n\n// // //         for(let i = 0; i < neighbors.length; i++){\n// // //             if(neighbors[i] && !(neighbors[i].visited)){\n// // //                 validNeighbors.push(neighbors[i])\n// // //             }\n// // //         }\n\n\n// // //         console.log(\"valid\") \n// // //         console.log(validNeighbors)\n\n// // //         let nextCell;\n\n// // //         if(validNeighbors.length > 0){\n// // //             nextCell = this.chooseRandomNeighbor(validNeighbors);\n// // //             return nextCell;\n// // //         }\n// // //         // let nextCell = \n\n// // //         // //need to check if nextCell is true bc it could be undefined at the edges\n// // //         // while(nextCell && nextCell.visited){\n// // //             //     nextCell = this.chooseRandomNeighbor(neighbors)\n\n// // //             //     if(nextCell && !nextCell.visited){\n// // //                 //         return nextCell\n// // //                 //     }\n// // //                 // }\n\n// // //                 // if (nextCell) {\n// // //                     //     rect(startRow, startCol, 40, 40)\n// // //                     //     fill(\"purple\");\n// // //                     // }\n// // //                     // console.log(nextCell)\n// // //                     // return nextCell;\n\n// // //     }\n\n// // //     this.chooseRandomNeighbor = function(validNeighbors) {\n// // //        return validNeighbors[Math.floor(Math.random() * validNeighbors.length)] \n// // //     }\n\n// // // }\n\n// // // function Wall(){\n// // //     this.present = true;\n\n// // //     this.render = function(i, x, y){\n// // //         stroke(255);\n// // //         switch(i){\n// // //             case 0: \n// // //                 line(x, y, x, y + 40)\n// // //             case 1:\n// // //                 line(x, y + 40, x + 40, y + 40)\n// // //             case 2: \n// // //                 line(x + 40, y + 40, x + 40, y)\n// // //             case 3:\n// // //                 line(x + 40, y, x, y)\n// // //         }\n// // //     }\n// // // }\n\n// // window.setup = setup;\n\n// // window.draw = draw;\n\n// // //p5 cannot find the functions, \n// // //so we need to set it to the window so the fx can be found //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2luZGV4LmpzPzQxZjUiXSwic291cmNlc0NvbnRlbnQiOlsiXG5jb25zdCBDZWxsID0gcmVxdWlyZSgnLi9jZWxsJyk7XG4vLyBjb25zdCBNb3ZpbmdPYmplY3QgPSByZXF1aXJlKCcuL21vdmluZ19vYmplY3RzJyk7XG4vLyBjb25zdCBVc2VyID0gcmVxdWlyZSgnLi91c2VyJyk7XG5jb25zdCBHYW1lID0gcmVxdWlyZSgnLi9nYW1lJyk7XG5jb25zdCBNYXplID0gcmVxdWlyZSgnLi9tYXplJyk7XG5cbi8vIHdpbmRvdy5Nb3ZpbmdPYmplY3QgPSBNb3ZpbmdPYmplY3Q7XG5cbmNvbnN0IGdyaWQgPSBbXTtcblxubGV0IGN1cnJlbnQ7XG5cbmNvbnN0IHN0YWNrID0gW107XG5cbmxldCBnYW1lO1xud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlwcmVzc1wiLCAoZXZlbnQpID0+IChnYW1lLnVzZXJNb3ZlKGV2ZW50KSkpO1xuXG5cbmxldCBtYXplO1xuXG5sZXQgbWFwQ29tcGxldGUgPSBmYWxzZTtcblxuLy8gY29uc3QgdXNlciA9IG5ldyBVc2VyKCk7XG5sZXQgdGl0bGU7XG5sZXQgY2FudmFzO1xuXG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgICB0aXRsZSA9IGNyZWF0ZUVsZW1lbnQoXCJoMVwiLCBcIkNvbG9yT3V0XCIpO1xuICAgIHRpdGxlLnBvc2l0aW9uKDEwMDAsIDIwKTtcblxuICAgIGNhbnZhcyA9IGNyZWF0ZUNhbnZhcyg4MDAsIDgwMCk7XG4gICAgY2FudmFzLnBvc2l0aW9uKDEwMCwgOTApO1xuXG4gICAgLy8gICBjb2xzID0gMTA7XG4gICAgLy8gICByb3dzID0gMTA7XG5cbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDIwOyB4KyspIHtcbiAgICAgICAgZ3JpZFt4XSA9IFtdO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDIwOyB5KyspIHtcbiAgICAgICAgICAgIGdyaWRbeF0ucHVzaChuZXcgQ2VsbCh4LCB5LCBncmlkLCBzdGFjaykpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgY3VycmVudF9yb3cgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyMCk7XG4gICAgbGV0IGN1cnJlbnRfY29sID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjApO1xuXG4gICAgY3VycmVudCA9IGdyaWRbY3VycmVudF9yb3ddW2N1cnJlbnRfY29sXTtcbiAgICBnYW1lID0gbmV3IEdhbWUoZ3JpZCk7XG4gICAgbWF6ZSA9IG5ldyBNYXplKGN1cnJlbnQsIGdyaWQsIGdhbWUpXG5cbiAgICAvLyAgIGNvbnNvbGUubG9nKFwiY3VycmVudFwiKVxuICAgIC8vICAgY29uc29sZS5sb2coY3VycmVudClcbiAgICAvLyBnYW1lLnJlbmRlclVzZXIodGhpcy51c2VyLmNvbG9yKTtcblxuICAgIGZyYW1lUmF0ZSgxMDApO1xuXG4gXG5cbn1cblxuLy8gY29uc3QgbWF6ZSA9IG5ldyBNYXplKGN1cnJlbnQsIGdyaWQpO1xuXG5mdW5jdGlvbiBkcmF3KCkge1xuICAgIC8vIGlmKCFtYXBDb21wbGV0ZSl7XG4gICAgLy8gZ2FtZS51c2VyUmVuZGVyKCk7XG5cbiAgICBtYXplLmRyYXcoKTtcbiAgICAvLyBtYXBDb21wbGV0ZSA9IG1hemUubWFwQ29tcGxldGUoKTtcbiAgICAvLyB9XG4gICAgLy8gY29uc29sZS5sb2coXCJmaW5pc2ggbWF6ZVwiKVxuICAgIC8vIHBsYXkoZ2FtZSlcblxuICAgIFxuICAgIGdhbWUudXNlck1vdmUoKTtcblxuICAgIGlmKGdhbWUuZW5kKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJjb25ncmF0c1wiKVxuICAgIH1cblxuICAgIC8vIGdhbWUudXNlclJlbmRlcigpO1xuXG4gICAgLy8gZ2FtZS51c2VyUmVuZGVyKDAsIDApO1xuXG4gICAgLy8gY29uc3Qga2V5cHJlc3MgPSBldmVudC5rZXlDb2RlO1xuICAgIC8vIGNvbnNvbGUubG9nKGV2ZW50KTtcblxuXG4gICAgLy8gZ2FtZS51c2VyTW92ZSgpO1xuICAgIC8vIGdhbWUudXNlci5kcmF3KCk7XG5cbiAgICAvLyBsb29wKCk7XG4gICAgLy8gYmFja2dyb3VuZCg1MSlcblxuICAgIC8vIGlmKCFtYXAgJiYgIWdhbWVFbmQpe1xuICAgIC8vICAgICBpZiAoY3VycmVudCkge1xuICAgIC8vICAgICAgICAgY3VycmVudC52aXNpdGVkID0gdHJ1ZTtcbiAgICAvLyAgICAgLy8gY3VycmVudC5oaWdobGlnaHQoKTtcbiAgICAvLyAgICAgICAgIHN0YWNrLnB1c2goY3VycmVudCk7XG4gICAgLy8gICAgIH1cblxuXG4gICAgLy8gICAgIC8vIGxldCBuZXh0Q2VsbCA9IGN1cnJlbnQuZ2V0TmV4dENlbGwoY3VycmVudC5yb3csIGN1cnJlbnQuY29sKTtcbiAgICAvLyAgICAgbGV0IG5leHRDZWxsID0gY3VycmVudC5nZXROZWlnaGJvcigpO1xuXG4gICAgLy8gICAgIC8vIGNvbnNvbGUubG9nKFwibmV4dGNlbGxcIilcbiAgICAvLyAgICAgLy8gY29uc29sZS5sb2cobmV4dENlbGwpO1xuXG4gICAgLy8gICAgIHRoaXMucmVtb3ZlV2FsbHMgPSBmdW5jdGlvbihjdXJyZW50LCBuZXh0LCBncmlkKXtcbiAgICAvLyAgICAgICAgIGNvbnN0IGNoYW5nZVggPSBjdXJyZW50LnJvdyAtIG5leHQucm93O1xuICAgIC8vICAgICAgICAgY29uc3QgY2hhbmdlWSA9IGN1cnJlbnQuY29sIC0gbmV4dC5jb2w7XG5cblxuICAgIC8vICAgICAgICAgc3dpdGNoKGNoYW5nZVgpe1xuICAgIC8vICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAvLyAgICAgICAgICAgICAgICAgY3VycmVudC53YWxsc1swXS5wcmVzZW50ID0gZmFsc2U7ICBcbiAgICAvLyAgICAgICAgICAgICAgICAgbmV4dC53YWxsc1syXS5wcmVzZW50ID0gZmFsc2U7XG4gICAgLy8gICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgIC8vICAgICAgICAgICAgIGNhc2UgLTE6XG4gICAgLy8gICAgICAgICAgICAgICAgIGN1cnJlbnQud2FsbHNbMl0ucHJlc2VudCA9IGZhbHNlO1xuICAgIC8vICAgICAgICAgICAgICAgICBuZXh0LndhbGxzWzBdLnByZXNlbnQgPSBmYWxzZTtcbiAgICAvLyAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgLy8gICAgICAgICB9XG5cbiAgICAvLyAgICAgICAgIHN3aXRjaCAoY2hhbmdlWSkge1xuICAgIC8vICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAvLyAgICAgICAgICAgICAgICAgY3VycmVudC53YWxsc1szXS5wcmVzZW50ID0gZmFsc2U7XG4gICAgLy8gICAgICAgICAgICAgICAgIG5leHQud2FsbHNbMV0ucHJlc2VudCA9IGZhbHNlO1xuICAgIC8vICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAvLyAgICAgICAgICAgICBjYXNlIC0xOlxuICAgIC8vICAgICAgICAgICAgICAgICBjdXJyZW50LndhbGxzWzFdLnByZXNlbnQgPSBmYWxzZTtcbiAgICAvLyAgICAgICAgICAgICAgICAgbmV4dC53YWxsc1szXS5wcmVzZW50ID0gZmFsc2U7XG4gICAgLy8gICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgIC8vICAgICAgICAgfVxuXG4gICAgLy8gICAgICAgICAvLyBjb25zdCBmaXJzdFJvdyA9IGdyaWRbMF07XG4gICAgLy8gICAgICAgICAvLyBjb25zdCBsYXN0Um93ID0gZ3JpZFsxOV07XG5cbiAgICAvLyAgICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgZmlyc3RSb3cubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAgICAgICAgIC8vICAgICBmaXJzdFJvd1tpXS53YWxsc1szXS5wcmVzZW50ID0gdHJ1ZVxuICAgIC8vICAgICAgICAgLy8gfVxuXG4gICAgLy8gICAgICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RSb3cubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAgICAgICAgIC8vICAgICBsYXN0Um93W2ldLndhbGxzWzFdLnByZXNlbnQgPSB0cnVlXG4gICAgLy8gICAgICAgICAvLyB9XG5cbiAgICAvLyAgICAgICAgIC8vIGNvbnN0IGZpcnN0Q29sID0gZ3JpZC5maWx0ZXIoKGNlbGwpID0+IHtcbiAgICAvLyAgICAgICAgIC8vICAgICByZXR1cm4gY2VsbC5jb2wgPT09IDBcbiAgICAvLyAgICAgICAgIC8vIH0pXG5cbiAgICAvLyAgICAgICAgIC8vIGNvbnN0IGxhc3RDb2wgPSBncmlkLmZpbHRlcigoY2VsbCkgPT4ge1xuICAgIC8vICAgICAgICAgLy8gICAgIHJldHVybiBjZWxsLmNvbCA9PT0gMTlcbiAgICAvLyAgICAgICAgIC8vIH0pXG5cbiAgICAvLyAgICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgZmlyc3RDb2wubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAgICAgICAgIC8vICAgICBmaXJzdENvbFtpXS53YWxsc1syXS5wcmVzZW50ID0gdHJ1ZTtcbiAgICAvLyAgICAgICAgIC8vIH1cblxuICAgIC8vICAgICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0Q29sLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gICAgICAgICAvLyAgICAgbGFzdENvbFtpXS53YWxsc1swXS5wcmVzZW50ID0gdHJ1ZTtcbiAgICAvLyAgICAgICAgIC8vIH1cbiAgICAvLyAgICAgfSBcblxuICAgIC8vICAgICBpZihuZXh0Q2VsbCl7XG4gICAgLy8gICAgICAgICBuZXh0Q2VsbC52aXNpdGVkID0gdHJ1ZTtcbiAgICAvLyAgICAgICAgIHRoaXMucmVtb3ZlV2FsbHMoY3VycmVudCwgbmV4dENlbGwsIGdyaWQpO1xuICAgIC8vICAgICAgICAgY3VycmVudCA9IG5leHRDZWxsO1xuICAgIC8vICAgICAgICAgLy8gY29uc29sZS5sb2coXCJzdGFja1wiKVxuICAgIC8vICAgICAgICAgLy8gY29uc29sZS5sb2coc3RhY2spO1xuICAgIC8vICAgICB9IGVsc2UgaWYoc3RhY2subGVuZ3RoID4gMCl7XG4gICAgLy8gICAgICAgICBwb3RlbnRpYWxSZXN0YXJ0ID0gc3RhY2sucG9wKClcbiAgICAvLyAgICAgICAgICAgICB3aGlsZSAocG90ZW50aWFsUmVzdGFydCAmJiAhcG90ZW50aWFsUmVzdGFydC5nZXROZWlnaGJvcigpKXtcbiAgICAvLyAgICAgICAgICAgICAgICAgaWYoIXN0YWNrLmxlbmd0aCl7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxSZXN0YXJ0LnZpc2l0ZWQgPSB0cnVlXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBtYXAgPSB0cnVlO1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgbm9Mb29wKCk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAvLyAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbFJlc3RhcnQgPSBzdGFjay5wb3AoKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICBjdXJyZW50ID0gcG90ZW50aWFsUmVzdGFydDtcbiAgICAvLyAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhjdXJyZW50KVxuICAgIC8vICAgICAvLyB9IGVsc2UgaWYoYWxsVmlzaXRlZCkge1xuICAgIC8vICAgICAvLyAgICAgbm9Mb29wKCk7XG4gICAgLy8gICAgIH1cblxuXG4gICAgLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JpZC5sZW5ndGg7IGkrKykge1xuICAgIC8vICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBncmlkW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgLy8gICAgICAgICAgICAgZ3JpZFtpXVtqXS5yZW5kZXIoKTtcbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgfVxuXG4gICAgLy8gICAgIGdhbWUudXNlclJlbmRlcigpO1xuICAgIC8vIH0gZWxzZSBpZihtYXAgJiYgIWdhbWVFbmQpe1xuICAgIC8vICAgICAvLyBsb29wKClcbiAgICAvLyAgICAgY29uc29sZS5sb2coXCJoaVwiKVxuICAgIC8vICAgICBnYW1lLnVzZXJSZW5kZXIoKTtcbiAgICAvLyAgICAgLy8gZ2FtZS51c2VyTW92ZSgpO1xuICAgIC8vICAgICBrZXlQcmVzc2VkKCk7XG5cbiAgICAvLyAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmlkLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdyaWRbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAvLyAgICAgICAgICAgICBncmlkW2ldW2pdLnJlbmRlcigpO1xuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICB9XG5cbiAgICAvLyB9XG5cbiAgICAvLyAvLyBjdXJyZW50LmhpZ2hsaWdodCgpO1xuXG4gICAgLy8gZnVuY3Rpb24ga2V5UHJlc3NlZCgpe1xuICAgIC8vICAgICAvLyBsb29wKCk7XG4gICAgLy8gICAgIGdhbWUudXNlck1vdmUoKTtcbiAgICAvLyAgICAgLy8gbG9vcCgpICAgICAgICBcbiAgICAvLyAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIH1cblxuICAgIC8vIGtleVByZXNzZWQoKTtcblxuICAgIC8vIC8vIHVzZXIucmVuZGVyKCk7XG5cblxuXG4gICAgLy8gLy8gcmVkcmF3KCk7XG5cbiAgICAvLyAvLyB3aGlsZSAoIWdhbWUuZW5kKCkpe1xuICAgIC8vIC8vICAgICBnYW1lLnVzZXJNb3ZlKClcbiAgICAvLyAvLyB9XG5cbn1cblxuZnVuY3Rpb24gcGxheShnYW1lKXtcbiAgICBnYW1lLnVzZXJSZW5kZXIoKTtcbiAgICAvLyByZWRyYXcoKTtcbn1cblxuLy8gZnVuY3Rpb24gQ2VsbChyb3csIGNvbCkge1xuLy8gICAgIHRoaXMucm93ID0gcm93O1xuLy8gICAgIHRoaXMuY29sID0gY29sO1xuLy8gICAgIHRoaXMud2FsbHMgPSBbbmV3IFdhbGwoKSwgbmV3IFdhbGwoKSwgbmV3IFdhbGwoKSwgbmV3IFdhbGwoKV07XG4vLyAgICAgdGhpcy52aXNpdGVkID0gZmFsc2U7XG5cbi8vICAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgY29uc3Qgc3RhcnRSb3cgPSB0aGlzLnJvdyAqIDQwO1xuLy8gICAgICAgICBjb25zdCBzdGFydENvbCA9IHRoaXMuY29sICogNDA7XG5cbi8vICAgICAgICAgLy8geCwgeSwgd2lkdGgsIGhlaWdodFxuLy8gICAgICAgICAvLyByZWN0KHN0YXJ0WCwgc3RhcnRZLCA0MCwgNDApXG4vLyAgICAgICAgIC8vIG5vRmlsbCgpO1xuLy8gICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy53YWxscy5sZW5ndGg7IGkrKyl7XG4vLyAgICAgICAgICAgICB0aGlzLndhbGxzW2ldLnJlbmRlcihpLCBzdGFydFJvdywgc3RhcnRDb2wpO1xuLy8gICAgICAgICB9XG5cbi8vICAgICAgICAgaWYodGhpcy52aXNpdGVkKXtcbi8vICAgICAgICAgICAgIHJlY3Qoc3RhcnRSb3csIHN0YXJ0Q29sLCA0MCwgNDApXG4vLyAgICAgICAgICAgICBmaWxsKFwiZ3JlZW5cIik7XG4vLyAgICAgICAgIH1cblxuLy8gICAgIH1cblxuLy8gICAgIHRoaXMuZ2V0TmVpZ2hib3IgPSBmdW5jdGlvbigpe1xuXG4vLyAgICAgICAgIC8vIGNvbnN0IG5laWdoYm9yc0luZGljZXMgPSBbXG4vLyAgICAgICAgIC8vICAgICBbcm93IC0gMSwgY29sXSxcbi8vICAgICAgICAgLy8gICAgIFtyb3cgKyAxLCBjb2xdLFxuLy8gICAgICAgICAvLyAgICAgW3JvdywgY29sIC0gMV0sXG4vLyAgICAgICAgIC8vICAgICBbcm93LCBjb2wgKyAxXSAgICAgICAgICAgIFxuLy8gICAgICAgICAvLyBdXG5cbi8vICAgICAgICAgY29uc3QgbmVpZ2hib3JzID0gW1xuLy8gICAgICAgICAgICAgZ3JpZFtyb3cgLSAxXVtjb2xdLFxuLy8gICAgICAgICAgICAgZ3JpZFtyb3cgKyAxXVtjb2xdLFxuLy8gICAgICAgICAgICAgZ3JpZFtyb3ddW2NvbCAtIDFdLFxuLy8gICAgICAgICAgICAgZ3JpZFtyb3ddW2NvbCArIDFdICAgICAgICAgICAgXG4vLyAgICAgICAgIF1cblxuLy8gICAgICAgICAvLyBjb25zdCBuZWlnaGJvcnMgPSBbXTtcblxuLy8gICAgICAgICAvLyBjb25zdCB2YWxpZGF0ZUlkeCA9IGZ1bmN0aW9uIChpZHhBcnIpIHtcbi8vICAgICAgICAgLy8gICAgIGlmKGlkeEFyci5ldmVyeSgoaWR4KSA9PiB7XG4vLyAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIGlkeCA8IDIwICYmIGlkeCA+PSAwfVxuLy8gICAgICAgICAvLyAgICAgICAgICkpe1xuXG4vLyAgICAgICAgIC8vICAgICAgICAgbmVpZ2hib3JzLnB1c2goaWR4QXJyKTtcbi8vICAgICAgICAgLy8gICAgIH1cbi8vICAgICAgICAgLy8gfVxuXG4vLyAgICAgICAgIC8vIGxldCB0b3AgPSBbKHJvdyAtIDEpLCBjb2xdO1xuLy8gICAgICAgICAvLyB2YWxpZGF0ZUlkeCh0b3ApO1xuLy8gICAgICAgICAvLyBsZXQgcmlnaHQgPSBbcm93LCAoY29sKzEpXTtcbi8vICAgICAgICAgLy8gdmFsaWRhdGVJZHgocmlnaHQpO1xuLy8gICAgICAgICAvLyBsZXQgYm90dG9tID0gWyhyb3cgKyAxKSwgY29sXTtcbi8vICAgICAgICAgLy8gdmFsaWRhdGVJZHgoYm90dG9tKTtcbi8vICAgICAgICAgLy8gbGV0IGxlZnQgPSBbcm93LCAoY29sIC0gMSldO1xuLy8gICAgICAgICAvLyB2YWxpZGF0ZUlkeChsZWZ0KTtcblxuLy8gICAgICAgICBjb25zb2xlLmxvZyhuZWlnaGJvcnMpXG5cbi8vICAgICAgICAgY29uc3QgdmFsaWROZWlnaGJvcnMgPSBbXTtcblxuLy8gICAgICAgICAvLyBmb3IobGV0IGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSsrKXtcbi8vICAgICAgICAgLy8gICAgIGlmICgobmVpZ2hib3JzW2ldWzBdIDwgMjAgJiYgbmVpZ2hib3JzW2ldWzBdID49IDApICYmIChuZWlnaGJvcnNbaV1bMV0gPCAyMCAmJiBuZWlnaGJvcnNbaV1bMV0gPj0gMCkpIHtcbi8vICAgICAgICAgLy8gICAgICAgICB2YWxpZE5laWdoYm9ycy5wdXNoKG5laWdoYm9yc1tpXSk7XG4vLyAgICAgICAgIC8vICAgICB9XG4vLyAgICAgICAgIC8vIH1cblxuLy8gICAgICAgICAvLyBjb25zdCB2YWxpZE5laWdoYm9ycyA9IG5laWdoYm9ycy5maWx0ZXIobmVpZ2hib3IgPT4ge1xuLy8gICAgICAgICAvLyAgICAgLy8gbGV0IHggPSBuZWlnaGJvclswXTtcbi8vICAgICAgICAgLy8gICAgIC8vIGxldCB5ID0gbmVpZ2hib3JbMV07XG5cbi8vICAgICAgICAgLy8gICAgIGlmKChuZWlnaGJvclswXSA8IDIwICYmIG5laWdoYm9yWzBdID49IDApICYmIChuZWlnaGJvclsxXSA8IDIwICYmIG5laWdoYm9yWzFdID49IDApKXtcbi8vICAgICAgICAgLy8gICAgICAgICByZXR1cm4gbmVpZ2hib3I7XG4vLyAgICAgICAgIC8vICAgICB9XG4vLyAgICAgICAgIC8vIH1cblxuLy8gICAgICAgICAvLyBjb25zdCB2YWxpZGF0ZU5laWdoYm9ycyA9IGZ1bmN0aW9uKG5laWdoYm9yKSB7XG4vLyAgICAgICAgIC8vICAgICBpZighbmVpZ2hib3Ipe1xuLy8gICAgICAgICAvLyAgICAgICAgIHJldHVybiBmYWxzZTtcbi8vICAgICAgICAgLy8gICAgIH1cbi8vICAgICAgICAgLy8gICAgIC8vIGxldCB4ID0gbmVpZ2hib3JbMF07XG4vLyAgICAgICAgIC8vICAgICAvLyBsZXQgeSA9IG5laWdoYm9yWzFdO1xuXG4vLyAgICAgICAgIC8vICAgICBpZihuZWlnaGJvci5yb3cgPCAyMCB8fCBuZWlnaGJvci5yb3cgPj0wKXtcbi8vICAgICAgICAgLy8gICAgICAgICByZXR1cm4gZmFsc2U7XG4vLyAgICAgICAgIC8vICAgICB9IGVsc2UgaWYobmVpZ2hib3IuY29sIDwgMjAgfHwgbmVpZ2hib3IuY29sID49IDApe1xuLy8gICAgICAgICAvLyAgICAgICAgIHJldHVybiBmYWxzZTtcbi8vICAgICAgICAgLy8gICAgIH0gZWxzZXtcbi8vICAgICAgICAgLy8gICAgICAgICByZXR1cm4gdHJ1ZVxuLy8gICAgICAgICAvLyAgICAgfVxuXG4vLyAgICAgICAgIC8vIH1cblxuLy8gICAgICAgICAvLyBjb25zdCB2YWxpZGF0ZU5laWdoYm9ycyA9IGZ1bmN0aW9uKG5laWdoYm9yKXtcbi8vICAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKG5laWdoYm9yKVxuLy8gICAgICAgICAvLyAgICAgbmVpZ2hib3Jcbi8vICAgICAgICAgLy8gfVxuXG4vLyAgICAgICAgIC8vIGNvbnN0IHZhbGlkTmVpZ2hib3JzID0gbmVpZ2hib3JzLmZpbHRlcih2YWxpZGF0ZU5laWdoYm9ycyk7XG5cbi8vICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7IGkrKyl7XG4vLyAgICAgICAgICAgICBpZihuZWlnaGJvcnNbaV0gJiYgIShuZWlnaGJvcnNbaV0udmlzaXRlZCkpe1xuLy8gICAgICAgICAgICAgICAgIHZhbGlkTmVpZ2hib3JzLnB1c2gobmVpZ2hib3JzW2ldKVxuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICB9XG5cblxuLy8gICAgICAgICBjb25zb2xlLmxvZyhcInZhbGlkXCIpIFxuLy8gICAgICAgICBjb25zb2xlLmxvZyh2YWxpZE5laWdoYm9ycylcblxuLy8gICAgICAgICBsZXQgbmV4dENlbGw7XG5cbi8vICAgICAgICAgaWYodmFsaWROZWlnaGJvcnMubGVuZ3RoID4gMCl7XG4vLyAgICAgICAgICAgICBuZXh0Q2VsbCA9IHRoaXMuY2hvb3NlUmFuZG9tTmVpZ2hib3IodmFsaWROZWlnaGJvcnMpO1xuLy8gICAgICAgICAgICAgcmV0dXJuIG5leHRDZWxsO1xuLy8gICAgICAgICB9XG4vLyAgICAgICAgIC8vIGxldCBuZXh0Q2VsbCA9IFxuXG4vLyAgICAgICAgIC8vIC8vbmVlZCB0byBjaGVjayBpZiBuZXh0Q2VsbCBpcyB0cnVlIGJjIGl0IGNvdWxkIGJlIHVuZGVmaW5lZCBhdCB0aGUgZWRnZXNcbi8vICAgICAgICAgLy8gd2hpbGUobmV4dENlbGwgJiYgbmV4dENlbGwudmlzaXRlZCl7XG4vLyAgICAgICAgICAgICAvLyAgICAgbmV4dENlbGwgPSB0aGlzLmNob29zZVJhbmRvbU5laWdoYm9yKG5laWdoYm9ycylcblxuLy8gICAgICAgICAgICAgLy8gICAgIGlmKG5leHRDZWxsICYmICFuZXh0Q2VsbC52aXNpdGVkKXtcbi8vICAgICAgICAgICAgICAgICAvLyAgICAgICAgIHJldHVybiBuZXh0Q2VsbFxuLy8gICAgICAgICAgICAgICAgIC8vICAgICB9XG4vLyAgICAgICAgICAgICAgICAgLy8gfVxuXG4vLyAgICAgICAgICAgICAgICAgLy8gaWYgKG5leHRDZWxsKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIC8vICAgICByZWN0KHN0YXJ0Um93LCBzdGFydENvbCwgNDAsIDQwKVxuLy8gICAgICAgICAgICAgICAgICAgICAvLyAgICAgZmlsbChcInB1cnBsZVwiKTtcbi8vICAgICAgICAgICAgICAgICAgICAgLy8gfVxuLy8gICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhuZXh0Q2VsbClcbi8vICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIG5leHRDZWxsO1xuXG4vLyAgICAgfVxuXG4vLyAgICAgdGhpcy5jaG9vc2VSYW5kb21OZWlnaGJvciA9IGZ1bmN0aW9uKHZhbGlkTmVpZ2hib3JzKSB7XG4vLyAgICAgICAgcmV0dXJuIHZhbGlkTmVpZ2hib3JzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHZhbGlkTmVpZ2hib3JzLmxlbmd0aCldIFxuLy8gICAgIH1cblxuLy8gfVxuXG4vLyBmdW5jdGlvbiBXYWxsKCl7XG4vLyAgICAgdGhpcy5wcmVzZW50ID0gdHJ1ZTtcblxuLy8gICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24oaSwgeCwgeSl7XG4vLyAgICAgICAgIHN0cm9rZSgyNTUpO1xuLy8gICAgICAgICBzd2l0Y2goaSl7XG4vLyAgICAgICAgICAgICBjYXNlIDA6IFxuLy8gICAgICAgICAgICAgICAgIGxpbmUoeCwgeSwgeCwgeSArIDQwKVxuLy8gICAgICAgICAgICAgY2FzZSAxOlxuLy8gICAgICAgICAgICAgICAgIGxpbmUoeCwgeSArIDQwLCB4ICsgNDAsIHkgKyA0MClcbi8vICAgICAgICAgICAgIGNhc2UgMjogXG4vLyAgICAgICAgICAgICAgICAgbGluZSh4ICsgNDAsIHkgKyA0MCwgeCArIDQwLCB5KVxuLy8gICAgICAgICAgICAgY2FzZSAzOlxuLy8gICAgICAgICAgICAgICAgIGxpbmUoeCArIDQwLCB5LCB4LCB5KVxuLy8gICAgICAgICB9XG4vLyAgICAgfVxuLy8gfVxuXG53aW5kb3cuc2V0dXAgPSBzZXR1cDtcblxud2luZG93LmRyYXcgPSBkcmF3O1xuXG4vL3A1IGNhbm5vdCBmaW5kIHRoZSBmdW5jdGlvbnMsIFxuLy9zbyB3ZSBuZWVkIHRvIHNldCBpdCB0byB0aGUgd2luZG93IHNvIHRoZSBmeCBjYW4gYmUgZm91bmQgXG5cbi8vIGNvbnN0IENlbGwgPSByZXF1aXJlKCcuL2NlbGwnKTtcbi8vIC8vIGNvbnN0IE1vdmluZ09iamVjdCA9IHJlcXVpcmUoJy4vbW92aW5nX29iamVjdHMnKTtcbi8vIC8vIGNvbnN0IFVzZXIgPSByZXF1aXJlKCcuL3VzZXInKTtcbi8vIGNvbnN0IEdhbWUgPSByZXF1aXJlKCcuL2dhbWUnKTtcblxuLy8gLy8gd2luZG93Lk1vdmluZ09iamVjdCA9IE1vdmluZ09iamVjdDtcblxuLy8gY29uc3QgZ3JpZCA9IFtdO1xuXG4vLyBsZXQgY3VycmVudDtcblxuLy8gY29uc3Qgc3RhY2sgPSBbXTtcblxuLy8gbGV0IGdhbWUgPSBuZXcgR2FtZSgpO1xuXG4vLyBsZXQgbWFwID0gZmFsc2U7XG5cbi8vIGxldCBnYW1lRW5kID0gZmFsc2U7XG5cbi8vIC8vIGNvbnN0IHVzZXIgPSBuZXcgVXNlcigpO1xuXG4vLyBmdW5jdGlvbiBzZXR1cCgpIHtcbi8vICAgY3JlYXRlQ2FudmFzKDgwMCwgODAwKTtcbi8vIC8vICAgY29scyA9IDEwO1xuLy8gLy8gICByb3dzID0gMTA7XG5cbi8vICAgZm9yKGxldCB4ID0gMDsgeCA8IDIwOyB4Kyspe1xuLy8gICAgICAgZ3JpZFt4XSA9IFtdO1xuLy8gICAgICAgZm9yKGxldCB5ID0gMDsgeSA8IDIwOyB5Kyspe1xuLy8gICAgICAgICBncmlkW3hdLnB1c2gobmV3IENlbGwoeCwgeSwgZ3JpZCwgc3RhY2spKVxuLy8gICAgICAgfVxuLy8gICB9XG5cbi8vICAgbGV0IGN1cnJlbnRfcm93ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjApO1xuLy8gICBsZXQgY3VycmVudF9jb2wgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyMCk7XG5cbi8vICAgY3VycmVudCA9IGdyaWRbY3VycmVudF9yb3ddW2N1cnJlbnRfY29sXTtcblxuLy8gICAvLyAgIGNvbnNvbGUubG9nKFwiY3VycmVudFwiKVxuLy8gLy8gICBjb25zb2xlLmxvZyhjdXJyZW50KVxuXG4vLyAgIGZyYW1lUmF0ZSgxMDApO1xuXG4vLyB9XG5cbi8vIGZ1bmN0aW9uIGRyYXcoKSB7XG4vLyAgICAgYmFja2dyb3VuZCg1MSlcblxuLy8gICAgIGlmKCFtYXAgJiYgIWdhbWVFbmQpe1xuLy8gICAgICAgICBpZiAoY3VycmVudCkge1xuLy8gICAgICAgICAgICAgY3VycmVudC52aXNpdGVkID0gdHJ1ZTtcbi8vICAgICAgICAgLy8gY3VycmVudC5oaWdobGlnaHQoKTtcbi8vICAgICAgICAgICAgIHN0YWNrLnB1c2goY3VycmVudCk7XG4vLyAgICAgICAgIH1cblxuXG4vLyAgICAgICAgIC8vIGxldCBuZXh0Q2VsbCA9IGN1cnJlbnQuZ2V0TmV4dENlbGwoY3VycmVudC5yb3csIGN1cnJlbnQuY29sKTtcbi8vICAgICAgICAgbGV0IG5leHRDZWxsID0gY3VycmVudC5nZXROZWlnaGJvcigpO1xuXG4vLyAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwibmV4dGNlbGxcIilcbi8vICAgICAgICAgLy8gY29uc29sZS5sb2cobmV4dENlbGwpO1xuXG4vLyAgICAgICAgIHRoaXMucmVtb3ZlV2FsbHMgPSBmdW5jdGlvbihjdXJyZW50LCBuZXh0LCBncmlkKXtcbi8vICAgICAgICAgICAgIGNvbnN0IGNoYW5nZVggPSBjdXJyZW50LnJvdyAtIG5leHQucm93O1xuLy8gICAgICAgICAgICAgY29uc3QgY2hhbmdlWSA9IGN1cnJlbnQuY29sIC0gbmV4dC5jb2w7XG5cbi8vICAgICAgICAgICAgIC8vIGN1cnJlbnQud2FsbHMuZm9yRWFjaCh3YWxsID0+IHdhbGwucHJlc2VudCA9IGZhbHNlKVxuXG5cbi8vICAgICAgICAgICAgIHN3aXRjaChjaGFuZ2VYKXtcbi8vICAgICAgICAgICAgICAgICBjYXNlIDE6XG4vLyAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQud2FsbHNbMF0ucHJlc2VudCA9IGZhbHNlOyAgXG4vLyAgICAgICAgICAgICAgICAgICAgIG5leHQud2FsbHNbMl0ucHJlc2VudCA9IGZhbHNlO1xuLy8gICAgICAgICAgICAgICAgICAgICBicmVhaztcbi8vICAgICAgICAgICAgICAgICBjYXNlIC0xOlxuLy8gICAgICAgICAgICAgICAgICAgICBjdXJyZW50LndhbGxzWzJdLnByZXNlbnQgPSBmYWxzZTtcbi8vICAgICAgICAgICAgICAgICAgICAgbmV4dC53YWxsc1swXS5wcmVzZW50ID0gZmFsc2U7XG4vLyAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuLy8gICAgICAgICAgICAgfVxuXG4vLyAgICAgICAgICAgICBzd2l0Y2ggKGNoYW5nZVkpIHtcbi8vICAgICAgICAgICAgICAgICBjYXNlIDE6XG4vLyAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQud2FsbHNbM10ucHJlc2VudCA9IGZhbHNlO1xuLy8gICAgICAgICAgICAgICAgICAgICBuZXh0LndhbGxzWzFdLnByZXNlbnQgPSBmYWxzZTtcbi8vICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4vLyAgICAgICAgICAgICAgICAgY2FzZSAtMTpcbi8vICAgICAgICAgICAgICAgICAgICAgY3VycmVudC53YWxsc1sxXS5wcmVzZW50ID0gZmFsc2U7XG4vLyAgICAgICAgICAgICAgICAgICAgIG5leHQud2FsbHNbM10ucHJlc2VudCA9IGZhbHNlO1xuLy8gICAgICAgICAgICAgICAgICAgICBicmVhaztcbi8vICAgICAgICAgICAgIH1cblxuLy8gICAgICAgICAgICAgLy8gY29uc3QgZmlyc3RSb3cgPSBncmlkWzBdO1xuLy8gICAgICAgICAgICAgLy8gY29uc3QgbGFzdFJvdyA9IGdyaWRbMTldO1xuXG4vLyAgICAgICAgICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IGZpcnN0Um93Lmxlbmd0aDsgaSsrKSB7XG4vLyAgICAgICAgICAgICAvLyAgICAgZmlyc3RSb3dbaV0ud2FsbHNbM10ucHJlc2VudCA9IHRydWVcbi8vICAgICAgICAgICAgIC8vIH1cblxuLy8gICAgICAgICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0Um93Lmxlbmd0aDsgaSsrKSB7XG4vLyAgICAgICAgICAgICAvLyAgICAgbGFzdFJvd1tpXS53YWxsc1sxXS5wcmVzZW50ID0gdHJ1ZVxuLy8gICAgICAgICAgICAgLy8gfVxuXG4vLyAgICAgICAgICAgICAvLyBjb25zdCBmaXJzdENvbCA9IGdyaWQuZmlsdGVyKChjZWxsKSA9PiB7XG4vLyAgICAgICAgICAgICAvLyAgICAgcmV0dXJuIGNlbGwuY29sID09PSAwXG4vLyAgICAgICAgICAgICAvLyB9KVxuXG4vLyAgICAgICAgICAgICAvLyBjb25zdCBsYXN0Q29sID0gZ3JpZC5maWx0ZXIoKGNlbGwpID0+IHtcbi8vICAgICAgICAgICAgIC8vICAgICByZXR1cm4gY2VsbC5jb2wgPT09IDE5XG4vLyAgICAgICAgICAgICAvLyB9KVxuXG4vLyAgICAgICAgICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IGZpcnN0Q29sLmxlbmd0aDsgaSsrKSB7XG4vLyAgICAgICAgICAgICAvLyAgICAgZmlyc3RDb2xbaV0ud2FsbHNbMl0ucHJlc2VudCA9IHRydWU7XG4vLyAgICAgICAgICAgICAvLyB9XG5cbi8vICAgICAgICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgbGFzdENvbC5sZW5ndGg7IGkrKykge1xuLy8gICAgICAgICAgICAgLy8gICAgIGxhc3RDb2xbaV0ud2FsbHNbMF0ucHJlc2VudCA9IHRydWU7XG4vLyAgICAgICAgICAgICAvLyB9XG4vLyAgICAgICAgIH0gXG5cbi8vICAgICAgICAgaWYobmV4dENlbGwpe1xuLy8gICAgICAgICAgICAgbmV4dENlbGwudmlzaXRlZCA9IHRydWU7XG4vLyAgICAgICAgICAgICB0aGlzLnJlbW92ZVdhbGxzKGN1cnJlbnQsIG5leHRDZWxsLCBncmlkKTtcbi8vICAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0Q2VsbDtcbi8vICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwic3RhY2tcIilcbi8vICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHN0YWNrKTtcbi8vICAgICAgICAgfSBlbHNlIGlmKHN0YWNrLmxlbmd0aCA+IDApe1xuLy8gICAgICAgICAgICAgcG90ZW50aWFsUmVzdGFydCA9IHN0YWNrLnBvcCgpXG4vLyAgICAgICAgICAgICAgICAgd2hpbGUgKHBvdGVudGlhbFJlc3RhcnQgJiYgIXBvdGVudGlhbFJlc3RhcnQuZ2V0TmVpZ2hib3IoKSl7XG4vLyAgICAgICAgICAgICAgICAgICAgIGlmKCFzdGFjay5sZW5ndGgpe1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsUmVzdGFydC52aXNpdGVkID0gdHJ1ZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgbWFwID0gdHJ1ZTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG5vTG9vcCgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4vLyAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxSZXN0YXJ0ID0gc3RhY2sucG9wKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgY3VycmVudCA9IHBvdGVudGlhbFJlc3RhcnQ7XG4vLyAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coY3VycmVudClcbi8vICAgICAgICAgLy8gfSBlbHNlIGlmKGFsbFZpc2l0ZWQpIHtcbi8vICAgICAgICAgLy8gICAgIG5vTG9vcCgpO1xuLy8gICAgICAgICB9XG5cblxuLy8gICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyaWQubGVuZ3RoOyBpKyspIHtcbi8vICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZ3JpZFtpXS5sZW5ndGg7IGorKykge1xuLy8gICAgICAgICAgICAgICAgIGdyaWRbaV1bal0ucmVuZGVyKCk7XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH1cblxuLy8gICAgICAgICBnYW1lLnVzZXJSZW5kZXIoKTtcbi8vICAgICB9IGVsc2UgaWYobWFwICYmICFnYW1lRW5kKXtcbi8vICAgICAgICAgLy8gbG9vcCgpXG4vLyAgICAgICAgIGNvbnNvbGUubG9nKFwiaGlcIilcbi8vICAgICAgICAgZ2FtZS51c2VyUmVuZGVyKCk7XG4vLyAgICAgICAgIC8vIGdhbWUudXNlck1vdmUoKTtcbi8vICAgICAgICAga2V5UHJlc3NlZCgpO1xuXG4vLyAgICAgfVxuXG4vLyAgICAgLy8gY3VycmVudC5oaWdobGlnaHQoKTtcblxuLy8gICAgIGZ1bmN0aW9uIGtleVByZXNzZWQoKXtcbi8vICAgICAgICAgLy8gbG9vcCgpO1xuLy8gICAgICAgICBnYW1lLnVzZXJNb3ZlKCk7XG4vLyAgICAgICAgIC8vIGxvb3AoKSAgICAgICAgXG4vLyAgICAgICAgIHJldHVybiBmYWxzZTtcbi8vICAgICB9XG5cbi8vICAgICBrZXlQcmVzc2VkKCk7XG5cbi8vICAgICAvLyB1c2VyLnJlbmRlcigpO1xuXG5cblxuLy8gICAgIC8vIHJlZHJhdygpO1xuXG4vLyAgICAgLy8gd2hpbGUgKCFnYW1lLmVuZCgpKXtcbi8vICAgICAvLyAgICAgZ2FtZS51c2VyTW92ZSgpXG4vLyAgICAgLy8gfVxuXG4vLyB9XG5cbi8vIC8vIGZ1bmN0aW9uIENlbGwocm93LCBjb2wpIHtcbi8vIC8vICAgICB0aGlzLnJvdyA9IHJvdztcbi8vIC8vICAgICB0aGlzLmNvbCA9IGNvbDtcbi8vIC8vICAgICB0aGlzLndhbGxzID0gW25ldyBXYWxsKCksIG5ldyBXYWxsKCksIG5ldyBXYWxsKCksIG5ldyBXYWxsKCldO1xuLy8gLy8gICAgIHRoaXMudmlzaXRlZCA9IGZhbHNlO1xuXG4vLyAvLyAgICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4vLyAvLyAgICAgICAgIGNvbnN0IHN0YXJ0Um93ID0gdGhpcy5yb3cgKiA0MDtcbi8vIC8vICAgICAgICAgY29uc3Qgc3RhcnRDb2wgPSB0aGlzLmNvbCAqIDQwO1xuXG4vLyAvLyAgICAgICAgIC8vIHgsIHksIHdpZHRoLCBoZWlnaHRcbi8vIC8vICAgICAgICAgLy8gcmVjdChzdGFydFgsIHN0YXJ0WSwgNDAsIDQwKVxuLy8gLy8gICAgICAgICAvLyBub0ZpbGwoKTtcbi8vIC8vICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMud2FsbHMubGVuZ3RoOyBpKyspe1xuLy8gLy8gICAgICAgICAgICAgdGhpcy53YWxsc1tpXS5yZW5kZXIoaSwgc3RhcnRSb3csIHN0YXJ0Q29sKTtcbi8vIC8vICAgICAgICAgfVxuXG4vLyAvLyAgICAgICAgIGlmKHRoaXMudmlzaXRlZCl7XG4vLyAvLyAgICAgICAgICAgICByZWN0KHN0YXJ0Um93LCBzdGFydENvbCwgNDAsIDQwKVxuLy8gLy8gICAgICAgICAgICAgZmlsbChcImdyZWVuXCIpO1xuLy8gLy8gICAgICAgICB9XG5cbi8vIC8vICAgICB9XG5cbi8vIC8vICAgICB0aGlzLmdldE5laWdoYm9yID0gZnVuY3Rpb24oKXtcblxuLy8gLy8gICAgICAgICAvLyBjb25zdCBuZWlnaGJvcnNJbmRpY2VzID0gW1xuLy8gLy8gICAgICAgICAvLyAgICAgW3JvdyAtIDEsIGNvbF0sXG4vLyAvLyAgICAgICAgIC8vICAgICBbcm93ICsgMSwgY29sXSxcbi8vIC8vICAgICAgICAgLy8gICAgIFtyb3csIGNvbCAtIDFdLFxuLy8gLy8gICAgICAgICAvLyAgICAgW3JvdywgY29sICsgMV0gICAgICAgICAgICBcbi8vIC8vICAgICAgICAgLy8gXVxuXG4vLyAvLyAgICAgICAgIGNvbnN0IG5laWdoYm9ycyA9IFtcbi8vIC8vICAgICAgICAgICAgIGdyaWRbcm93IC0gMV1bY29sXSxcbi8vIC8vICAgICAgICAgICAgIGdyaWRbcm93ICsgMV1bY29sXSxcbi8vIC8vICAgICAgICAgICAgIGdyaWRbcm93XVtjb2wgLSAxXSxcbi8vIC8vICAgICAgICAgICAgIGdyaWRbcm93XVtjb2wgKyAxXSAgICAgICAgICAgIFxuLy8gLy8gICAgICAgICBdXG5cbi8vIC8vICAgICAgICAgLy8gY29uc3QgbmVpZ2hib3JzID0gW107XG5cbi8vIC8vICAgICAgICAgLy8gY29uc3QgdmFsaWRhdGVJZHggPSBmdW5jdGlvbiAoaWR4QXJyKSB7XG4vLyAvLyAgICAgICAgIC8vICAgICBpZihpZHhBcnIuZXZlcnkoKGlkeCkgPT4ge1xuLy8gLy8gICAgICAgICAvLyAgICAgICAgIHJldHVybiBpZHggPCAyMCAmJiBpZHggPj0gMH1cbi8vIC8vICAgICAgICAgLy8gICAgICAgICApKXtcblxuLy8gLy8gICAgICAgICAvLyAgICAgICAgIG5laWdoYm9ycy5wdXNoKGlkeEFycik7XG4vLyAvLyAgICAgICAgIC8vICAgICB9XG4vLyAvLyAgICAgICAgIC8vIH1cblxuLy8gLy8gICAgICAgICAvLyBsZXQgdG9wID0gWyhyb3cgLSAxKSwgY29sXTtcbi8vIC8vICAgICAgICAgLy8gdmFsaWRhdGVJZHgodG9wKTtcbi8vIC8vICAgICAgICAgLy8gbGV0IHJpZ2h0ID0gW3JvdywgKGNvbCsxKV07XG4vLyAvLyAgICAgICAgIC8vIHZhbGlkYXRlSWR4KHJpZ2h0KTtcbi8vIC8vICAgICAgICAgLy8gbGV0IGJvdHRvbSA9IFsocm93ICsgMSksIGNvbF07XG4vLyAvLyAgICAgICAgIC8vIHZhbGlkYXRlSWR4KGJvdHRvbSk7XG4vLyAvLyAgICAgICAgIC8vIGxldCBsZWZ0ID0gW3JvdywgKGNvbCAtIDEpXTtcbi8vIC8vICAgICAgICAgLy8gdmFsaWRhdGVJZHgobGVmdCk7XG5cbi8vIC8vICAgICAgICAgY29uc29sZS5sb2cobmVpZ2hib3JzKVxuXG4vLyAvLyAgICAgICAgIGNvbnN0IHZhbGlkTmVpZ2hib3JzID0gW107XG5cbi8vIC8vICAgICAgICAgLy8gZm9yKGxldCBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7IGkrKyl7XG4vLyAvLyAgICAgICAgIC8vICAgICBpZiAoKG5laWdoYm9yc1tpXVswXSA8IDIwICYmIG5laWdoYm9yc1tpXVswXSA+PSAwKSAmJiAobmVpZ2hib3JzW2ldWzFdIDwgMjAgJiYgbmVpZ2hib3JzW2ldWzFdID49IDApKSB7XG4vLyAvLyAgICAgICAgIC8vICAgICAgICAgdmFsaWROZWlnaGJvcnMucHVzaChuZWlnaGJvcnNbaV0pO1xuLy8gLy8gICAgICAgICAvLyAgICAgfVxuLy8gLy8gICAgICAgICAvLyB9XG5cbi8vIC8vICAgICAgICAgLy8gY29uc3QgdmFsaWROZWlnaGJvcnMgPSBuZWlnaGJvcnMuZmlsdGVyKG5laWdoYm9yID0+IHtcbi8vIC8vICAgICAgICAgLy8gICAgIC8vIGxldCB4ID0gbmVpZ2hib3JbMF07XG4vLyAvLyAgICAgICAgIC8vICAgICAvLyBsZXQgeSA9IG5laWdoYm9yWzFdO1xuXG4vLyAvLyAgICAgICAgIC8vICAgICBpZigobmVpZ2hib3JbMF0gPCAyMCAmJiBuZWlnaGJvclswXSA+PSAwKSAmJiAobmVpZ2hib3JbMV0gPCAyMCAmJiBuZWlnaGJvclsxXSA+PSAwKSl7XG4vLyAvLyAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIG5laWdoYm9yO1xuLy8gLy8gICAgICAgICAvLyAgICAgfVxuLy8gLy8gICAgICAgICAvLyB9XG5cbi8vIC8vICAgICAgICAgLy8gY29uc3QgdmFsaWRhdGVOZWlnaGJvcnMgPSBmdW5jdGlvbihuZWlnaGJvcikge1xuLy8gLy8gICAgICAgICAvLyAgICAgaWYoIW5laWdoYm9yKXtcbi8vIC8vICAgICAgICAgLy8gICAgICAgICByZXR1cm4gZmFsc2U7XG4vLyAvLyAgICAgICAgIC8vICAgICB9XG4vLyAvLyAgICAgICAgIC8vICAgICAvLyBsZXQgeCA9IG5laWdoYm9yWzBdO1xuLy8gLy8gICAgICAgICAvLyAgICAgLy8gbGV0IHkgPSBuZWlnaGJvclsxXTtcblxuLy8gLy8gICAgICAgICAvLyAgICAgaWYobmVpZ2hib3Iucm93IDwgMjAgfHwgbmVpZ2hib3Iucm93ID49MCl7XG4vLyAvLyAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIGZhbHNlO1xuLy8gLy8gICAgICAgICAvLyAgICAgfSBlbHNlIGlmKG5laWdoYm9yLmNvbCA8IDIwIHx8IG5laWdoYm9yLmNvbCA+PSAwKXtcbi8vIC8vICAgICAgICAgLy8gICAgICAgICByZXR1cm4gZmFsc2U7XG4vLyAvLyAgICAgICAgIC8vICAgICB9IGVsc2V7XG4vLyAvLyAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIHRydWVcbi8vIC8vICAgICAgICAgLy8gICAgIH1cblxuLy8gLy8gICAgICAgICAvLyB9XG5cbi8vIC8vICAgICAgICAgLy8gY29uc3QgdmFsaWRhdGVOZWlnaGJvcnMgPSBmdW5jdGlvbihuZWlnaGJvcil7XG4vLyAvLyAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhuZWlnaGJvcilcbi8vIC8vICAgICAgICAgLy8gICAgIG5laWdoYm9yXG4vLyAvLyAgICAgICAgIC8vIH1cblxuLy8gLy8gICAgICAgICAvLyBjb25zdCB2YWxpZE5laWdoYm9ycyA9IG5laWdoYm9ycy5maWx0ZXIodmFsaWRhdGVOZWlnaGJvcnMpO1xuXG4vLyAvLyAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKyspe1xuLy8gLy8gICAgICAgICAgICAgaWYobmVpZ2hib3JzW2ldICYmICEobmVpZ2hib3JzW2ldLnZpc2l0ZWQpKXtcbi8vIC8vICAgICAgICAgICAgICAgICB2YWxpZE5laWdoYm9ycy5wdXNoKG5laWdoYm9yc1tpXSlcbi8vIC8vICAgICAgICAgICAgIH1cbi8vIC8vICAgICAgICAgfVxuXG5cbi8vIC8vICAgICAgICAgY29uc29sZS5sb2coXCJ2YWxpZFwiKSBcbi8vIC8vICAgICAgICAgY29uc29sZS5sb2codmFsaWROZWlnaGJvcnMpXG5cbi8vIC8vICAgICAgICAgbGV0IG5leHRDZWxsO1xuXG4vLyAvLyAgICAgICAgIGlmKHZhbGlkTmVpZ2hib3JzLmxlbmd0aCA+IDApe1xuLy8gLy8gICAgICAgICAgICAgbmV4dENlbGwgPSB0aGlzLmNob29zZVJhbmRvbU5laWdoYm9yKHZhbGlkTmVpZ2hib3JzKTtcbi8vIC8vICAgICAgICAgICAgIHJldHVybiBuZXh0Q2VsbDtcbi8vIC8vICAgICAgICAgfVxuLy8gLy8gICAgICAgICAvLyBsZXQgbmV4dENlbGwgPSBcblxuLy8gLy8gICAgICAgICAvLyAvL25lZWQgdG8gY2hlY2sgaWYgbmV4dENlbGwgaXMgdHJ1ZSBiYyBpdCBjb3VsZCBiZSB1bmRlZmluZWQgYXQgdGhlIGVkZ2VzXG4vLyAvLyAgICAgICAgIC8vIHdoaWxlKG5leHRDZWxsICYmIG5leHRDZWxsLnZpc2l0ZWQpe1xuLy8gLy8gICAgICAgICAgICAgLy8gICAgIG5leHRDZWxsID0gdGhpcy5jaG9vc2VSYW5kb21OZWlnaGJvcihuZWlnaGJvcnMpXG5cbi8vIC8vICAgICAgICAgICAgIC8vICAgICBpZihuZXh0Q2VsbCAmJiAhbmV4dENlbGwudmlzaXRlZCl7XG4vLyAvLyAgICAgICAgICAgICAgICAgLy8gICAgICAgICByZXR1cm4gbmV4dENlbGxcbi8vIC8vICAgICAgICAgICAgICAgICAvLyAgICAgfVxuLy8gLy8gICAgICAgICAgICAgICAgIC8vIH1cblxuLy8gLy8gICAgICAgICAgICAgICAgIC8vIGlmIChuZXh0Q2VsbCkge1xuLy8gLy8gICAgICAgICAgICAgICAgICAgICAvLyAgICAgcmVjdChzdGFydFJvdywgc3RhcnRDb2wsIDQwLCA0MClcbi8vIC8vICAgICAgICAgICAgICAgICAgICAgLy8gICAgIGZpbGwoXCJwdXJwbGVcIik7XG4vLyAvLyAgICAgICAgICAgICAgICAgICAgIC8vIH1cbi8vIC8vICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cobmV4dENlbGwpXG4vLyAvLyAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBuZXh0Q2VsbDtcblxuLy8gLy8gICAgIH1cblxuLy8gLy8gICAgIHRoaXMuY2hvb3NlUmFuZG9tTmVpZ2hib3IgPSBmdW5jdGlvbih2YWxpZE5laWdoYm9ycykge1xuLy8gLy8gICAgICAgIHJldHVybiB2YWxpZE5laWdoYm9yc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB2YWxpZE5laWdoYm9ycy5sZW5ndGgpXSBcbi8vIC8vICAgICB9XG5cbi8vIC8vIH1cblxuLy8gLy8gZnVuY3Rpb24gV2FsbCgpe1xuLy8gLy8gICAgIHRoaXMucHJlc2VudCA9IHRydWU7XG5cbi8vIC8vICAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKGksIHgsIHkpe1xuLy8gLy8gICAgICAgICBzdHJva2UoMjU1KTtcbi8vIC8vICAgICAgICAgc3dpdGNoKGkpe1xuLy8gLy8gICAgICAgICAgICAgY2FzZSAwOiBcbi8vIC8vICAgICAgICAgICAgICAgICBsaW5lKHgsIHksIHgsIHkgKyA0MClcbi8vIC8vICAgICAgICAgICAgIGNhc2UgMTpcbi8vIC8vICAgICAgICAgICAgICAgICBsaW5lKHgsIHkgKyA0MCwgeCArIDQwLCB5ICsgNDApXG4vLyAvLyAgICAgICAgICAgICBjYXNlIDI6IFxuLy8gLy8gICAgICAgICAgICAgICAgIGxpbmUoeCArIDQwLCB5ICsgNDAsIHggKyA0MCwgeSlcbi8vIC8vICAgICAgICAgICAgIGNhc2UgMzpcbi8vIC8vICAgICAgICAgICAgICAgICBsaW5lKHggKyA0MCwgeSwgeCwgeSlcbi8vIC8vICAgICAgICAgfVxuLy8gLy8gICAgIH1cbi8vIC8vIH1cblxuLy8gd2luZG93LnNldHVwID0gc2V0dXA7XG5cbi8vIHdpbmRvdy5kcmF3ID0gZHJhdztcblxuLy8gLy9wNSBjYW5ub3QgZmluZCB0aGUgZnVuY3Rpb25zLCBcbi8vIC8vc28gd2UgbmVlZCB0byBzZXQgaXQgdG8gdGhlIHdpbmRvdyBzbyB0aGUgZnggY2FuIGJlIGZvdW5kIFxuXG4vLyBjb25zdCBDZWxsID0gcmVxdWlyZSgnLi9jZWxsJyk7XG4vLyAvLyBjb25zdCBNb3ZpbmdPYmplY3QgPSByZXF1aXJlKCcuL21vdmluZ19vYmplY3RzJyk7XG4vLyAvLyBjb25zdCBVc2VyID0gcmVxdWlyZSgnLi91c2VyJyk7XG4vLyBjb25zdCBHYW1lID0gcmVxdWlyZSgnLi9nYW1lJyk7XG4vLyBjb25zdCBNYXplID0gcmVxdWlyZSgnLi9tYXplJyk7XG5cbi8vIC8vIHdpbmRvdy5Nb3ZpbmdPYmplY3QgPSBNb3ZpbmdPYmplY3Q7XG5cbi8vIGNvbnN0IGdyaWQgPSBbXTtcblxuLy8gbGV0IGN1cnJlbnQ7XG5cbi8vIGNvbnN0IHN0YWNrID0gW107XG5cbi8vIGxldCBnYW1lO1xuLy8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlwcmVzc1wiLCAoZXZlbnQpID0+IChnYW1lLnVzZXJNb3ZlKGV2ZW50KSkpO1xuXG5cbi8vIGxldCBtYXplO1xuXG4vLyBsZXQgbWFwQ29tcGxldGUgPSBmYWxzZTtcblxuLy8gLy8gY29uc3QgdXNlciA9IG5ldyBVc2VyKCk7XG5cbi8vIGZ1bmN0aW9uIHNldHVwKCkge1xuLy8gICAgIGNyZWF0ZUNhbnZhcyg4MDAsIDgwMCk7XG4vLyAgICAgLy8gICBjb2xzID0gMTA7XG4vLyAgICAgLy8gICByb3dzID0gMTA7XG5cbi8vICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDIwOyB4KyspIHtcbi8vICAgICAgICAgZ3JpZFt4XSA9IFtdO1xuLy8gICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDIwOyB5KyspIHtcbi8vICAgICAgICAgICAgIGdyaWRbeF0ucHVzaChuZXcgQ2VsbCh4LCB5LCBncmlkLCBzdGFjaykpXG4vLyAgICAgICAgIH1cbi8vICAgICB9XG5cbi8vICAgICBsZXQgY3VycmVudF9yb3cgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyMCk7XG4vLyAgICAgbGV0IGN1cnJlbnRfY29sID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjApO1xuXG4vLyAgICAgY3VycmVudCA9IGdyaWRbY3VycmVudF9yb3ddW2N1cnJlbnRfY29sXTtcbi8vICAgICBnYW1lID0gbmV3IEdhbWUoZ3JpZCk7XG4vLyAgICAgbWF6ZSA9IG5ldyBNYXplKGN1cnJlbnQsIGdyaWQsIGdhbWUpO1xuXG4vLyAgICAgLy8gICBjb25zb2xlLmxvZyhcImN1cnJlbnRcIilcbi8vICAgICAvLyAgIGNvbnNvbGUubG9nKGN1cnJlbnQpXG5cbi8vICAgICBmcmFtZVJhdGUoMTAwKTtcblxuLy8gfVxuXG4vLyAvLyBjb25zdCBtYXplID0gbmV3IE1hemUoY3VycmVudCwgZ3JpZCk7XG5cbi8vIGZ1bmN0aW9uIGRyYXcoKSB7XG4vLyAgICAgLy8gaWYoIW1hcENvbXBsZXRlKXtcbi8vICAgICBnYW1lLmZpcnN0VXNlclJlbmRlcigpO1xuLy8gICAgIG1hemUuZHJhdygpO1xuLy8gICAgIC8vIG1hcENvbXBsZXRlID0gbWF6ZS5tYXBDb21wbGV0ZSgpO1xuLy8gICAgIC8vIH1cbi8vICAgICAvLyBjb25zb2xlLmxvZyhcImZpbmlzaCBtYXplXCIpXG4vLyAgICAgZ2FtZS51c2VyTW92ZSgpO1xuLy8gICAgIGdhbWUudXNlclJlbmRlcigpO1xuLy8gICAgIC8vIGNvbnNvbGUubG9nKGdhbWUudXNlci5wb3MpXG4vLyAgICAgLy8gZ2FtZS51c2VyUmVuZGVyKDAsIDApO1xuXG4vLyAgICAgLy8gY29uc3Qga2V5cHJlc3MgPSBldmVudC5rZXlDb2RlO1xuLy8gICAgIC8vIGNvbnNvbGUubG9nKGV2ZW50KTtcblxuXG4vLyAgICAgLy8gZ2FtZS51c2VyTW92ZSgpO1xuLy8gICAgIC8vIGdhbWUudXNlci5kcmF3KCk7XG5cbi8vICAgICAvLyBsb29wKCk7XG4vLyAgICAgLy8gYmFja2dyb3VuZCg1MSlcblxuLy8gICAgIC8vIGlmKCFtYXAgJiYgIWdhbWVFbmQpe1xuLy8gICAgIC8vICAgICBpZiAoY3VycmVudCkge1xuLy8gICAgIC8vICAgICAgICAgY3VycmVudC52aXNpdGVkID0gdHJ1ZTtcbi8vICAgICAvLyAgICAgLy8gY3VycmVudC5oaWdobGlnaHQoKTtcbi8vICAgICAvLyAgICAgICAgIHN0YWNrLnB1c2goY3VycmVudCk7XG4vLyAgICAgLy8gICAgIH1cblxuXG4vLyAgICAgLy8gICAgIC8vIGxldCBuZXh0Q2VsbCA9IGN1cnJlbnQuZ2V0TmV4dENlbGwoY3VycmVudC5yb3csIGN1cnJlbnQuY29sKTtcbi8vICAgICAvLyAgICAgbGV0IG5leHRDZWxsID0gY3VycmVudC5nZXROZWlnaGJvcigpO1xuXG4vLyAgICAgLy8gICAgIC8vIGNvbnNvbGUubG9nKFwibmV4dGNlbGxcIilcbi8vICAgICAvLyAgICAgLy8gY29uc29sZS5sb2cobmV4dENlbGwpO1xuXG4vLyAgICAgLy8gICAgIHRoaXMucmVtb3ZlV2FsbHMgPSBmdW5jdGlvbihjdXJyZW50LCBuZXh0LCBncmlkKXtcbi8vICAgICAvLyAgICAgICAgIGNvbnN0IGNoYW5nZVggPSBjdXJyZW50LnJvdyAtIG5leHQucm93O1xuLy8gICAgIC8vICAgICAgICAgY29uc3QgY2hhbmdlWSA9IGN1cnJlbnQuY29sIC0gbmV4dC5jb2w7XG5cblxuLy8gICAgIC8vICAgICAgICAgc3dpdGNoKGNoYW5nZVgpe1xuLy8gICAgIC8vICAgICAgICAgICAgIGNhc2UgMTpcbi8vICAgICAvLyAgICAgICAgICAgICAgICAgY3VycmVudC53YWxsc1swXS5wcmVzZW50ID0gZmFsc2U7ICBcbi8vICAgICAvLyAgICAgICAgICAgICAgICAgbmV4dC53YWxsc1syXS5wcmVzZW50ID0gZmFsc2U7XG4vLyAgICAgLy8gICAgICAgICAgICAgICAgIGJyZWFrO1xuLy8gICAgIC8vICAgICAgICAgICAgIGNhc2UgLTE6XG4vLyAgICAgLy8gICAgICAgICAgICAgICAgIGN1cnJlbnQud2FsbHNbMl0ucHJlc2VudCA9IGZhbHNlO1xuLy8gICAgIC8vICAgICAgICAgICAgICAgICBuZXh0LndhbGxzWzBdLnByZXNlbnQgPSBmYWxzZTtcbi8vICAgICAvLyAgICAgICAgICAgICAgICAgYnJlYWs7XG4vLyAgICAgLy8gICAgICAgICB9XG5cbi8vICAgICAvLyAgICAgICAgIHN3aXRjaCAoY2hhbmdlWSkge1xuLy8gICAgIC8vICAgICAgICAgICAgIGNhc2UgMTpcbi8vICAgICAvLyAgICAgICAgICAgICAgICAgY3VycmVudC53YWxsc1szXS5wcmVzZW50ID0gZmFsc2U7XG4vLyAgICAgLy8gICAgICAgICAgICAgICAgIG5leHQud2FsbHNbMV0ucHJlc2VudCA9IGZhbHNlO1xuLy8gICAgIC8vICAgICAgICAgICAgICAgICBicmVhaztcbi8vICAgICAvLyAgICAgICAgICAgICBjYXNlIC0xOlxuLy8gICAgIC8vICAgICAgICAgICAgICAgICBjdXJyZW50LndhbGxzWzFdLnByZXNlbnQgPSBmYWxzZTtcbi8vICAgICAvLyAgICAgICAgICAgICAgICAgbmV4dC53YWxsc1szXS5wcmVzZW50ID0gZmFsc2U7XG4vLyAgICAgLy8gICAgICAgICAgICAgICAgIGJyZWFrO1xuLy8gICAgIC8vICAgICAgICAgfVxuXG4vLyAgICAgLy8gICAgICAgICAvLyBjb25zdCBmaXJzdFJvdyA9IGdyaWRbMF07XG4vLyAgICAgLy8gICAgICAgICAvLyBjb25zdCBsYXN0Um93ID0gZ3JpZFsxOV07XG5cbi8vICAgICAvLyAgICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgZmlyc3RSb3cubGVuZ3RoOyBpKyspIHtcbi8vICAgICAvLyAgICAgICAgIC8vICAgICBmaXJzdFJvd1tpXS53YWxsc1szXS5wcmVzZW50ID0gdHJ1ZVxuLy8gICAgIC8vICAgICAgICAgLy8gfVxuXG4vLyAgICAgLy8gICAgICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RSb3cubGVuZ3RoOyBpKyspIHtcbi8vICAgICAvLyAgICAgICAgIC8vICAgICBsYXN0Um93W2ldLndhbGxzWzFdLnByZXNlbnQgPSB0cnVlXG4vLyAgICAgLy8gICAgICAgICAvLyB9XG5cbi8vICAgICAvLyAgICAgICAgIC8vIGNvbnN0IGZpcnN0Q29sID0gZ3JpZC5maWx0ZXIoKGNlbGwpID0+IHtcbi8vICAgICAvLyAgICAgICAgIC8vICAgICByZXR1cm4gY2VsbC5jb2wgPT09IDBcbi8vICAgICAvLyAgICAgICAgIC8vIH0pXG5cbi8vICAgICAvLyAgICAgICAgIC8vIGNvbnN0IGxhc3RDb2wgPSBncmlkLmZpbHRlcigoY2VsbCkgPT4ge1xuLy8gICAgIC8vICAgICAgICAgLy8gICAgIHJldHVybiBjZWxsLmNvbCA9PT0gMTlcbi8vICAgICAvLyAgICAgICAgIC8vIH0pXG5cbi8vICAgICAvLyAgICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgZmlyc3RDb2wubGVuZ3RoOyBpKyspIHtcbi8vICAgICAvLyAgICAgICAgIC8vICAgICBmaXJzdENvbFtpXS53YWxsc1syXS5wcmVzZW50ID0gdHJ1ZTtcbi8vICAgICAvLyAgICAgICAgIC8vIH1cblxuLy8gICAgIC8vICAgICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0Q29sLmxlbmd0aDsgaSsrKSB7XG4vLyAgICAgLy8gICAgICAgICAvLyAgICAgbGFzdENvbFtpXS53YWxsc1swXS5wcmVzZW50ID0gdHJ1ZTtcbi8vICAgICAvLyAgICAgICAgIC8vIH1cbi8vICAgICAvLyAgICAgfSBcblxuLy8gICAgIC8vICAgICBpZihuZXh0Q2VsbCl7XG4vLyAgICAgLy8gICAgICAgICBuZXh0Q2VsbC52aXNpdGVkID0gdHJ1ZTtcbi8vICAgICAvLyAgICAgICAgIHRoaXMucmVtb3ZlV2FsbHMoY3VycmVudCwgbmV4dENlbGwsIGdyaWQpO1xuLy8gICAgIC8vICAgICAgICAgY3VycmVudCA9IG5leHRDZWxsO1xuLy8gICAgIC8vICAgICAgICAgLy8gY29uc29sZS5sb2coXCJzdGFja1wiKVxuLy8gICAgIC8vICAgICAgICAgLy8gY29uc29sZS5sb2coc3RhY2spO1xuLy8gICAgIC8vICAgICB9IGVsc2UgaWYoc3RhY2subGVuZ3RoID4gMCl7XG4vLyAgICAgLy8gICAgICAgICBwb3RlbnRpYWxSZXN0YXJ0ID0gc3RhY2sucG9wKClcbi8vICAgICAvLyAgICAgICAgICAgICB3aGlsZSAocG90ZW50aWFsUmVzdGFydCAmJiAhcG90ZW50aWFsUmVzdGFydC5nZXROZWlnaGJvcigpKXtcbi8vICAgICAvLyAgICAgICAgICAgICAgICAgaWYoIXN0YWNrLmxlbmd0aCl7XG4vLyAgICAgLy8gICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxSZXN0YXJ0LnZpc2l0ZWQgPSB0cnVlXG4vLyAgICAgLy8gICAgICAgICAgICAgICAgICAgICBtYXAgPSB0cnVlO1xuLy8gICAgIC8vICAgICAgICAgICAgICAgICAgICAgbm9Mb29wKCk7XG4vLyAgICAgLy8gICAgICAgICAgICAgICAgICAgICBicmVhaztcbi8vICAgICAvLyAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbi8vICAgICAvLyAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbFJlc3RhcnQgPSBzdGFjay5wb3AoKTtcbi8vICAgICAvLyAgICAgICAgICAgICAgICAgfVxuLy8gICAgIC8vICAgICAgICAgICAgIH1cbi8vICAgICAvLyAgICAgICAgICAgICBjdXJyZW50ID0gcG90ZW50aWFsUmVzdGFydDtcbi8vICAgICAvLyAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhjdXJyZW50KVxuLy8gICAgIC8vICAgICAvLyB9IGVsc2UgaWYoYWxsVmlzaXRlZCkge1xuLy8gICAgIC8vICAgICAvLyAgICAgbm9Mb29wKCk7XG4vLyAgICAgLy8gICAgIH1cblxuXG4vLyAgICAgLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JpZC5sZW5ndGg7IGkrKykge1xuLy8gICAgIC8vICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBncmlkW2ldLmxlbmd0aDsgaisrKSB7XG4vLyAgICAgLy8gICAgICAgICAgICAgZ3JpZFtpXVtqXS5yZW5kZXIoKTtcbi8vICAgICAvLyAgICAgICAgIH1cbi8vICAgICAvLyAgICAgfVxuXG4vLyAgICAgLy8gICAgIGdhbWUudXNlclJlbmRlcigpO1xuLy8gICAgIC8vIH0gZWxzZSBpZihtYXAgJiYgIWdhbWVFbmQpe1xuLy8gICAgIC8vICAgICAvLyBsb29wKClcbi8vICAgICAvLyAgICAgY29uc29sZS5sb2coXCJoaVwiKVxuLy8gICAgIC8vICAgICBnYW1lLnVzZXJSZW5kZXIoKTtcbi8vICAgICAvLyAgICAgLy8gZ2FtZS51c2VyTW92ZSgpO1xuLy8gICAgIC8vICAgICBrZXlQcmVzc2VkKCk7XG5cbi8vICAgICAvLyAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmlkLmxlbmd0aDsgaSsrKSB7XG4vLyAgICAgLy8gICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdyaWRbaV0ubGVuZ3RoOyBqKyspIHtcbi8vICAgICAvLyAgICAgICAgICAgICBncmlkW2ldW2pdLnJlbmRlcigpO1xuLy8gICAgIC8vICAgICAgICAgfVxuLy8gICAgIC8vICAgICB9XG5cbi8vICAgICAvLyB9XG5cbi8vICAgICAvLyAvLyBjdXJyZW50LmhpZ2hsaWdodCgpO1xuXG4vLyAgICAgLy8gZnVuY3Rpb24ga2V5UHJlc3NlZCgpe1xuLy8gICAgIC8vICAgICAvLyBsb29wKCk7XG4vLyAgICAgLy8gICAgIGdhbWUudXNlck1vdmUoKTtcbi8vICAgICAvLyAgICAgLy8gbG9vcCgpICAgICAgICBcbi8vICAgICAvLyAgICAgcmV0dXJuIGZhbHNlO1xuLy8gICAgIC8vIH1cblxuLy8gICAgIC8vIGtleVByZXNzZWQoKTtcblxuLy8gICAgIC8vIC8vIHVzZXIucmVuZGVyKCk7XG5cblxuXG4vLyAgICAgLy8gLy8gcmVkcmF3KCk7XG5cbi8vICAgICAvLyAvLyB3aGlsZSAoIWdhbWUuZW5kKCkpe1xuLy8gICAgIC8vIC8vICAgICBnYW1lLnVzZXJNb3ZlKClcbi8vICAgICAvLyAvLyB9XG5cbi8vIH1cblxuXG4vLyAvLyBmdW5jdGlvbiBDZWxsKHJvdywgY29sKSB7XG4vLyAvLyAgICAgdGhpcy5yb3cgPSByb3c7XG4vLyAvLyAgICAgdGhpcy5jb2wgPSBjb2w7XG4vLyAvLyAgICAgdGhpcy53YWxscyA9IFtuZXcgV2FsbCgpLCBuZXcgV2FsbCgpLCBuZXcgV2FsbCgpLCBuZXcgV2FsbCgpXTtcbi8vIC8vICAgICB0aGlzLnZpc2l0ZWQgPSBmYWxzZTtcblxuLy8gLy8gICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuLy8gLy8gICAgICAgICBjb25zdCBzdGFydFJvdyA9IHRoaXMucm93ICogNDA7XG4vLyAvLyAgICAgICAgIGNvbnN0IHN0YXJ0Q29sID0gdGhpcy5jb2wgKiA0MDtcblxuLy8gLy8gICAgICAgICAvLyB4LCB5LCB3aWR0aCwgaGVpZ2h0XG4vLyAvLyAgICAgICAgIC8vIHJlY3Qoc3RhcnRYLCBzdGFydFksIDQwLCA0MClcbi8vIC8vICAgICAgICAgLy8gbm9GaWxsKCk7XG4vLyAvLyAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLndhbGxzLmxlbmd0aDsgaSsrKXtcbi8vIC8vICAgICAgICAgICAgIHRoaXMud2FsbHNbaV0ucmVuZGVyKGksIHN0YXJ0Um93LCBzdGFydENvbCk7XG4vLyAvLyAgICAgICAgIH1cblxuLy8gLy8gICAgICAgICBpZih0aGlzLnZpc2l0ZWQpe1xuLy8gLy8gICAgICAgICAgICAgcmVjdChzdGFydFJvdywgc3RhcnRDb2wsIDQwLCA0MClcbi8vIC8vICAgICAgICAgICAgIGZpbGwoXCJncmVlblwiKTtcbi8vIC8vICAgICAgICAgfVxuXG4vLyAvLyAgICAgfVxuXG4vLyAvLyAgICAgdGhpcy5nZXROZWlnaGJvciA9IGZ1bmN0aW9uKCl7XG5cbi8vIC8vICAgICAgICAgLy8gY29uc3QgbmVpZ2hib3JzSW5kaWNlcyA9IFtcbi8vIC8vICAgICAgICAgLy8gICAgIFtyb3cgLSAxLCBjb2xdLFxuLy8gLy8gICAgICAgICAvLyAgICAgW3JvdyArIDEsIGNvbF0sXG4vLyAvLyAgICAgICAgIC8vICAgICBbcm93LCBjb2wgLSAxXSxcbi8vIC8vICAgICAgICAgLy8gICAgIFtyb3csIGNvbCArIDFdICAgICAgICAgICAgXG4vLyAvLyAgICAgICAgIC8vIF1cblxuLy8gLy8gICAgICAgICBjb25zdCBuZWlnaGJvcnMgPSBbXG4vLyAvLyAgICAgICAgICAgICBncmlkW3JvdyAtIDFdW2NvbF0sXG4vLyAvLyAgICAgICAgICAgICBncmlkW3JvdyArIDFdW2NvbF0sXG4vLyAvLyAgICAgICAgICAgICBncmlkW3Jvd11bY29sIC0gMV0sXG4vLyAvLyAgICAgICAgICAgICBncmlkW3Jvd11bY29sICsgMV0gICAgICAgICAgICBcbi8vIC8vICAgICAgICAgXVxuXG4vLyAvLyAgICAgICAgIC8vIGNvbnN0IG5laWdoYm9ycyA9IFtdO1xuXG4vLyAvLyAgICAgICAgIC8vIGNvbnN0IHZhbGlkYXRlSWR4ID0gZnVuY3Rpb24gKGlkeEFycikge1xuLy8gLy8gICAgICAgICAvLyAgICAgaWYoaWR4QXJyLmV2ZXJ5KChpZHgpID0+IHtcbi8vIC8vICAgICAgICAgLy8gICAgICAgICByZXR1cm4gaWR4IDwgMjAgJiYgaWR4ID49IDB9XG4vLyAvLyAgICAgICAgIC8vICAgICAgICAgKSl7XG5cbi8vIC8vICAgICAgICAgLy8gICAgICAgICBuZWlnaGJvcnMucHVzaChpZHhBcnIpO1xuLy8gLy8gICAgICAgICAvLyAgICAgfVxuLy8gLy8gICAgICAgICAvLyB9XG5cbi8vIC8vICAgICAgICAgLy8gbGV0IHRvcCA9IFsocm93IC0gMSksIGNvbF07XG4vLyAvLyAgICAgICAgIC8vIHZhbGlkYXRlSWR4KHRvcCk7XG4vLyAvLyAgICAgICAgIC8vIGxldCByaWdodCA9IFtyb3csIChjb2wrMSldO1xuLy8gLy8gICAgICAgICAvLyB2YWxpZGF0ZUlkeChyaWdodCk7XG4vLyAvLyAgICAgICAgIC8vIGxldCBib3R0b20gPSBbKHJvdyArIDEpLCBjb2xdO1xuLy8gLy8gICAgICAgICAvLyB2YWxpZGF0ZUlkeChib3R0b20pO1xuLy8gLy8gICAgICAgICAvLyBsZXQgbGVmdCA9IFtyb3csIChjb2wgLSAxKV07XG4vLyAvLyAgICAgICAgIC8vIHZhbGlkYXRlSWR4KGxlZnQpO1xuXG4vLyAvLyAgICAgICAgIGNvbnNvbGUubG9nKG5laWdoYm9ycylcblxuLy8gLy8gICAgICAgICBjb25zdCB2YWxpZE5laWdoYm9ycyA9IFtdO1xuXG4vLyAvLyAgICAgICAgIC8vIGZvcihsZXQgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKyspe1xuLy8gLy8gICAgICAgICAvLyAgICAgaWYgKChuZWlnaGJvcnNbaV1bMF0gPCAyMCAmJiBuZWlnaGJvcnNbaV1bMF0gPj0gMCkgJiYgKG5laWdoYm9yc1tpXVsxXSA8IDIwICYmIG5laWdoYm9yc1tpXVsxXSA+PSAwKSkge1xuLy8gLy8gICAgICAgICAvLyAgICAgICAgIHZhbGlkTmVpZ2hib3JzLnB1c2gobmVpZ2hib3JzW2ldKTtcbi8vIC8vICAgICAgICAgLy8gICAgIH1cbi8vIC8vICAgICAgICAgLy8gfVxuXG4vLyAvLyAgICAgICAgIC8vIGNvbnN0IHZhbGlkTmVpZ2hib3JzID0gbmVpZ2hib3JzLmZpbHRlcihuZWlnaGJvciA9PiB7XG4vLyAvLyAgICAgICAgIC8vICAgICAvLyBsZXQgeCA9IG5laWdoYm9yWzBdO1xuLy8gLy8gICAgICAgICAvLyAgICAgLy8gbGV0IHkgPSBuZWlnaGJvclsxXTtcblxuLy8gLy8gICAgICAgICAvLyAgICAgaWYoKG5laWdoYm9yWzBdIDwgMjAgJiYgbmVpZ2hib3JbMF0gPj0gMCkgJiYgKG5laWdoYm9yWzFdIDwgMjAgJiYgbmVpZ2hib3JbMV0gPj0gMCkpe1xuLy8gLy8gICAgICAgICAvLyAgICAgICAgIHJldHVybiBuZWlnaGJvcjtcbi8vIC8vICAgICAgICAgLy8gICAgIH1cbi8vIC8vICAgICAgICAgLy8gfVxuXG4vLyAvLyAgICAgICAgIC8vIGNvbnN0IHZhbGlkYXRlTmVpZ2hib3JzID0gZnVuY3Rpb24obmVpZ2hib3IpIHtcbi8vIC8vICAgICAgICAgLy8gICAgIGlmKCFuZWlnaGJvcil7XG4vLyAvLyAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIGZhbHNlO1xuLy8gLy8gICAgICAgICAvLyAgICAgfVxuLy8gLy8gICAgICAgICAvLyAgICAgLy8gbGV0IHggPSBuZWlnaGJvclswXTtcbi8vIC8vICAgICAgICAgLy8gICAgIC8vIGxldCB5ID0gbmVpZ2hib3JbMV07XG5cbi8vIC8vICAgICAgICAgLy8gICAgIGlmKG5laWdoYm9yLnJvdyA8IDIwIHx8IG5laWdoYm9yLnJvdyA+PTApe1xuLy8gLy8gICAgICAgICAvLyAgICAgICAgIHJldHVybiBmYWxzZTtcbi8vIC8vICAgICAgICAgLy8gICAgIH0gZWxzZSBpZihuZWlnaGJvci5jb2wgPCAyMCB8fCBuZWlnaGJvci5jb2wgPj0gMCl7XG4vLyAvLyAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIGZhbHNlO1xuLy8gLy8gICAgICAgICAvLyAgICAgfSBlbHNle1xuLy8gLy8gICAgICAgICAvLyAgICAgICAgIHJldHVybiB0cnVlXG4vLyAvLyAgICAgICAgIC8vICAgICB9XG5cbi8vIC8vICAgICAgICAgLy8gfVxuXG4vLyAvLyAgICAgICAgIC8vIGNvbnN0IHZhbGlkYXRlTmVpZ2hib3JzID0gZnVuY3Rpb24obmVpZ2hib3Ipe1xuLy8gLy8gICAgICAgICAvLyAgICAgY29uc29sZS5sb2cobmVpZ2hib3IpXG4vLyAvLyAgICAgICAgIC8vICAgICBuZWlnaGJvclxuLy8gLy8gICAgICAgICAvLyB9XG5cbi8vIC8vICAgICAgICAgLy8gY29uc3QgdmFsaWROZWlnaGJvcnMgPSBuZWlnaGJvcnMuZmlsdGVyKHZhbGlkYXRlTmVpZ2hib3JzKTtcblxuLy8gLy8gICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSsrKXtcbi8vIC8vICAgICAgICAgICAgIGlmKG5laWdoYm9yc1tpXSAmJiAhKG5laWdoYm9yc1tpXS52aXNpdGVkKSl7XG4vLyAvLyAgICAgICAgICAgICAgICAgdmFsaWROZWlnaGJvcnMucHVzaChuZWlnaGJvcnNbaV0pXG4vLyAvLyAgICAgICAgICAgICB9XG4vLyAvLyAgICAgICAgIH1cblxuXG4vLyAvLyAgICAgICAgIGNvbnNvbGUubG9nKFwidmFsaWRcIikgXG4vLyAvLyAgICAgICAgIGNvbnNvbGUubG9nKHZhbGlkTmVpZ2hib3JzKVxuXG4vLyAvLyAgICAgICAgIGxldCBuZXh0Q2VsbDtcblxuLy8gLy8gICAgICAgICBpZih2YWxpZE5laWdoYm9ycy5sZW5ndGggPiAwKXtcbi8vIC8vICAgICAgICAgICAgIG5leHRDZWxsID0gdGhpcy5jaG9vc2VSYW5kb21OZWlnaGJvcih2YWxpZE5laWdoYm9ycyk7XG4vLyAvLyAgICAgICAgICAgICByZXR1cm4gbmV4dENlbGw7XG4vLyAvLyAgICAgICAgIH1cbi8vIC8vICAgICAgICAgLy8gbGV0IG5leHRDZWxsID0gXG5cbi8vIC8vICAgICAgICAgLy8gLy9uZWVkIHRvIGNoZWNrIGlmIG5leHRDZWxsIGlzIHRydWUgYmMgaXQgY291bGQgYmUgdW5kZWZpbmVkIGF0IHRoZSBlZGdlc1xuLy8gLy8gICAgICAgICAvLyB3aGlsZShuZXh0Q2VsbCAmJiBuZXh0Q2VsbC52aXNpdGVkKXtcbi8vIC8vICAgICAgICAgICAgIC8vICAgICBuZXh0Q2VsbCA9IHRoaXMuY2hvb3NlUmFuZG9tTmVpZ2hib3IobmVpZ2hib3JzKVxuXG4vLyAvLyAgICAgICAgICAgICAvLyAgICAgaWYobmV4dENlbGwgJiYgIW5leHRDZWxsLnZpc2l0ZWQpe1xuLy8gLy8gICAgICAgICAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIG5leHRDZWxsXG4vLyAvLyAgICAgICAgICAgICAgICAgLy8gICAgIH1cbi8vIC8vICAgICAgICAgICAgICAgICAvLyB9XG5cbi8vIC8vICAgICAgICAgICAgICAgICAvLyBpZiAobmV4dENlbGwpIHtcbi8vIC8vICAgICAgICAgICAgICAgICAgICAgLy8gICAgIHJlY3Qoc3RhcnRSb3csIHN0YXJ0Q29sLCA0MCwgNDApXG4vLyAvLyAgICAgICAgICAgICAgICAgICAgIC8vICAgICBmaWxsKFwicHVycGxlXCIpO1xuLy8gLy8gICAgICAgICAgICAgICAgICAgICAvLyB9XG4vLyAvLyAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG5leHRDZWxsKVxuLy8gLy8gICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gbmV4dENlbGw7XG5cbi8vIC8vICAgICB9XG5cbi8vIC8vICAgICB0aGlzLmNob29zZVJhbmRvbU5laWdoYm9yID0gZnVuY3Rpb24odmFsaWROZWlnaGJvcnMpIHtcbi8vIC8vICAgICAgICByZXR1cm4gdmFsaWROZWlnaGJvcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdmFsaWROZWlnaGJvcnMubGVuZ3RoKV0gXG4vLyAvLyAgICAgfVxuXG4vLyAvLyB9XG5cbi8vIC8vIGZ1bmN0aW9uIFdhbGwoKXtcbi8vIC8vICAgICB0aGlzLnByZXNlbnQgPSB0cnVlO1xuXG4vLyAvLyAgICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbihpLCB4LCB5KXtcbi8vIC8vICAgICAgICAgc3Ryb2tlKDI1NSk7XG4vLyAvLyAgICAgICAgIHN3aXRjaChpKXtcbi8vIC8vICAgICAgICAgICAgIGNhc2UgMDogXG4vLyAvLyAgICAgICAgICAgICAgICAgbGluZSh4LCB5LCB4LCB5ICsgNDApXG4vLyAvLyAgICAgICAgICAgICBjYXNlIDE6XG4vLyAvLyAgICAgICAgICAgICAgICAgbGluZSh4LCB5ICsgNDAsIHggKyA0MCwgeSArIDQwKVxuLy8gLy8gICAgICAgICAgICAgY2FzZSAyOiBcbi8vIC8vICAgICAgICAgICAgICAgICBsaW5lKHggKyA0MCwgeSArIDQwLCB4ICsgNDAsIHkpXG4vLyAvLyAgICAgICAgICAgICBjYXNlIDM6XG4vLyAvLyAgICAgICAgICAgICAgICAgbGluZSh4ICsgNDAsIHksIHgsIHkpXG4vLyAvLyAgICAgICAgIH1cbi8vIC8vICAgICB9XG4vLyAvLyB9XG5cbi8vIHdpbmRvdy5zZXR1cCA9IHNldHVwO1xuXG4vLyB3aW5kb3cuZHJhdyA9IGRyYXc7XG5cbi8vIC8vcDUgY2Fubm90IGZpbmQgdGhlIGZ1bmN0aW9ucywgXG4vLyAvL3NvIHdlIG5lZWQgdG8gc2V0IGl0IHRvIHRoZSB3aW5kb3cgc28gdGhlIGZ4IGNhbiBiZSBmb3VuZCBcblxuLy8gLy8gY29uc3QgQ2VsbCA9IHJlcXVpcmUoJy4vY2VsbCcpO1xuLy8gLy8gLy8gY29uc3QgTW92aW5nT2JqZWN0ID0gcmVxdWlyZSgnLi9tb3Zpbmdfb2JqZWN0cycpO1xuLy8gLy8gLy8gY29uc3QgVXNlciA9IHJlcXVpcmUoJy4vdXNlcicpO1xuLy8gLy8gY29uc3QgR2FtZSA9IHJlcXVpcmUoJy4vZ2FtZScpO1xuXG4vLyAvLyAvLyB3aW5kb3cuTW92aW5nT2JqZWN0ID0gTW92aW5nT2JqZWN0O1xuXG4vLyAvLyBjb25zdCBncmlkID0gW107XG5cbi8vIC8vIGxldCBjdXJyZW50O1xuXG4vLyAvLyBjb25zdCBzdGFjayA9IFtdO1xuXG4vLyAvLyBsZXQgZ2FtZSA9IG5ldyBHYW1lKCk7XG5cbi8vIC8vIGxldCBtYXAgPSBmYWxzZTtcblxuLy8gLy8gbGV0IGdhbWVFbmQgPSBmYWxzZTtcblxuLy8gLy8gLy8gY29uc3QgdXNlciA9IG5ldyBVc2VyKCk7XG5cbi8vIC8vIGZ1bmN0aW9uIHNldHVwKCkge1xuLy8gLy8gICBjcmVhdGVDYW52YXMoODAwLCA4MDApO1xuLy8gLy8gLy8gICBjb2xzID0gMTA7XG4vLyAvLyAvLyAgIHJvd3MgPSAxMDtcblxuLy8gLy8gICBmb3IobGV0IHggPSAwOyB4IDwgMjA7IHgrKyl7XG4vLyAvLyAgICAgICBncmlkW3hdID0gW107XG4vLyAvLyAgICAgICBmb3IobGV0IHkgPSAwOyB5IDwgMjA7IHkrKyl7XG4vLyAvLyAgICAgICAgIGdyaWRbeF0ucHVzaChuZXcgQ2VsbCh4LCB5LCBncmlkLCBzdGFjaykpXG4vLyAvLyAgICAgICB9XG4vLyAvLyAgIH1cblxuLy8gLy8gICBsZXQgY3VycmVudF9yb3cgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyMCk7XG4vLyAvLyAgIGxldCBjdXJyZW50X2NvbCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIwKTtcblxuLy8gLy8gICBjdXJyZW50ID0gZ3JpZFtjdXJyZW50X3Jvd11bY3VycmVudF9jb2xdO1xuXG4vLyAvLyAgIC8vICAgY29uc29sZS5sb2coXCJjdXJyZW50XCIpXG4vLyAvLyAvLyAgIGNvbnNvbGUubG9nKGN1cnJlbnQpXG5cbi8vIC8vICAgZnJhbWVSYXRlKDEwMCk7XG5cbi8vIC8vIH1cblxuLy8gLy8gZnVuY3Rpb24gZHJhdygpIHtcbi8vIC8vICAgICBiYWNrZ3JvdW5kKDUxKVxuXG4vLyAvLyAgICAgaWYoIW1hcCAmJiAhZ2FtZUVuZCl7XG4vLyAvLyAgICAgICAgIGlmIChjdXJyZW50KSB7XG4vLyAvLyAgICAgICAgICAgICBjdXJyZW50LnZpc2l0ZWQgPSB0cnVlO1xuLy8gLy8gICAgICAgICAvLyBjdXJyZW50LmhpZ2hsaWdodCgpO1xuLy8gLy8gICAgICAgICAgICAgc3RhY2sucHVzaChjdXJyZW50KTtcbi8vIC8vICAgICAgICAgfVxuXG5cbi8vIC8vICAgICAgICAgLy8gbGV0IG5leHRDZWxsID0gY3VycmVudC5nZXROZXh0Q2VsbChjdXJyZW50LnJvdywgY3VycmVudC5jb2wpO1xuLy8gLy8gICAgICAgICBsZXQgbmV4dENlbGwgPSBjdXJyZW50LmdldE5laWdoYm9yKCk7XG5cbi8vIC8vICAgICAgICAgLy8gY29uc29sZS5sb2coXCJuZXh0Y2VsbFwiKVxuLy8gLy8gICAgICAgICAvLyBjb25zb2xlLmxvZyhuZXh0Q2VsbCk7XG5cbi8vIC8vICAgICAgICAgdGhpcy5yZW1vdmVXYWxscyA9IGZ1bmN0aW9uKGN1cnJlbnQsIG5leHQsIGdyaWQpe1xuLy8gLy8gICAgICAgICAgICAgY29uc3QgY2hhbmdlWCA9IGN1cnJlbnQucm93IC0gbmV4dC5yb3c7XG4vLyAvLyAgICAgICAgICAgICBjb25zdCBjaGFuZ2VZID0gY3VycmVudC5jb2wgLSBuZXh0LmNvbDtcblxuLy8gLy8gICAgICAgICAgICAgLy8gY3VycmVudC53YWxscy5mb3JFYWNoKHdhbGwgPT4gd2FsbC5wcmVzZW50ID0gZmFsc2UpXG5cblxuLy8gLy8gICAgICAgICAgICAgc3dpdGNoKGNoYW5nZVgpe1xuLy8gLy8gICAgICAgICAgICAgICAgIGNhc2UgMTpcbi8vIC8vICAgICAgICAgICAgICAgICAgICAgY3VycmVudC53YWxsc1swXS5wcmVzZW50ID0gZmFsc2U7ICBcbi8vIC8vICAgICAgICAgICAgICAgICAgICAgbmV4dC53YWxsc1syXS5wcmVzZW50ID0gZmFsc2U7XG4vLyAvLyAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuLy8gLy8gICAgICAgICAgICAgICAgIGNhc2UgLTE6XG4vLyAvLyAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQud2FsbHNbMl0ucHJlc2VudCA9IGZhbHNlO1xuLy8gLy8gICAgICAgICAgICAgICAgICAgICBuZXh0LndhbGxzWzBdLnByZXNlbnQgPSBmYWxzZTtcbi8vIC8vICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4vLyAvLyAgICAgICAgICAgICB9XG5cbi8vIC8vICAgICAgICAgICAgIHN3aXRjaCAoY2hhbmdlWSkge1xuLy8gLy8gICAgICAgICAgICAgICAgIGNhc2UgMTpcbi8vIC8vICAgICAgICAgICAgICAgICAgICAgY3VycmVudC53YWxsc1szXS5wcmVzZW50ID0gZmFsc2U7XG4vLyAvLyAgICAgICAgICAgICAgICAgICAgIG5leHQud2FsbHNbMV0ucHJlc2VudCA9IGZhbHNlO1xuLy8gLy8gICAgICAgICAgICAgICAgICAgICBicmVhaztcbi8vIC8vICAgICAgICAgICAgICAgICBjYXNlIC0xOlxuLy8gLy8gICAgICAgICAgICAgICAgICAgICBjdXJyZW50LndhbGxzWzFdLnByZXNlbnQgPSBmYWxzZTtcbi8vIC8vICAgICAgICAgICAgICAgICAgICAgbmV4dC53YWxsc1szXS5wcmVzZW50ID0gZmFsc2U7XG4vLyAvLyAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuLy8gLy8gICAgICAgICAgICAgfVxuXG4vLyAvLyAgICAgICAgICAgICAvLyBjb25zdCBmaXJzdFJvdyA9IGdyaWRbMF07XG4vLyAvLyAgICAgICAgICAgICAvLyBjb25zdCBsYXN0Um93ID0gZ3JpZFsxOV07XG5cbi8vIC8vICAgICAgICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgZmlyc3RSb3cubGVuZ3RoOyBpKyspIHtcbi8vIC8vICAgICAgICAgICAgIC8vICAgICBmaXJzdFJvd1tpXS53YWxsc1szXS5wcmVzZW50ID0gdHJ1ZVxuLy8gLy8gICAgICAgICAgICAgLy8gfVxuXG4vLyAvLyAgICAgICAgICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RSb3cubGVuZ3RoOyBpKyspIHtcbi8vIC8vICAgICAgICAgICAgIC8vICAgICBsYXN0Um93W2ldLndhbGxzWzFdLnByZXNlbnQgPSB0cnVlXG4vLyAvLyAgICAgICAgICAgICAvLyB9XG5cbi8vIC8vICAgICAgICAgICAgIC8vIGNvbnN0IGZpcnN0Q29sID0gZ3JpZC5maWx0ZXIoKGNlbGwpID0+IHtcbi8vIC8vICAgICAgICAgICAgIC8vICAgICByZXR1cm4gY2VsbC5jb2wgPT09IDBcbi8vIC8vICAgICAgICAgICAgIC8vIH0pXG5cbi8vIC8vICAgICAgICAgICAgIC8vIGNvbnN0IGxhc3RDb2wgPSBncmlkLmZpbHRlcigoY2VsbCkgPT4ge1xuLy8gLy8gICAgICAgICAgICAgLy8gICAgIHJldHVybiBjZWxsLmNvbCA9PT0gMTlcbi8vIC8vICAgICAgICAgICAgIC8vIH0pXG5cbi8vIC8vICAgICAgICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgZmlyc3RDb2wubGVuZ3RoOyBpKyspIHtcbi8vIC8vICAgICAgICAgICAgIC8vICAgICBmaXJzdENvbFtpXS53YWxsc1syXS5wcmVzZW50ID0gdHJ1ZTtcbi8vIC8vICAgICAgICAgICAgIC8vIH1cblxuLy8gLy8gICAgICAgICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0Q29sLmxlbmd0aDsgaSsrKSB7XG4vLyAvLyAgICAgICAgICAgICAvLyAgICAgbGFzdENvbFtpXS53YWxsc1swXS5wcmVzZW50ID0gdHJ1ZTtcbi8vIC8vICAgICAgICAgICAgIC8vIH1cbi8vIC8vICAgICAgICAgfSBcblxuLy8gLy8gICAgICAgICBpZihuZXh0Q2VsbCl7XG4vLyAvLyAgICAgICAgICAgICBuZXh0Q2VsbC52aXNpdGVkID0gdHJ1ZTtcbi8vIC8vICAgICAgICAgICAgIHRoaXMucmVtb3ZlV2FsbHMoY3VycmVudCwgbmV4dENlbGwsIGdyaWQpO1xuLy8gLy8gICAgICAgICAgICAgY3VycmVudCA9IG5leHRDZWxsO1xuLy8gLy8gICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJzdGFja1wiKVxuLy8gLy8gICAgICAgICAgICAgLy8gY29uc29sZS5sb2coc3RhY2spO1xuLy8gLy8gICAgICAgICB9IGVsc2UgaWYoc3RhY2subGVuZ3RoID4gMCl7XG4vLyAvLyAgICAgICAgICAgICBwb3RlbnRpYWxSZXN0YXJ0ID0gc3RhY2sucG9wKClcbi8vIC8vICAgICAgICAgICAgICAgICB3aGlsZSAocG90ZW50aWFsUmVzdGFydCAmJiAhcG90ZW50aWFsUmVzdGFydC5nZXROZWlnaGJvcigpKXtcbi8vIC8vICAgICAgICAgICAgICAgICAgICAgaWYoIXN0YWNrLmxlbmd0aCl7XG4vLyAvLyAgICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxSZXN0YXJ0LnZpc2l0ZWQgPSB0cnVlXG4vLyAvLyAgICAgICAgICAgICAgICAgICAgICAgICBtYXAgPSB0cnVlO1xuLy8gLy8gICAgICAgICAgICAgICAgICAgICAgICAgbm9Mb29wKCk7XG4vLyAvLyAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbi8vIC8vICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbi8vIC8vICAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbFJlc3RhcnQgPSBzdGFjay5wb3AoKTtcbi8vIC8vICAgICAgICAgICAgICAgICAgICAgfVxuLy8gLy8gICAgICAgICAgICAgICAgIH1cbi8vIC8vICAgICAgICAgICAgICAgICBjdXJyZW50ID0gcG90ZW50aWFsUmVzdGFydDtcbi8vIC8vICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhjdXJyZW50KVxuLy8gLy8gICAgICAgICAvLyB9IGVsc2UgaWYoYWxsVmlzaXRlZCkge1xuLy8gLy8gICAgICAgICAvLyAgICAgbm9Mb29wKCk7XG4vLyAvLyAgICAgICAgIH1cblxuXG4vLyAvLyAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JpZC5sZW5ndGg7IGkrKykge1xuLy8gLy8gICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBncmlkW2ldLmxlbmd0aDsgaisrKSB7XG4vLyAvLyAgICAgICAgICAgICAgICAgZ3JpZFtpXVtqXS5yZW5kZXIoKTtcbi8vIC8vICAgICAgICAgICAgIH1cbi8vIC8vICAgICAgICAgfVxuXG4vLyAvLyAgICAgICAgIGdhbWUudXNlclJlbmRlcigpO1xuLy8gLy8gICAgIH0gZWxzZSBpZihtYXAgJiYgIWdhbWVFbmQpe1xuLy8gLy8gICAgICAgICAvLyBsb29wKClcbi8vIC8vICAgICAgICAgY29uc29sZS5sb2coXCJoaVwiKVxuLy8gLy8gICAgICAgICBnYW1lLnVzZXJSZW5kZXIoKTtcbi8vIC8vICAgICAgICAgLy8gZ2FtZS51c2VyTW92ZSgpO1xuLy8gLy8gICAgICAgICBrZXlQcmVzc2VkKCk7XG5cbi8vIC8vICAgICB9XG5cbi8vIC8vICAgICAvLyBjdXJyZW50LmhpZ2hsaWdodCgpO1xuXG4vLyAvLyAgICAgZnVuY3Rpb24ga2V5UHJlc3NlZCgpe1xuLy8gLy8gICAgICAgICAvLyBsb29wKCk7XG4vLyAvLyAgICAgICAgIGdhbWUudXNlck1vdmUoKTtcbi8vIC8vICAgICAgICAgLy8gbG9vcCgpICAgICAgICBcbi8vIC8vICAgICAgICAgcmV0dXJuIGZhbHNlO1xuLy8gLy8gICAgIH1cblxuLy8gLy8gICAgIGtleVByZXNzZWQoKTtcblxuLy8gLy8gICAgIC8vIHVzZXIucmVuZGVyKCk7XG5cblxuXG4vLyAvLyAgICAgLy8gcmVkcmF3KCk7XG5cbi8vIC8vICAgICAvLyB3aGlsZSAoIWdhbWUuZW5kKCkpe1xuLy8gLy8gICAgIC8vICAgICBnYW1lLnVzZXJNb3ZlKClcbi8vIC8vICAgICAvLyB9XG5cbi8vIC8vIH1cblxuLy8gLy8gLy8gZnVuY3Rpb24gQ2VsbChyb3csIGNvbCkge1xuLy8gLy8gLy8gICAgIHRoaXMucm93ID0gcm93O1xuLy8gLy8gLy8gICAgIHRoaXMuY29sID0gY29sO1xuLy8gLy8gLy8gICAgIHRoaXMud2FsbHMgPSBbbmV3IFdhbGwoKSwgbmV3IFdhbGwoKSwgbmV3IFdhbGwoKSwgbmV3IFdhbGwoKV07XG4vLyAvLyAvLyAgICAgdGhpcy52aXNpdGVkID0gZmFsc2U7XG5cbi8vIC8vIC8vICAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbi8vIC8vIC8vICAgICAgICAgY29uc3Qgc3RhcnRSb3cgPSB0aGlzLnJvdyAqIDQwO1xuLy8gLy8gLy8gICAgICAgICBjb25zdCBzdGFydENvbCA9IHRoaXMuY29sICogNDA7XG5cbi8vIC8vIC8vICAgICAgICAgLy8geCwgeSwgd2lkdGgsIGhlaWdodFxuLy8gLy8gLy8gICAgICAgICAvLyByZWN0KHN0YXJ0WCwgc3RhcnRZLCA0MCwgNDApXG4vLyAvLyAvLyAgICAgICAgIC8vIG5vRmlsbCgpO1xuLy8gLy8gLy8gICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy53YWxscy5sZW5ndGg7IGkrKyl7XG4vLyAvLyAvLyAgICAgICAgICAgICB0aGlzLndhbGxzW2ldLnJlbmRlcihpLCBzdGFydFJvdywgc3RhcnRDb2wpO1xuLy8gLy8gLy8gICAgICAgICB9XG5cbi8vIC8vIC8vICAgICAgICAgaWYodGhpcy52aXNpdGVkKXtcbi8vIC8vIC8vICAgICAgICAgICAgIHJlY3Qoc3RhcnRSb3csIHN0YXJ0Q29sLCA0MCwgNDApXG4vLyAvLyAvLyAgICAgICAgICAgICBmaWxsKFwiZ3JlZW5cIik7XG4vLyAvLyAvLyAgICAgICAgIH1cblxuLy8gLy8gLy8gICAgIH1cblxuLy8gLy8gLy8gICAgIHRoaXMuZ2V0TmVpZ2hib3IgPSBmdW5jdGlvbigpe1xuXG4vLyAvLyAvLyAgICAgICAgIC8vIGNvbnN0IG5laWdoYm9yc0luZGljZXMgPSBbXG4vLyAvLyAvLyAgICAgICAgIC8vICAgICBbcm93IC0gMSwgY29sXSxcbi8vIC8vIC8vICAgICAgICAgLy8gICAgIFtyb3cgKyAxLCBjb2xdLFxuLy8gLy8gLy8gICAgICAgICAvLyAgICAgW3JvdywgY29sIC0gMV0sXG4vLyAvLyAvLyAgICAgICAgIC8vICAgICBbcm93LCBjb2wgKyAxXSAgICAgICAgICAgIFxuLy8gLy8gLy8gICAgICAgICAvLyBdXG5cbi8vIC8vIC8vICAgICAgICAgY29uc3QgbmVpZ2hib3JzID0gW1xuLy8gLy8gLy8gICAgICAgICAgICAgZ3JpZFtyb3cgLSAxXVtjb2xdLFxuLy8gLy8gLy8gICAgICAgICAgICAgZ3JpZFtyb3cgKyAxXVtjb2xdLFxuLy8gLy8gLy8gICAgICAgICAgICAgZ3JpZFtyb3ddW2NvbCAtIDFdLFxuLy8gLy8gLy8gICAgICAgICAgICAgZ3JpZFtyb3ddW2NvbCArIDFdICAgICAgICAgICAgXG4vLyAvLyAvLyAgICAgICAgIF1cblxuLy8gLy8gLy8gICAgICAgICAvLyBjb25zdCBuZWlnaGJvcnMgPSBbXTtcblxuLy8gLy8gLy8gICAgICAgICAvLyBjb25zdCB2YWxpZGF0ZUlkeCA9IGZ1bmN0aW9uIChpZHhBcnIpIHtcbi8vIC8vIC8vICAgICAgICAgLy8gICAgIGlmKGlkeEFyci5ldmVyeSgoaWR4KSA9PiB7XG4vLyAvLyAvLyAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIGlkeCA8IDIwICYmIGlkeCA+PSAwfVxuLy8gLy8gLy8gICAgICAgICAvLyAgICAgICAgICkpe1xuXG4vLyAvLyAvLyAgICAgICAgIC8vICAgICAgICAgbmVpZ2hib3JzLnB1c2goaWR4QXJyKTtcbi8vIC8vIC8vICAgICAgICAgLy8gICAgIH1cbi8vIC8vIC8vICAgICAgICAgLy8gfVxuXG4vLyAvLyAvLyAgICAgICAgIC8vIGxldCB0b3AgPSBbKHJvdyAtIDEpLCBjb2xdO1xuLy8gLy8gLy8gICAgICAgICAvLyB2YWxpZGF0ZUlkeCh0b3ApO1xuLy8gLy8gLy8gICAgICAgICAvLyBsZXQgcmlnaHQgPSBbcm93LCAoY29sKzEpXTtcbi8vIC8vIC8vICAgICAgICAgLy8gdmFsaWRhdGVJZHgocmlnaHQpO1xuLy8gLy8gLy8gICAgICAgICAvLyBsZXQgYm90dG9tID0gWyhyb3cgKyAxKSwgY29sXTtcbi8vIC8vIC8vICAgICAgICAgLy8gdmFsaWRhdGVJZHgoYm90dG9tKTtcbi8vIC8vIC8vICAgICAgICAgLy8gbGV0IGxlZnQgPSBbcm93LCAoY29sIC0gMSldO1xuLy8gLy8gLy8gICAgICAgICAvLyB2YWxpZGF0ZUlkeChsZWZ0KTtcblxuLy8gLy8gLy8gICAgICAgICBjb25zb2xlLmxvZyhuZWlnaGJvcnMpXG5cbi8vIC8vIC8vICAgICAgICAgY29uc3QgdmFsaWROZWlnaGJvcnMgPSBbXTtcblxuLy8gLy8gLy8gICAgICAgICAvLyBmb3IobGV0IGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSsrKXtcbi8vIC8vIC8vICAgICAgICAgLy8gICAgIGlmICgobmVpZ2hib3JzW2ldWzBdIDwgMjAgJiYgbmVpZ2hib3JzW2ldWzBdID49IDApICYmIChuZWlnaGJvcnNbaV1bMV0gPCAyMCAmJiBuZWlnaGJvcnNbaV1bMV0gPj0gMCkpIHtcbi8vIC8vIC8vICAgICAgICAgLy8gICAgICAgICB2YWxpZE5laWdoYm9ycy5wdXNoKG5laWdoYm9yc1tpXSk7XG4vLyAvLyAvLyAgICAgICAgIC8vICAgICB9XG4vLyAvLyAvLyAgICAgICAgIC8vIH1cblxuLy8gLy8gLy8gICAgICAgICAvLyBjb25zdCB2YWxpZE5laWdoYm9ycyA9IG5laWdoYm9ycy5maWx0ZXIobmVpZ2hib3IgPT4ge1xuLy8gLy8gLy8gICAgICAgICAvLyAgICAgLy8gbGV0IHggPSBuZWlnaGJvclswXTtcbi8vIC8vIC8vICAgICAgICAgLy8gICAgIC8vIGxldCB5ID0gbmVpZ2hib3JbMV07XG5cbi8vIC8vIC8vICAgICAgICAgLy8gICAgIGlmKChuZWlnaGJvclswXSA8IDIwICYmIG5laWdoYm9yWzBdID49IDApICYmIChuZWlnaGJvclsxXSA8IDIwICYmIG5laWdoYm9yWzFdID49IDApKXtcbi8vIC8vIC8vICAgICAgICAgLy8gICAgICAgICByZXR1cm4gbmVpZ2hib3I7XG4vLyAvLyAvLyAgICAgICAgIC8vICAgICB9XG4vLyAvLyAvLyAgICAgICAgIC8vIH1cblxuLy8gLy8gLy8gICAgICAgICAvLyBjb25zdCB2YWxpZGF0ZU5laWdoYm9ycyA9IGZ1bmN0aW9uKG5laWdoYm9yKSB7XG4vLyAvLyAvLyAgICAgICAgIC8vICAgICBpZighbmVpZ2hib3Ipe1xuLy8gLy8gLy8gICAgICAgICAvLyAgICAgICAgIHJldHVybiBmYWxzZTtcbi8vIC8vIC8vICAgICAgICAgLy8gICAgIH1cbi8vIC8vIC8vICAgICAgICAgLy8gICAgIC8vIGxldCB4ID0gbmVpZ2hib3JbMF07XG4vLyAvLyAvLyAgICAgICAgIC8vICAgICAvLyBsZXQgeSA9IG5laWdoYm9yWzFdO1xuXG4vLyAvLyAvLyAgICAgICAgIC8vICAgICBpZihuZWlnaGJvci5yb3cgPCAyMCB8fCBuZWlnaGJvci5yb3cgPj0wKXtcbi8vIC8vIC8vICAgICAgICAgLy8gICAgICAgICByZXR1cm4gZmFsc2U7XG4vLyAvLyAvLyAgICAgICAgIC8vICAgICB9IGVsc2UgaWYobmVpZ2hib3IuY29sIDwgMjAgfHwgbmVpZ2hib3IuY29sID49IDApe1xuLy8gLy8gLy8gICAgICAgICAvLyAgICAgICAgIHJldHVybiBmYWxzZTtcbi8vIC8vIC8vICAgICAgICAgLy8gICAgIH0gZWxzZXtcbi8vIC8vIC8vICAgICAgICAgLy8gICAgICAgICByZXR1cm4gdHJ1ZVxuLy8gLy8gLy8gICAgICAgICAvLyAgICAgfVxuXG4vLyAvLyAvLyAgICAgICAgIC8vIH1cblxuLy8gLy8gLy8gICAgICAgICAvLyBjb25zdCB2YWxpZGF0ZU5laWdoYm9ycyA9IGZ1bmN0aW9uKG5laWdoYm9yKXtcbi8vIC8vIC8vICAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKG5laWdoYm9yKVxuLy8gLy8gLy8gICAgICAgICAvLyAgICAgbmVpZ2hib3Jcbi8vIC8vIC8vICAgICAgICAgLy8gfVxuXG4vLyAvLyAvLyAgICAgICAgIC8vIGNvbnN0IHZhbGlkTmVpZ2hib3JzID0gbmVpZ2hib3JzLmZpbHRlcih2YWxpZGF0ZU5laWdoYm9ycyk7XG5cbi8vIC8vIC8vICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7IGkrKyl7XG4vLyAvLyAvLyAgICAgICAgICAgICBpZihuZWlnaGJvcnNbaV0gJiYgIShuZWlnaGJvcnNbaV0udmlzaXRlZCkpe1xuLy8gLy8gLy8gICAgICAgICAgICAgICAgIHZhbGlkTmVpZ2hib3JzLnB1c2gobmVpZ2hib3JzW2ldKVxuLy8gLy8gLy8gICAgICAgICAgICAgfVxuLy8gLy8gLy8gICAgICAgICB9XG5cblxuLy8gLy8gLy8gICAgICAgICBjb25zb2xlLmxvZyhcInZhbGlkXCIpIFxuLy8gLy8gLy8gICAgICAgICBjb25zb2xlLmxvZyh2YWxpZE5laWdoYm9ycylcblxuLy8gLy8gLy8gICAgICAgICBsZXQgbmV4dENlbGw7XG5cbi8vIC8vIC8vICAgICAgICAgaWYodmFsaWROZWlnaGJvcnMubGVuZ3RoID4gMCl7XG4vLyAvLyAvLyAgICAgICAgICAgICBuZXh0Q2VsbCA9IHRoaXMuY2hvb3NlUmFuZG9tTmVpZ2hib3IodmFsaWROZWlnaGJvcnMpO1xuLy8gLy8gLy8gICAgICAgICAgICAgcmV0dXJuIG5leHRDZWxsO1xuLy8gLy8gLy8gICAgICAgICB9XG4vLyAvLyAvLyAgICAgICAgIC8vIGxldCBuZXh0Q2VsbCA9IFxuXG4vLyAvLyAvLyAgICAgICAgIC8vIC8vbmVlZCB0byBjaGVjayBpZiBuZXh0Q2VsbCBpcyB0cnVlIGJjIGl0IGNvdWxkIGJlIHVuZGVmaW5lZCBhdCB0aGUgZWRnZXNcbi8vIC8vIC8vICAgICAgICAgLy8gd2hpbGUobmV4dENlbGwgJiYgbmV4dENlbGwudmlzaXRlZCl7XG4vLyAvLyAvLyAgICAgICAgICAgICAvLyAgICAgbmV4dENlbGwgPSB0aGlzLmNob29zZVJhbmRvbU5laWdoYm9yKG5laWdoYm9ycylcblxuLy8gLy8gLy8gICAgICAgICAgICAgLy8gICAgIGlmKG5leHRDZWxsICYmICFuZXh0Q2VsbC52aXNpdGVkKXtcbi8vIC8vIC8vICAgICAgICAgICAgICAgICAvLyAgICAgICAgIHJldHVybiBuZXh0Q2VsbFxuLy8gLy8gLy8gICAgICAgICAgICAgICAgIC8vICAgICB9XG4vLyAvLyAvLyAgICAgICAgICAgICAgICAgLy8gfVxuXG4vLyAvLyAvLyAgICAgICAgICAgICAgICAgLy8gaWYgKG5leHRDZWxsKSB7XG4vLyAvLyAvLyAgICAgICAgICAgICAgICAgICAgIC8vICAgICByZWN0KHN0YXJ0Um93LCBzdGFydENvbCwgNDAsIDQwKVxuLy8gLy8gLy8gICAgICAgICAgICAgICAgICAgICAvLyAgICAgZmlsbChcInB1cnBsZVwiKTtcbi8vIC8vIC8vICAgICAgICAgICAgICAgICAgICAgLy8gfVxuLy8gLy8gLy8gICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhuZXh0Q2VsbClcbi8vIC8vIC8vICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIG5leHRDZWxsO1xuXG4vLyAvLyAvLyAgICAgfVxuXG4vLyAvLyAvLyAgICAgdGhpcy5jaG9vc2VSYW5kb21OZWlnaGJvciA9IGZ1bmN0aW9uKHZhbGlkTmVpZ2hib3JzKSB7XG4vLyAvLyAvLyAgICAgICAgcmV0dXJuIHZhbGlkTmVpZ2hib3JzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHZhbGlkTmVpZ2hib3JzLmxlbmd0aCldIFxuLy8gLy8gLy8gICAgIH1cblxuLy8gLy8gLy8gfVxuXG4vLyAvLyAvLyBmdW5jdGlvbiBXYWxsKCl7XG4vLyAvLyAvLyAgICAgdGhpcy5wcmVzZW50ID0gdHJ1ZTtcblxuLy8gLy8gLy8gICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24oaSwgeCwgeSl7XG4vLyAvLyAvLyAgICAgICAgIHN0cm9rZSgyNTUpO1xuLy8gLy8gLy8gICAgICAgICBzd2l0Y2goaSl7XG4vLyAvLyAvLyAgICAgICAgICAgICBjYXNlIDA6IFxuLy8gLy8gLy8gICAgICAgICAgICAgICAgIGxpbmUoeCwgeSwgeCwgeSArIDQwKVxuLy8gLy8gLy8gICAgICAgICAgICAgY2FzZSAxOlxuLy8gLy8gLy8gICAgICAgICAgICAgICAgIGxpbmUoeCwgeSArIDQwLCB4ICsgNDAsIHkgKyA0MClcbi8vIC8vIC8vICAgICAgICAgICAgIGNhc2UgMjogXG4vLyAvLyAvLyAgICAgICAgICAgICAgICAgbGluZSh4ICsgNDAsIHkgKyA0MCwgeCArIDQwLCB5KVxuLy8gLy8gLy8gICAgICAgICAgICAgY2FzZSAzOlxuLy8gLy8gLy8gICAgICAgICAgICAgICAgIGxpbmUoeCArIDQwLCB5LCB4LCB5KVxuLy8gLy8gLy8gICAgICAgICB9XG4vLyAvLyAvLyAgICAgfVxuLy8gLy8gLy8gfVxuXG4vLyAvLyB3aW5kb3cuc2V0dXAgPSBzZXR1cDtcblxuLy8gLy8gd2luZG93LmRyYXcgPSBkcmF3O1xuXG4vLyAvLyAvL3A1IGNhbm5vdCBmaW5kIHRoZSBmdW5jdGlvbnMsIFxuLy8gLy8gLy9zbyB3ZSBuZWVkIHRvIHNldCBpdCB0byB0aGUgd2luZG93IHNvIHRoZSBmeCBjYW4gYmUgZm91bmQgIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./index.js\n");

/***/ }),

/***/ "./maze.js":
/*!*****************!*\
  !*** ./maze.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function Maze(current, grid, game) {\n  this.current = current;\n  this.grid = grid;\n  this.stack = [];\n  // this.complete = false;\n  this.game = game;\n\n\n  this.draw = function() {\n    background(51);\n\n    // if (!map && !gameEnd) {\n    if (this.current) {\n      this.current.visited = true;\n      // this.current.highlight();\n      this.stack.push(this.current);\n    }\n\n    // let nextCell = this.current.getNextCell(this.current.row, this.current.col);\n    let nextCell = this.current.getNeighbor();\n\n    // console.log(\"nextcell\")\n    // console.log(nextCell);\n\n    removeWalls = function(current, next, grid) {\n      const changeX = current.row - next.row;\n      const changeY = current.col - next.col;\n\n      // current.walls.forEach(wall => wall.present = false)\n\n      switch (changeX) {\n        case 1:\n          current.walls[0].present = false;\n          next.walls[2].present = false;\n          break;\n        case -1:\n          current.walls[2].present = false;\n          next.walls[0].present = false;\n          break;\n      }\n\n      switch (changeY) {\n        case 1:\n          current.walls[3].present = false;\n          next.walls[1].present = false;\n          break;\n        case -1:\n          current.walls[1].present = false;\n          next.walls[3].present = false;\n          break;\n      }\n\n      // const firstRow = grid[0];\n      // const lastRow = grid[19];\n\n      // for (let i = 0; i < firstRow.length; i++) {\n      //     firstRow[i].walls[3].present = true\n      // }\n\n      // for (let i = 0; i < lastRow.length; i++) {\n      //     lastRow[i].walls[1].present = true\n      // }\n\n      // const firstCol = grid.filter((cell) => {\n      //     return cell.col === 0\n      // })\n\n      // const lastCol = grid.filter((cell) => {\n      //     return cell.col === 19\n      // })\n\n      // for (let i = 0; i < firstCol.length; i++) {\n      //     firstCol[i].walls[2].present = true;\n      // }\n\n      // for (let i = 0; i < lastCol.length; i++) {\n      //     lastCol[i].walls[0].present = true;\n      // }\n    };\n\n    // openWalls = function(cell){\n    //   console.log(\"open\")\n    //   // cell.walls.forEach((wall) => {\n    //   //   return wall.present = true;\n    //   // })\n    //   // for(let i = 0; i < cell.walls.length; i++){\n    //   //   cell.walls[i] = true;\n    //   // }\n    //   debugger\n    //   cell.makeWallsFalse();\n    // }\n\n    // addWalls = function(cell){\n    //   // console.log(\"open\")\n    //   // cell.walls.forEach((wall) => {\n    //   //   return wall.present = true;\n    //   // })\n    //   // for(let i = 0; i < cell.walls.length; i++){\n    //   //   cell.walls[i] = true;\n    //   // }\n    //   cell.makeBlack();\n    //   // cell.makeWallsFalse();\n    // }\n\n    // rerenderAtEnd = function(){\n    //   for (let i = 0; i < grid.length; i++) {\n    //     for (let j = 0; j < grid[i].length; j++) {\n    //       grid[i][j].render();\n    //     }\n    //   }\n    // }\n\n    if (nextCell) {\n      nextCell.visited = true;\n      removeWalls(this.current, nextCell, grid);\n      this.current = nextCell;\n      // console.log(\"this.stack\")\n      // console.log(this.stack);\n    } else if (this.stack.length > 0) {\n      potentialRestart = this.stack.pop();\n      while (potentialRestart && !potentialRestart.getNeighbor()) {\n        if (!this.stack.length) {\n          potentialRestart.visited = true;\n          // potentialRestart.render();\n          // openWalls(potentialRestart);\n          // potentialRestartNeighbor = grid[potentialRestart.row + 1][potentialRestart.col]\n          // removeWalls(potentialRestart, potentialRestartNeighbor, grid);\n          this.map = true;\n          break;\n\n          // noLoop();\n          // break;\n        } else {\n          potentialRestart = this.stack.pop();\n          // potentialRestart.render();\n\n          // if(potentialRestart.row < 18){\n          //   potentialRestartNeighbor = grid[potentialRestart.row + 1][potentialRestart.col]\n          // } else {\n          //   potentialRestartNeighbor = grid[potentialRestart.row][potentialRestart.col]\n          // }\n          // addWalls(potentialRestart);\n        }\n      }\n      this.current = potentialRestart;\n      // console.log(this.this.current)\n      // } else if(allVisited) {\n      //     noLoop();\n    }\n\n    for (let i = 0; i < grid.length; i++) {\n      for (let j = 0; j < grid[i].length; j++) {\n        grid[i][j].render();\n      }\n    }\n    //     game.start();\n    // } else if (map && !gameEnd) {\n    //     game.start();\n    //     game.userMove();\n    //     // keyPressed();\n\n    // }\n\n    // // this.current.highlight();\n\n    // function keyPressed() {\n    //     game.userMove();\n    //     // redraw();\n    //     return false;\n    // }\n\n    // keyPressed();\n\n    // user.render();\n\n    // redraw();\n\n    // while (!game.end()){\n    //     game.userMove()\n    // }\n\n  };\n\n  // this.mapComplete = function(){\n  //     return this.map;\n  // }\n\n  \n\n}\n\nmodule.exports = Maze;\n\n// window.draw = draw;\n\n// class Maze{\n//     constructor(current){\n//         this.current = current;\n//     }\n\n//     draw(){\n//         background(51)\n\n//         // if (!map && !gameEnd) {\n//             if (this.current) {\n//                 this.current.visited = true;\n//                 // this.current.highlight();\n//                 stack.push(this.current);\n//             }\n\n//             // let nextCell = this.current.getNextCell(this.current.row, this.current.col);\n//             let nextCell = this.current.getNeighbor();\n\n//             // console.log(\"nextcell\")\n//             // console.log(nextCell);\n\n//             removeWalls = function (this.current, next, grid) {\n//                 const changeX = this.current.row - next.row;\n//                 const changeY = this.current.col - next.col;\n\n//                 // this.current.walls.forEach(wall => wall.present = false)\n\n//                 switch (changeX) {\n//                     case 1:\n//                         this.current.walls[0].present = false;\n//                         next.walls[2].present = false;\n//                         break;\n//                     case -1:\n//                         this.current.walls[2].present = false;\n//                         next.walls[0].present = false;\n//                         break;\n//                 }\n\n//                 switch (changeY) {\n//                     case 1:\n//                         this.current.walls[3].present = false;\n//                         next.walls[1].present = false;\n//                         break;\n//                     case -1:\n//                         this.current.walls[1].present = false;\n//                         next.walls[3].present = false;\n//                         break;\n//                 }\n\n//                 // const firstRow = grid[0];\n//                 // const lastRow = grid[19];\n\n//                 // for (let i = 0; i < firstRow.length; i++) {\n//                 //     firstRow[i].walls[3].present = true\n//                 // }\n\n//                 // for (let i = 0; i < lastRow.length; i++) {\n//                 //     lastRow[i].walls[1].present = true\n//                 // }\n\n//                 // const firstCol = grid.filter((cell) => {\n//                 //     return cell.col === 0\n//                 // })\n\n//                 // const lastCol = grid.filter((cell) => {\n//                 //     return cell.col === 19\n//                 // })\n\n//                 // for (let i = 0; i < firstCol.length; i++) {\n//                 //     firstCol[i].walls[2].present = true;\n//                 // }\n\n//                 // for (let i = 0; i < lastCol.length; i++) {\n//                 //     lastCol[i].walls[0].present = true;\n//                 // }\n//             }\n\n//             if (nextCell) {\n//                 nextCell.visited = true;\n//                 this.removeWalls(this.current, nextCell, grid);\n//                 this.current = nextCell;\n//                 // console.log(\"stack\")\n//                 // console.log(stack);\n//             } else if (stack.length > 0) {\n//                 potentialRestart = stack.pop()\n//                 while (potentialRestart && !potentialRestart.getNeighbor()) {\n//                     if (!stack.length) {\n//                         potentialRestart.visited = true\n//                         map = true;\n//                         // noLoop();\n//                         // break;\n//                     } else {\n//                         potentialRestart = stack.pop();\n//                     }\n//                 }\n//                 this.current = potentialRestart;\n//                 // console.log(this.current)\n//                 // } else if(allVisited) {\n//                 //     noLoop();\n//             }\n\n//             for (let i = 0; i < grid.length; i++) {\n//                 for (let j = 0; j < grid[i].length; j++) {\n//                     grid[i][j].render();\n//                 }\n//             }\n\n//         //     game.start();\n//         // } else if (map && !gameEnd) {\n//         //     game.start();\n//         //     game.userMove();\n//         //     // keyPressed();\n\n//         // }\n\n//         // // current.highlight();\n\n//         // function keyPressed() {\n//         //     game.userMove();\n//         //     // redraw();\n//         //     return false;\n//         // }\n\n//         // keyPressed();\n\n//     // user.render();\n\n//     // redraw();\n\n//     // while (!game.end()){\n//     //     game.userMove()\n//     // }\n\n//     }\n\n// }\n\n// module.exports = Maze;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9tYXplLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbWF6ZS5qcz8zZWI1Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIE1hemUoY3VycmVudCwgZ3JpZCwgZ2FtZSkge1xuICB0aGlzLmN1cnJlbnQgPSBjdXJyZW50O1xuICB0aGlzLmdyaWQgPSBncmlkO1xuICB0aGlzLnN0YWNrID0gW107XG4gIC8vIHRoaXMuY29tcGxldGUgPSBmYWxzZTtcbiAgdGhpcy5nYW1lID0gZ2FtZTtcblxuXG4gIHRoaXMuZHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgIGJhY2tncm91bmQoNTEpO1xuXG4gICAgLy8gaWYgKCFtYXAgJiYgIWdhbWVFbmQpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50KSB7XG4gICAgICB0aGlzLmN1cnJlbnQudmlzaXRlZCA9IHRydWU7XG4gICAgICAvLyB0aGlzLmN1cnJlbnQuaGlnaGxpZ2h0KCk7XG4gICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5jdXJyZW50KTtcbiAgICB9XG5cbiAgICAvLyBsZXQgbmV4dENlbGwgPSB0aGlzLmN1cnJlbnQuZ2V0TmV4dENlbGwodGhpcy5jdXJyZW50LnJvdywgdGhpcy5jdXJyZW50LmNvbCk7XG4gICAgbGV0IG5leHRDZWxsID0gdGhpcy5jdXJyZW50LmdldE5laWdoYm9yKCk7XG5cbiAgICAvLyBjb25zb2xlLmxvZyhcIm5leHRjZWxsXCIpXG4gICAgLy8gY29uc29sZS5sb2cobmV4dENlbGwpO1xuXG4gICAgcmVtb3ZlV2FsbHMgPSBmdW5jdGlvbihjdXJyZW50LCBuZXh0LCBncmlkKSB7XG4gICAgICBjb25zdCBjaGFuZ2VYID0gY3VycmVudC5yb3cgLSBuZXh0LnJvdztcbiAgICAgIGNvbnN0IGNoYW5nZVkgPSBjdXJyZW50LmNvbCAtIG5leHQuY29sO1xuXG4gICAgICAvLyBjdXJyZW50LndhbGxzLmZvckVhY2god2FsbCA9PiB3YWxsLnByZXNlbnQgPSBmYWxzZSlcblxuICAgICAgc3dpdGNoIChjaGFuZ2VYKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBjdXJyZW50LndhbGxzWzBdLnByZXNlbnQgPSBmYWxzZTtcbiAgICAgICAgICBuZXh0LndhbGxzWzJdLnByZXNlbnQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICBjdXJyZW50LndhbGxzWzJdLnByZXNlbnQgPSBmYWxzZTtcbiAgICAgICAgICBuZXh0LndhbGxzWzBdLnByZXNlbnQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjaGFuZ2VZKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBjdXJyZW50LndhbGxzWzNdLnByZXNlbnQgPSBmYWxzZTtcbiAgICAgICAgICBuZXh0LndhbGxzWzFdLnByZXNlbnQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICBjdXJyZW50LndhbGxzWzFdLnByZXNlbnQgPSBmYWxzZTtcbiAgICAgICAgICBuZXh0LndhbGxzWzNdLnByZXNlbnQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gY29uc3QgZmlyc3RSb3cgPSBncmlkWzBdO1xuICAgICAgLy8gY29uc3QgbGFzdFJvdyA9IGdyaWRbMTldO1xuXG4gICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IGZpcnN0Um93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyAgICAgZmlyc3RSb3dbaV0ud2FsbHNbM10ucHJlc2VudCA9IHRydWVcbiAgICAgIC8vIH1cblxuICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0Um93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyAgICAgbGFzdFJvd1tpXS53YWxsc1sxXS5wcmVzZW50ID0gdHJ1ZVxuICAgICAgLy8gfVxuXG4gICAgICAvLyBjb25zdCBmaXJzdENvbCA9IGdyaWQuZmlsdGVyKChjZWxsKSA9PiB7XG4gICAgICAvLyAgICAgcmV0dXJuIGNlbGwuY29sID09PSAwXG4gICAgICAvLyB9KVxuXG4gICAgICAvLyBjb25zdCBsYXN0Q29sID0gZ3JpZC5maWx0ZXIoKGNlbGwpID0+IHtcbiAgICAgIC8vICAgICByZXR1cm4gY2VsbC5jb2wgPT09IDE5XG4gICAgICAvLyB9KVxuXG4gICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IGZpcnN0Q29sLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyAgICAgZmlyc3RDb2xbaV0ud2FsbHNbMl0ucHJlc2VudCA9IHRydWU7XG4gICAgICAvLyB9XG5cbiAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgbGFzdENvbC5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gICAgIGxhc3RDb2xbaV0ud2FsbHNbMF0ucHJlc2VudCA9IHRydWU7XG4gICAgICAvLyB9XG4gICAgfTtcblxuICAgIC8vIG9wZW5XYWxscyA9IGZ1bmN0aW9uKGNlbGwpe1xuICAgIC8vICAgY29uc29sZS5sb2coXCJvcGVuXCIpXG4gICAgLy8gICAvLyBjZWxsLndhbGxzLmZvckVhY2goKHdhbGwpID0+IHtcbiAgICAvLyAgIC8vICAgcmV0dXJuIHdhbGwucHJlc2VudCA9IHRydWU7XG4gICAgLy8gICAvLyB9KVxuICAgIC8vICAgLy8gZm9yKGxldCBpID0gMDsgaSA8IGNlbGwud2FsbHMubGVuZ3RoOyBpKyspe1xuICAgIC8vICAgLy8gICBjZWxsLndhbGxzW2ldID0gdHJ1ZTtcbiAgICAvLyAgIC8vIH1cbiAgICAvLyAgIGRlYnVnZ2VyXG4gICAgLy8gICBjZWxsLm1ha2VXYWxsc0ZhbHNlKCk7XG4gICAgLy8gfVxuXG4gICAgLy8gYWRkV2FsbHMgPSBmdW5jdGlvbihjZWxsKXtcbiAgICAvLyAgIC8vIGNvbnNvbGUubG9nKFwib3BlblwiKVxuICAgIC8vICAgLy8gY2VsbC53YWxscy5mb3JFYWNoKCh3YWxsKSA9PiB7XG4gICAgLy8gICAvLyAgIHJldHVybiB3YWxsLnByZXNlbnQgPSB0cnVlO1xuICAgIC8vICAgLy8gfSlcbiAgICAvLyAgIC8vIGZvcihsZXQgaSA9IDA7IGkgPCBjZWxsLndhbGxzLmxlbmd0aDsgaSsrKXtcbiAgICAvLyAgIC8vICAgY2VsbC53YWxsc1tpXSA9IHRydWU7XG4gICAgLy8gICAvLyB9XG4gICAgLy8gICBjZWxsLm1ha2VCbGFjaygpO1xuICAgIC8vICAgLy8gY2VsbC5tYWtlV2FsbHNGYWxzZSgpO1xuICAgIC8vIH1cblxuICAgIC8vIHJlcmVuZGVyQXRFbmQgPSBmdW5jdGlvbigpe1xuICAgIC8vICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmlkLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gICAgIGZvciAobGV0IGogPSAwOyBqIDwgZ3JpZFtpXS5sZW5ndGg7IGorKykge1xuICAgIC8vICAgICAgIGdyaWRbaV1bal0ucmVuZGVyKCk7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgIH1cbiAgICAvLyB9XG5cbiAgICBpZiAobmV4dENlbGwpIHtcbiAgICAgIG5leHRDZWxsLnZpc2l0ZWQgPSB0cnVlO1xuICAgICAgcmVtb3ZlV2FsbHModGhpcy5jdXJyZW50LCBuZXh0Q2VsbCwgZ3JpZCk7XG4gICAgICB0aGlzLmN1cnJlbnQgPSBuZXh0Q2VsbDtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwidGhpcy5zdGFja1wiKVxuICAgICAgLy8gY29uc29sZS5sb2codGhpcy5zdGFjayk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHBvdGVudGlhbFJlc3RhcnQgPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgd2hpbGUgKHBvdGVudGlhbFJlc3RhcnQgJiYgIXBvdGVudGlhbFJlc3RhcnQuZ2V0TmVpZ2hib3IoKSkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgcG90ZW50aWFsUmVzdGFydC52aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAvLyBwb3RlbnRpYWxSZXN0YXJ0LnJlbmRlcigpO1xuICAgICAgICAgIC8vIG9wZW5XYWxscyhwb3RlbnRpYWxSZXN0YXJ0KTtcbiAgICAgICAgICAvLyBwb3RlbnRpYWxSZXN0YXJ0TmVpZ2hib3IgPSBncmlkW3BvdGVudGlhbFJlc3RhcnQucm93ICsgMV1bcG90ZW50aWFsUmVzdGFydC5jb2xdXG4gICAgICAgICAgLy8gcmVtb3ZlV2FsbHMocG90ZW50aWFsUmVzdGFydCwgcG90ZW50aWFsUmVzdGFydE5laWdoYm9yLCBncmlkKTtcbiAgICAgICAgICB0aGlzLm1hcCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBub0xvb3AoKTtcbiAgICAgICAgICAvLyBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb3RlbnRpYWxSZXN0YXJ0ID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICAvLyBwb3RlbnRpYWxSZXN0YXJ0LnJlbmRlcigpO1xuXG4gICAgICAgICAgLy8gaWYocG90ZW50aWFsUmVzdGFydC5yb3cgPCAxOCl7XG4gICAgICAgICAgLy8gICBwb3RlbnRpYWxSZXN0YXJ0TmVpZ2hib3IgPSBncmlkW3BvdGVudGlhbFJlc3RhcnQucm93ICsgMV1bcG90ZW50aWFsUmVzdGFydC5jb2xdXG4gICAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgICAvLyAgIHBvdGVudGlhbFJlc3RhcnROZWlnaGJvciA9IGdyaWRbcG90ZW50aWFsUmVzdGFydC5yb3ddW3BvdGVudGlhbFJlc3RhcnQuY29sXVxuICAgICAgICAgIC8vIH1cbiAgICAgICAgICAvLyBhZGRXYWxscyhwb3RlbnRpYWxSZXN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5jdXJyZW50ID0gcG90ZW50aWFsUmVzdGFydDtcbiAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMudGhpcy5jdXJyZW50KVxuICAgICAgLy8gfSBlbHNlIGlmKGFsbFZpc2l0ZWQpIHtcbiAgICAgIC8vICAgICBub0xvb3AoKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyaWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZ3JpZFtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICBncmlkW2ldW2pdLnJlbmRlcigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyAgICAgZ2FtZS5zdGFydCgpO1xuICAgIC8vIH0gZWxzZSBpZiAobWFwICYmICFnYW1lRW5kKSB7XG4gICAgLy8gICAgIGdhbWUuc3RhcnQoKTtcbiAgICAvLyAgICAgZ2FtZS51c2VyTW92ZSgpO1xuICAgIC8vICAgICAvLyBrZXlQcmVzc2VkKCk7XG5cbiAgICAvLyB9XG5cbiAgICAvLyAvLyB0aGlzLmN1cnJlbnQuaGlnaGxpZ2h0KCk7XG5cbiAgICAvLyBmdW5jdGlvbiBrZXlQcmVzc2VkKCkge1xuICAgIC8vICAgICBnYW1lLnVzZXJNb3ZlKCk7XG4gICAgLy8gICAgIC8vIHJlZHJhdygpO1xuICAgIC8vICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gfVxuXG4gICAgLy8ga2V5UHJlc3NlZCgpO1xuXG4gICAgLy8gdXNlci5yZW5kZXIoKTtcblxuICAgIC8vIHJlZHJhdygpO1xuXG4gICAgLy8gd2hpbGUgKCFnYW1lLmVuZCgpKXtcbiAgICAvLyAgICAgZ2FtZS51c2VyTW92ZSgpXG4gICAgLy8gfVxuXG4gIH07XG5cbiAgLy8gdGhpcy5tYXBDb21wbGV0ZSA9IGZ1bmN0aW9uKCl7XG4gIC8vICAgICByZXR1cm4gdGhpcy5tYXA7XG4gIC8vIH1cblxuICBcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hemU7XG5cbi8vIHdpbmRvdy5kcmF3ID0gZHJhdztcblxuLy8gY2xhc3MgTWF6ZXtcbi8vICAgICBjb25zdHJ1Y3RvcihjdXJyZW50KXtcbi8vICAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcbi8vICAgICB9XG5cbi8vICAgICBkcmF3KCl7XG4vLyAgICAgICAgIGJhY2tncm91bmQoNTEpXG5cbi8vICAgICAgICAgLy8gaWYgKCFtYXAgJiYgIWdhbWVFbmQpIHtcbi8vICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQpIHtcbi8vICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQudmlzaXRlZCA9IHRydWU7XG4vLyAgICAgICAgICAgICAgICAgLy8gdGhpcy5jdXJyZW50LmhpZ2hsaWdodCgpO1xuLy8gICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5jdXJyZW50KTtcbi8vICAgICAgICAgICAgIH1cblxuLy8gICAgICAgICAgICAgLy8gbGV0IG5leHRDZWxsID0gdGhpcy5jdXJyZW50LmdldE5leHRDZWxsKHRoaXMuY3VycmVudC5yb3csIHRoaXMuY3VycmVudC5jb2wpO1xuLy8gICAgICAgICAgICAgbGV0IG5leHRDZWxsID0gdGhpcy5jdXJyZW50LmdldE5laWdoYm9yKCk7XG5cbi8vICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwibmV4dGNlbGxcIilcbi8vICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG5leHRDZWxsKTtcblxuLy8gICAgICAgICAgICAgcmVtb3ZlV2FsbHMgPSBmdW5jdGlvbiAodGhpcy5jdXJyZW50LCBuZXh0LCBncmlkKSB7XG4vLyAgICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlWCA9IHRoaXMuY3VycmVudC5yb3cgLSBuZXh0LnJvdztcbi8vICAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VZID0gdGhpcy5jdXJyZW50LmNvbCAtIG5leHQuY29sO1xuXG4vLyAgICAgICAgICAgICAgICAgLy8gdGhpcy5jdXJyZW50LndhbGxzLmZvckVhY2god2FsbCA9PiB3YWxsLnByZXNlbnQgPSBmYWxzZSlcblxuLy8gICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhbmdlWCkge1xuLy8gICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQud2FsbHNbMF0ucHJlc2VudCA9IGZhbHNlO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC53YWxsc1syXS5wcmVzZW50ID0gZmFsc2U7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbi8vICAgICAgICAgICAgICAgICAgICAgY2FzZSAtMTpcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC53YWxsc1syXS5wcmVzZW50ID0gZmFsc2U7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0LndhbGxzWzBdLnByZXNlbnQgPSBmYWxzZTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuLy8gICAgICAgICAgICAgICAgIH1cblxuLy8gICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhbmdlWSkge1xuLy8gICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQud2FsbHNbM10ucHJlc2VudCA9IGZhbHNlO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC53YWxsc1sxXS5wcmVzZW50ID0gZmFsc2U7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbi8vICAgICAgICAgICAgICAgICAgICAgY2FzZSAtMTpcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC53YWxsc1sxXS5wcmVzZW50ID0gZmFsc2U7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0LndhbGxzWzNdLnByZXNlbnQgPSBmYWxzZTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuLy8gICAgICAgICAgICAgICAgIH1cblxuLy8gICAgICAgICAgICAgICAgIC8vIGNvbnN0IGZpcnN0Um93ID0gZ3JpZFswXTtcbi8vICAgICAgICAgICAgICAgICAvLyBjb25zdCBsYXN0Um93ID0gZ3JpZFsxOV07XG5cbi8vICAgICAgICAgICAgICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IGZpcnN0Um93Lmxlbmd0aDsgaSsrKSB7XG4vLyAgICAgICAgICAgICAgICAgLy8gICAgIGZpcnN0Um93W2ldLndhbGxzWzNdLnByZXNlbnQgPSB0cnVlXG4vLyAgICAgICAgICAgICAgICAgLy8gfVxuXG4vLyAgICAgICAgICAgICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0Um93Lmxlbmd0aDsgaSsrKSB7XG4vLyAgICAgICAgICAgICAgICAgLy8gICAgIGxhc3RSb3dbaV0ud2FsbHNbMV0ucHJlc2VudCA9IHRydWVcbi8vICAgICAgICAgICAgICAgICAvLyB9XG5cbi8vICAgICAgICAgICAgICAgICAvLyBjb25zdCBmaXJzdENvbCA9IGdyaWQuZmlsdGVyKChjZWxsKSA9PiB7XG4vLyAgICAgICAgICAgICAgICAgLy8gICAgIHJldHVybiBjZWxsLmNvbCA9PT0gMFxuLy8gICAgICAgICAgICAgICAgIC8vIH0pXG5cbi8vICAgICAgICAgICAgICAgICAvLyBjb25zdCBsYXN0Q29sID0gZ3JpZC5maWx0ZXIoKGNlbGwpID0+IHtcbi8vICAgICAgICAgICAgICAgICAvLyAgICAgcmV0dXJuIGNlbGwuY29sID09PSAxOVxuLy8gICAgICAgICAgICAgICAgIC8vIH0pXG5cbi8vICAgICAgICAgICAgICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IGZpcnN0Q29sLmxlbmd0aDsgaSsrKSB7XG4vLyAgICAgICAgICAgICAgICAgLy8gICAgIGZpcnN0Q29sW2ldLndhbGxzWzJdLnByZXNlbnQgPSB0cnVlO1xuLy8gICAgICAgICAgICAgICAgIC8vIH1cblxuLy8gICAgICAgICAgICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgbGFzdENvbC5sZW5ndGg7IGkrKykge1xuLy8gICAgICAgICAgICAgICAgIC8vICAgICBsYXN0Q29sW2ldLndhbGxzWzBdLnByZXNlbnQgPSB0cnVlO1xuLy8gICAgICAgICAgICAgICAgIC8vIH1cbi8vICAgICAgICAgICAgIH1cblxuLy8gICAgICAgICAgICAgaWYgKG5leHRDZWxsKSB7XG4vLyAgICAgICAgICAgICAgICAgbmV4dENlbGwudmlzaXRlZCA9IHRydWU7XG4vLyAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVXYWxscyh0aGlzLmN1cnJlbnQsIG5leHRDZWxsLCBncmlkKTtcbi8vICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBuZXh0Q2VsbDtcbi8vICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInN0YWNrXCIpXG4vLyAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coc3RhY2spO1xuLy8gICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XG4vLyAgICAgICAgICAgICAgICAgcG90ZW50aWFsUmVzdGFydCA9IHN0YWNrLnBvcCgpXG4vLyAgICAgICAgICAgICAgICAgd2hpbGUgKHBvdGVudGlhbFJlc3RhcnQgJiYgIXBvdGVudGlhbFJlc3RhcnQuZ2V0TmVpZ2hib3IoKSkge1xuLy8gICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YWNrLmxlbmd0aCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsUmVzdGFydC52aXNpdGVkID0gdHJ1ZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgbWFwID0gdHJ1ZTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vTG9vcCgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnJlYWs7XG4vLyAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxSZXN0YXJ0ID0gc3RhY2sucG9wKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gcG90ZW50aWFsUmVzdGFydDtcbi8vICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmN1cnJlbnQpXG4vLyAgICAgICAgICAgICAgICAgLy8gfSBlbHNlIGlmKGFsbFZpc2l0ZWQpIHtcbi8vICAgICAgICAgICAgICAgICAvLyAgICAgbm9Mb29wKCk7XG4vLyAgICAgICAgICAgICB9XG5cbi8vICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JpZC5sZW5ndGg7IGkrKykge1xuLy8gICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZ3JpZFtpXS5sZW5ndGg7IGorKykge1xuLy8gICAgICAgICAgICAgICAgICAgICBncmlkW2ldW2pdLnJlbmRlcigpO1xuLy8gICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIH1cblxuLy8gICAgICAgICAvLyAgICAgZ2FtZS5zdGFydCgpO1xuLy8gICAgICAgICAvLyB9IGVsc2UgaWYgKG1hcCAmJiAhZ2FtZUVuZCkge1xuLy8gICAgICAgICAvLyAgICAgZ2FtZS5zdGFydCgpO1xuLy8gICAgICAgICAvLyAgICAgZ2FtZS51c2VyTW92ZSgpO1xuLy8gICAgICAgICAvLyAgICAgLy8ga2V5UHJlc3NlZCgpO1xuXG4vLyAgICAgICAgIC8vIH1cblxuLy8gICAgICAgICAvLyAvLyBjdXJyZW50LmhpZ2hsaWdodCgpO1xuXG4vLyAgICAgICAgIC8vIGZ1bmN0aW9uIGtleVByZXNzZWQoKSB7XG4vLyAgICAgICAgIC8vICAgICBnYW1lLnVzZXJNb3ZlKCk7XG4vLyAgICAgICAgIC8vICAgICAvLyByZWRyYXcoKTtcbi8vICAgICAgICAgLy8gICAgIHJldHVybiBmYWxzZTtcbi8vICAgICAgICAgLy8gfVxuXG4vLyAgICAgICAgIC8vIGtleVByZXNzZWQoKTtcblxuLy8gICAgIC8vIHVzZXIucmVuZGVyKCk7XG5cbi8vICAgICAvLyByZWRyYXcoKTtcblxuLy8gICAgIC8vIHdoaWxlICghZ2FtZS5lbmQoKSl7XG4vLyAgICAgLy8gICAgIGdhbWUudXNlck1vdmUoKVxuLy8gICAgIC8vIH1cblxuLy8gICAgIH1cblxuLy8gfVxuXG4vLyBtb2R1bGUuZXhwb3J0cyA9IE1hemU7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./maze.js\n");

/***/ }),

/***/ "./user.js":
/*!*****************!*\
  !*** ./user.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function User(grid) {\n    this.row = 19;\n    this.col = 19;\n    this.radius = 10;\n    this.pos = [0, 0];\n    this.gridPos = [0, 0];\n    this.grid = grid;\n\n    const colors = [\"lightcoral\", \"orange\", \"Chartreuse\", \"darkcyan\", \"darkorchid\"];\n    let currentColor = colors[Math.floor(Math.random() * colors.length)];\n\n    this.updatePos = function (posChange) {\n        switch (posChange[0]) {\n            case \"y\":\n                let updatedX = this.pos[0] + posChange[1];\n                this.pos = [updatedX, this.pos[1]];\n            case \"x\":\n                let updatedY = this.pos[1] + posChange[1];\n                this.pos = [this.pos[1], updatedY];\n        }\n    }\n\n    this.updateGridPos = function(posChange, prevPos){\n        let prev = prevPos;\n        switch (posChange[0]) {\n            case \"y\":\n                // let updatedY = prev[1] + posChange[1];\n                // this.pos = [prev[0], updatedY];\n                let updatedY = this.gridPos[1] + posChange[1];\n                this.gridPos = [this.gridPos[0], updatedY];\n                break;\n            case \"x\":\n                // let updatedX = prev[0] + posChange[1];\n                // this.pos = [updatedX, prev[1]];\n                let updatedX = this.gridPos[0] + posChange[1];\n                this.gridPos = [updatedX, this.gridPos[1]];\n                break;\n        }\n        // console.log(\"grid pos\")\n        // console.log(this.gridPos)\n    }\n\n    this.render = function () {\n        // fill(currentColor);\n        // ellipse((x+20), (y+20), 15, 15);\n        let nextCell = this.grid[this.gridPos[0]][this.gridPos[1]]\n        nextCell.renderUser(currentColor);\n    }\n\n    // this.draw = function () {\n    //     let x = this.pos[0];\n    //     let y = this.pos[1];\n    //     // const keypress = event.keyCode;\n    //     // console.log(event);\n    //     if (keyIsDown(LEFT_ARROW)) {\n    //         // console.log(this.user.pos)\n    //         this.updatePos([\"y\", -40]);\n    //         this.render(this.pos[0], this.pos[1]);\n    //     }\n\n    //     if (keyIsDown(RIGHT_ARROW)) {\n    //         this.updatePos([\"y\", 40]);\n    //         this.render(this.pos[0], this.pos[1]);\n    //     }\n\n    //     if (keyIsDown(UP_ARROW)) {\n    //         this.updatePos([\"x\", -40]);\n    //         this.render(this.pos[0], this.pos[1]);\n    //     }\n\n    //     if (keyIsDown(DOWN_ARROW)) {\n    //         this.updatePos([\"x\", 40]);\n    //         this.render(this.pos[0], this.pos[1]);\n    //     }\n    // }\n}\n\nmodule.exports = User;\n\n// const Cell = require('./cell');\n\n// function User(grid) {\n//     this.row = 19;\n//     this.col = 19;\n//     this.radius = 10;\n//     this.pos = [0, 0];\n//     this.grid = grid;\n\n//     const colors = [\"lightcoral\", \"orange\", \"Chartreuse\", \"darkcyan\", \"darkorchid\"];\n//     let currentColor = colors[Math.floor(Math.random() * colors.length)];\n\n//     this.updatePos = function (posChange, prevPos) {\n//         let prev = prevPos;\n//         console.log(\"prevpos\")\n//         console.log(prev)\n//         switch (posChange[0]) {\n//             case \"y\":\n//                 // let updatedY = prev[1] + posChange[1];\n//                 // this.pos = [prev[0], updatedY];\n//                 let updatedY = this.pos[1] + posChange[1];\n//                 this.pos = [this.pos[0], updatedY];\n//                 break;\n//             case \"x\":\n//                 // let updatedX = prev[0] + posChange[1];\n//                 // this.pos = [updatedX, prev[1]];\n//                 let updatedX = this.pos[0] + posChange[1];\n//                 this.pos = [updatedX, this.pos[1]];\n//                 break;\n//         }\n//         console.log(\"newpos\")\n//         console.log(this.pos)\n//     }\n\n//     this.display = function(){\n//         fill(currentColor);\n//         ellipse((this.pos[0] + 20), (this.pos[1] + 20), 15, 15);\n\n//     }\n\n//     this.persistantDisplay = function(x, y){\n//         fill(currentColor);\n//         ellipse((x + 20), (y + 20), 15, 15);\n//     }\n\n//     this.render = function() {\n//         let currentCell = this.grid[this.pos[0]][this.pos[1]];\n//         console.log(\"cell to rerender\")\n//         console.log(currentCell)\n//         currentCell.hasUser = true;\n//         currentCell.rerender(currentColor);\n//         this.persistantDisplay()\n//         // currentCell.display(currentCell.row, currentCell.col)\n//     }\n\n//     this.draw = function () {\n//         let x = this.pos[0];\n//         let y = this.pos[1];\n//         // const keypress = event.keyCode;\n//         // console.log(event);\n//         if (keyIsDown(LEFT_ARROW)) {\n//             // console.log(this.user.pos)\n//             this.updatePos([\"y\", -40]);\n//             this.render(this.pos[0], this.pos[1]);\n//         }\n\n//         if (keyIsDown(RIGHT_ARROW)) {\n//             this.updatePos([\"y\", 40]);\n//             this.render(this.pos[0], this.pos[1]);\n//         }\n\n//         if (keyIsDown(UP_ARROW)) {\n//             this.updatePos([\"x\", -40]);\n//             this.render(this.pos[0], this.pos[1]);\n//         }\n\n//         if (keyIsDown(DOWN_ARROW)) {\n//             this.updatePos([\"x\", 40]);\n//             this.render(this.pos[0], this.pos[1]);\n//         }\n//     }\n// }\n\n// module.exports = User;\n\n// // function User(){\n// //     this.row = 19;\n// //     this.col = 19;\n// //     this.radius = 10;\n// //     this.pos = [0, 0]\n\n// //     const colors = [\"lightcoral\", \"orange\", \"Chartreuse\", \"darkcyan\", \"darkorchid\"];\n// //     let currentColor = colors[Math.floor(Math.random() * colors.length)];\n\n\n// //     this.updatePos = function(posChange){\n// //         switch(posChange[0]){\n// //             case \"x\":\n// //                 let updatedX = this.pos[0] + posChange[1];\n// //                 this.pos = [updatedX, this.pos[1]];\n// //             case \"y\":\n// //                 let updatedY = this.pos[1] + posChange[1];\n// //                 this.pos = [this.pos[1], updatedY]; \n// //         }\n// //     }\n\n\n// //     this.render = function(x, y) {\n\n// //         fill(currentColor);\n// //         ellipse(19, 19, 15, 15);\n// //     }\n// // }\n\n// // module.exports = User;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91c2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vdXNlci5qcz9iYjMzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIFVzZXIoZ3JpZCkge1xuICAgIHRoaXMucm93ID0gMTk7XG4gICAgdGhpcy5jb2wgPSAxOTtcbiAgICB0aGlzLnJhZGl1cyA9IDEwO1xuICAgIHRoaXMucG9zID0gWzAsIDBdO1xuICAgIHRoaXMuZ3JpZFBvcyA9IFswLCAwXTtcbiAgICB0aGlzLmdyaWQgPSBncmlkO1xuXG4gICAgY29uc3QgY29sb3JzID0gW1wibGlnaHRjb3JhbFwiLCBcIm9yYW5nZVwiLCBcIkNoYXJ0cmV1c2VcIiwgXCJkYXJrY3lhblwiLCBcImRhcmtvcmNoaWRcIl07XG4gICAgbGV0IGN1cnJlbnRDb2xvciA9IGNvbG9yc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjb2xvcnMubGVuZ3RoKV07XG5cbiAgICB0aGlzLnVwZGF0ZVBvcyA9IGZ1bmN0aW9uIChwb3NDaGFuZ2UpIHtcbiAgICAgICAgc3dpdGNoIChwb3NDaGFuZ2VbMF0pIHtcbiAgICAgICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgICAgICAgbGV0IHVwZGF0ZWRYID0gdGhpcy5wb3NbMF0gKyBwb3NDaGFuZ2VbMV07XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBbdXBkYXRlZFgsIHRoaXMucG9zWzFdXTtcbiAgICAgICAgICAgIGNhc2UgXCJ4XCI6XG4gICAgICAgICAgICAgICAgbGV0IHVwZGF0ZWRZID0gdGhpcy5wb3NbMV0gKyBwb3NDaGFuZ2VbMV07XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBbdGhpcy5wb3NbMV0sIHVwZGF0ZWRZXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlR3JpZFBvcyA9IGZ1bmN0aW9uKHBvc0NoYW5nZSwgcHJldlBvcyl7XG4gICAgICAgIGxldCBwcmV2ID0gcHJldlBvcztcbiAgICAgICAgc3dpdGNoIChwb3NDaGFuZ2VbMF0pIHtcbiAgICAgICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgICAgICAgLy8gbGV0IHVwZGF0ZWRZID0gcHJldlsxXSArIHBvc0NoYW5nZVsxXTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLnBvcyA9IFtwcmV2WzBdLCB1cGRhdGVkWV07XG4gICAgICAgICAgICAgICAgbGV0IHVwZGF0ZWRZID0gdGhpcy5ncmlkUG9zWzFdICsgcG9zQ2hhbmdlWzFdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZFBvcyA9IFt0aGlzLmdyaWRQb3NbMF0sIHVwZGF0ZWRZXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ4XCI6XG4gICAgICAgICAgICAgICAgLy8gbGV0IHVwZGF0ZWRYID0gcHJldlswXSArIHBvc0NoYW5nZVsxXTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLnBvcyA9IFt1cGRhdGVkWCwgcHJldlsxXV07XG4gICAgICAgICAgICAgICAgbGV0IHVwZGF0ZWRYID0gdGhpcy5ncmlkUG9zWzBdICsgcG9zQ2hhbmdlWzFdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZFBvcyA9IFt1cGRhdGVkWCwgdGhpcy5ncmlkUG9zWzFdXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImdyaWQgcG9zXCIpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuZ3JpZFBvcylcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZmlsbChjdXJyZW50Q29sb3IpO1xuICAgICAgICAvLyBlbGxpcHNlKCh4KzIwKSwgKHkrMjApLCAxNSwgMTUpO1xuICAgICAgICBsZXQgbmV4dENlbGwgPSB0aGlzLmdyaWRbdGhpcy5ncmlkUG9zWzBdXVt0aGlzLmdyaWRQb3NbMV1dXG4gICAgICAgIG5leHRDZWxsLnJlbmRlclVzZXIoY3VycmVudENvbG9yKTtcbiAgICB9XG5cbiAgICAvLyB0aGlzLmRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gICAgIGxldCB4ID0gdGhpcy5wb3NbMF07XG4gICAgLy8gICAgIGxldCB5ID0gdGhpcy5wb3NbMV07XG4gICAgLy8gICAgIC8vIGNvbnN0IGtleXByZXNzID0gZXZlbnQua2V5Q29kZTtcbiAgICAvLyAgICAgLy8gY29uc29sZS5sb2coZXZlbnQpO1xuICAgIC8vICAgICBpZiAoa2V5SXNEb3duKExFRlRfQVJST1cpKSB7XG4gICAgLy8gICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnVzZXIucG9zKVxuICAgIC8vICAgICAgICAgdGhpcy51cGRhdGVQb3MoW1wieVwiLCAtNDBdKTtcbiAgICAvLyAgICAgICAgIHRoaXMucmVuZGVyKHRoaXMucG9zWzBdLCB0aGlzLnBvc1sxXSk7XG4gICAgLy8gICAgIH1cblxuICAgIC8vICAgICBpZiAoa2V5SXNEb3duKFJJR0hUX0FSUk9XKSkge1xuICAgIC8vICAgICAgICAgdGhpcy51cGRhdGVQb3MoW1wieVwiLCA0MF0pO1xuICAgIC8vICAgICAgICAgdGhpcy5yZW5kZXIodGhpcy5wb3NbMF0sIHRoaXMucG9zWzFdKTtcbiAgICAvLyAgICAgfVxuXG4gICAgLy8gICAgIGlmIChrZXlJc0Rvd24oVVBfQVJST1cpKSB7XG4gICAgLy8gICAgICAgICB0aGlzLnVwZGF0ZVBvcyhbXCJ4XCIsIC00MF0pO1xuICAgIC8vICAgICAgICAgdGhpcy5yZW5kZXIodGhpcy5wb3NbMF0sIHRoaXMucG9zWzFdKTtcbiAgICAvLyAgICAgfVxuXG4gICAgLy8gICAgIGlmIChrZXlJc0Rvd24oRE9XTl9BUlJPVykpIHtcbiAgICAvLyAgICAgICAgIHRoaXMudXBkYXRlUG9zKFtcInhcIiwgNDBdKTtcbiAgICAvLyAgICAgICAgIHRoaXMucmVuZGVyKHRoaXMucG9zWzBdLCB0aGlzLnBvc1sxXSk7XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVXNlcjtcblxuLy8gY29uc3QgQ2VsbCA9IHJlcXVpcmUoJy4vY2VsbCcpO1xuXG4vLyBmdW5jdGlvbiBVc2VyKGdyaWQpIHtcbi8vICAgICB0aGlzLnJvdyA9IDE5O1xuLy8gICAgIHRoaXMuY29sID0gMTk7XG4vLyAgICAgdGhpcy5yYWRpdXMgPSAxMDtcbi8vICAgICB0aGlzLnBvcyA9IFswLCAwXTtcbi8vICAgICB0aGlzLmdyaWQgPSBncmlkO1xuXG4vLyAgICAgY29uc3QgY29sb3JzID0gW1wibGlnaHRjb3JhbFwiLCBcIm9yYW5nZVwiLCBcIkNoYXJ0cmV1c2VcIiwgXCJkYXJrY3lhblwiLCBcImRhcmtvcmNoaWRcIl07XG4vLyAgICAgbGV0IGN1cnJlbnRDb2xvciA9IGNvbG9yc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjb2xvcnMubGVuZ3RoKV07XG5cbi8vICAgICB0aGlzLnVwZGF0ZVBvcyA9IGZ1bmN0aW9uIChwb3NDaGFuZ2UsIHByZXZQb3MpIHtcbi8vICAgICAgICAgbGV0IHByZXYgPSBwcmV2UG9zO1xuLy8gICAgICAgICBjb25zb2xlLmxvZyhcInByZXZwb3NcIilcbi8vICAgICAgICAgY29uc29sZS5sb2cocHJldilcbi8vICAgICAgICAgc3dpdGNoIChwb3NDaGFuZ2VbMF0pIHtcbi8vICAgICAgICAgICAgIGNhc2UgXCJ5XCI6XG4vLyAgICAgICAgICAgICAgICAgLy8gbGV0IHVwZGF0ZWRZID0gcHJldlsxXSArIHBvc0NoYW5nZVsxXTtcbi8vICAgICAgICAgICAgICAgICAvLyB0aGlzLnBvcyA9IFtwcmV2WzBdLCB1cGRhdGVkWV07XG4vLyAgICAgICAgICAgICAgICAgbGV0IHVwZGF0ZWRZID0gdGhpcy5wb3NbMV0gKyBwb3NDaGFuZ2VbMV07XG4vLyAgICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBbdGhpcy5wb3NbMF0sIHVwZGF0ZWRZXTtcbi8vICAgICAgICAgICAgICAgICBicmVhaztcbi8vICAgICAgICAgICAgIGNhc2UgXCJ4XCI6XG4vLyAgICAgICAgICAgICAgICAgLy8gbGV0IHVwZGF0ZWRYID0gcHJldlswXSArIHBvc0NoYW5nZVsxXTtcbi8vICAgICAgICAgICAgICAgICAvLyB0aGlzLnBvcyA9IFt1cGRhdGVkWCwgcHJldlsxXV07XG4vLyAgICAgICAgICAgICAgICAgbGV0IHVwZGF0ZWRYID0gdGhpcy5wb3NbMF0gKyBwb3NDaGFuZ2VbMV07XG4vLyAgICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBbdXBkYXRlZFgsIHRoaXMucG9zWzFdXTtcbi8vICAgICAgICAgICAgICAgICBicmVhaztcbi8vICAgICAgICAgfVxuLy8gICAgICAgICBjb25zb2xlLmxvZyhcIm5ld3Bvc1wiKVxuLy8gICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnBvcylcbi8vICAgICB9XG5cbi8vICAgICB0aGlzLmRpc3BsYXkgPSBmdW5jdGlvbigpe1xuLy8gICAgICAgICBmaWxsKGN1cnJlbnRDb2xvcik7XG4vLyAgICAgICAgIGVsbGlwc2UoKHRoaXMucG9zWzBdICsgMjApLCAodGhpcy5wb3NbMV0gKyAyMCksIDE1LCAxNSk7XG5cbi8vICAgICB9XG5cbi8vICAgICB0aGlzLnBlcnNpc3RhbnREaXNwbGF5ID0gZnVuY3Rpb24oeCwgeSl7XG4vLyAgICAgICAgIGZpbGwoY3VycmVudENvbG9yKTtcbi8vICAgICAgICAgZWxsaXBzZSgoeCArIDIwKSwgKHkgKyAyMCksIDE1LCAxNSk7XG4vLyAgICAgfVxuXG4vLyAgICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbi8vICAgICAgICAgbGV0IGN1cnJlbnRDZWxsID0gdGhpcy5ncmlkW3RoaXMucG9zWzBdXVt0aGlzLnBvc1sxXV07XG4vLyAgICAgICAgIGNvbnNvbGUubG9nKFwiY2VsbCB0byByZXJlbmRlclwiKVxuLy8gICAgICAgICBjb25zb2xlLmxvZyhjdXJyZW50Q2VsbClcbi8vICAgICAgICAgY3VycmVudENlbGwuaGFzVXNlciA9IHRydWU7XG4vLyAgICAgICAgIGN1cnJlbnRDZWxsLnJlcmVuZGVyKGN1cnJlbnRDb2xvcik7XG4vLyAgICAgICAgIHRoaXMucGVyc2lzdGFudERpc3BsYXkoKVxuLy8gICAgICAgICAvLyBjdXJyZW50Q2VsbC5kaXNwbGF5KGN1cnJlbnRDZWxsLnJvdywgY3VycmVudENlbGwuY29sKVxuLy8gICAgIH1cblxuLy8gICAgIHRoaXMuZHJhdyA9IGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgbGV0IHggPSB0aGlzLnBvc1swXTtcbi8vICAgICAgICAgbGV0IHkgPSB0aGlzLnBvc1sxXTtcbi8vICAgICAgICAgLy8gY29uc3Qga2V5cHJlc3MgPSBldmVudC5rZXlDb2RlO1xuLy8gICAgICAgICAvLyBjb25zb2xlLmxvZyhldmVudCk7XG4vLyAgICAgICAgIGlmIChrZXlJc0Rvd24oTEVGVF9BUlJPVykpIHtcbi8vICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMudXNlci5wb3MpXG4vLyAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBvcyhbXCJ5XCIsIC00MF0pO1xuLy8gICAgICAgICAgICAgdGhpcy5yZW5kZXIodGhpcy5wb3NbMF0sIHRoaXMucG9zWzFdKTtcbi8vICAgICAgICAgfVxuXG4vLyAgICAgICAgIGlmIChrZXlJc0Rvd24oUklHSFRfQVJST1cpKSB7XG4vLyAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBvcyhbXCJ5XCIsIDQwXSk7XG4vLyAgICAgICAgICAgICB0aGlzLnJlbmRlcih0aGlzLnBvc1swXSwgdGhpcy5wb3NbMV0pO1xuLy8gICAgICAgICB9XG5cbi8vICAgICAgICAgaWYgKGtleUlzRG93bihVUF9BUlJPVykpIHtcbi8vICAgICAgICAgICAgIHRoaXMudXBkYXRlUG9zKFtcInhcIiwgLTQwXSk7XG4vLyAgICAgICAgICAgICB0aGlzLnJlbmRlcih0aGlzLnBvc1swXSwgdGhpcy5wb3NbMV0pO1xuLy8gICAgICAgICB9XG5cbi8vICAgICAgICAgaWYgKGtleUlzRG93bihET1dOX0FSUk9XKSkge1xuLy8gICAgICAgICAgICAgdGhpcy51cGRhdGVQb3MoW1wieFwiLCA0MF0pO1xuLy8gICAgICAgICAgICAgdGhpcy5yZW5kZXIodGhpcy5wb3NbMF0sIHRoaXMucG9zWzFdKTtcbi8vICAgICAgICAgfVxuLy8gICAgIH1cbi8vIH1cblxuLy8gbW9kdWxlLmV4cG9ydHMgPSBVc2VyO1xuXG4vLyAvLyBmdW5jdGlvbiBVc2VyKCl7XG4vLyAvLyAgICAgdGhpcy5yb3cgPSAxOTtcbi8vIC8vICAgICB0aGlzLmNvbCA9IDE5O1xuLy8gLy8gICAgIHRoaXMucmFkaXVzID0gMTA7XG4vLyAvLyAgICAgdGhpcy5wb3MgPSBbMCwgMF1cblxuLy8gLy8gICAgIGNvbnN0IGNvbG9ycyA9IFtcImxpZ2h0Y29yYWxcIiwgXCJvcmFuZ2VcIiwgXCJDaGFydHJldXNlXCIsIFwiZGFya2N5YW5cIiwgXCJkYXJrb3JjaGlkXCJdO1xuLy8gLy8gICAgIGxldCBjdXJyZW50Q29sb3IgPSBjb2xvcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY29sb3JzLmxlbmd0aCldO1xuXG5cbi8vIC8vICAgICB0aGlzLnVwZGF0ZVBvcyA9IGZ1bmN0aW9uKHBvc0NoYW5nZSl7XG4vLyAvLyAgICAgICAgIHN3aXRjaChwb3NDaGFuZ2VbMF0pe1xuLy8gLy8gICAgICAgICAgICAgY2FzZSBcInhcIjpcbi8vIC8vICAgICAgICAgICAgICAgICBsZXQgdXBkYXRlZFggPSB0aGlzLnBvc1swXSArIHBvc0NoYW5nZVsxXTtcbi8vIC8vICAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IFt1cGRhdGVkWCwgdGhpcy5wb3NbMV1dO1xuLy8gLy8gICAgICAgICAgICAgY2FzZSBcInlcIjpcbi8vIC8vICAgICAgICAgICAgICAgICBsZXQgdXBkYXRlZFkgPSB0aGlzLnBvc1sxXSArIHBvc0NoYW5nZVsxXTtcbi8vIC8vICAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IFt0aGlzLnBvc1sxXSwgdXBkYXRlZFldOyBcbi8vIC8vICAgICAgICAgfVxuLy8gLy8gICAgIH1cblxuXG4vLyAvLyAgICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbih4LCB5KSB7XG5cbi8vIC8vICAgICAgICAgZmlsbChjdXJyZW50Q29sb3IpO1xuLy8gLy8gICAgICAgICBlbGxpcHNlKDE5LCAxOSwgMTUsIDE1KTtcbi8vIC8vICAgICB9XG4vLyAvLyB9XG5cbi8vIC8vIG1vZHVsZS5leHBvcnRzID0gVXNlcjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./user.js\n");

/***/ }),

/***/ "./wall.js":
/*!*****************!*\
  !*** ./wall.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class Wall {\n  constructor() {\n    this.present = true;\n    this.color = \"black\";\n  }\n\n  render(wallPos, x, y) {\n    stroke(\"black\");\n    strokeWeight(3);\n    switch (wallPos) {\n      case 0:\n        line(x, y, x, y + 40);\n      case 1:\n        line(x, y + 40, x + 40, y + 40);\n      case 2:\n        line(x + 40, y + 40, x + 40, y);\n      case 3:\n        line(x + 40, y, x, y);\n    }\n\n  }\n\n  derender(wallPos, x, y) {\n    stroke(\"white\");\n    switch (wallPos) {\n      case 0:\n        line(x, y, x, y + 40);\n        this.color = \"white\";\n      case 1:\n        line(x, y + 40, x + 40, y + 40);\n        this.color = \"white\";\n      case 2:\n        line(x + 40, y + 40, x + 40, y);\n        this.color = \"white\";\n      case 3:\n        line(x + 40, y, x, y);\n        this.color = \"white\";\n    }\n  }\n}\n\n// class Wall{\n//     constructor(){\n//         this.present = true;\n//     }\n\n//   render = (i, x, y) => {\n//     stroke(255);\n//     switch (i) {\n//       case 0:\n//         line(x, y, x, y + 40);\n//       case 1:\n//         line(x, y + 40, x + 40, y + 40);\n//       case 2:\n//         line(x + 40, y + 40, x + 40, y);\n//       case 3:\n//         line(x + 40, y, x, y);\n//     }\n//   };\n// }\n\nmodule.exports = Wall;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93YWxsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vd2FsbC5qcz85MDU5Il0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFdhbGwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnByZXNlbnQgPSB0cnVlO1xuICAgIHRoaXMuY29sb3IgPSBcImJsYWNrXCI7XG4gIH1cblxuICByZW5kZXIod2FsbFBvcywgeCwgeSkge1xuICAgIHN0cm9rZShcImJsYWNrXCIpO1xuICAgIHN0cm9rZVdlaWdodCgzKTtcbiAgICBzd2l0Y2ggKHdhbGxQb3MpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgbGluZSh4LCB5LCB4LCB5ICsgNDApO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBsaW5lKHgsIHkgKyA0MCwgeCArIDQwLCB5ICsgNDApO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBsaW5lKHggKyA0MCwgeSArIDQwLCB4ICsgNDAsIHkpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBsaW5lKHggKyA0MCwgeSwgeCwgeSk7XG4gICAgfVxuXG4gIH1cblxuICBkZXJlbmRlcih3YWxsUG9zLCB4LCB5KSB7XG4gICAgc3Ryb2tlKFwid2hpdGVcIik7XG4gICAgc3dpdGNoICh3YWxsUG9zKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIGxpbmUoeCwgeSwgeCwgeSArIDQwKTtcbiAgICAgICAgdGhpcy5jb2xvciA9IFwid2hpdGVcIjtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgbGluZSh4LCB5ICsgNDAsIHggKyA0MCwgeSArIDQwKTtcbiAgICAgICAgdGhpcy5jb2xvciA9IFwid2hpdGVcIjtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgbGluZSh4ICsgNDAsIHkgKyA0MCwgeCArIDQwLCB5KTtcbiAgICAgICAgdGhpcy5jb2xvciA9IFwid2hpdGVcIjtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgbGluZSh4ICsgNDAsIHksIHgsIHkpO1xuICAgICAgICB0aGlzLmNvbG9yID0gXCJ3aGl0ZVwiO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjbGFzcyBXYWxse1xuLy8gICAgIGNvbnN0cnVjdG9yKCl7XG4vLyAgICAgICAgIHRoaXMucHJlc2VudCA9IHRydWU7XG4vLyAgICAgfVxuXG4vLyAgIHJlbmRlciA9IChpLCB4LCB5KSA9PiB7XG4vLyAgICAgc3Ryb2tlKDI1NSk7XG4vLyAgICAgc3dpdGNoIChpKSB7XG4vLyAgICAgICBjYXNlIDA6XG4vLyAgICAgICAgIGxpbmUoeCwgeSwgeCwgeSArIDQwKTtcbi8vICAgICAgIGNhc2UgMTpcbi8vICAgICAgICAgbGluZSh4LCB5ICsgNDAsIHggKyA0MCwgeSArIDQwKTtcbi8vICAgICAgIGNhc2UgMjpcbi8vICAgICAgICAgbGluZSh4ICsgNDAsIHkgKyA0MCwgeCArIDQwLCB5KTtcbi8vICAgICAgIGNhc2UgMzpcbi8vICAgICAgICAgbGluZSh4ICsgNDAsIHksIHgsIHkpO1xuLy8gICAgIH1cbi8vICAgfTtcbi8vIH1cblxubW9kdWxlLmV4cG9ydHMgPSBXYWxsO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./wall.js\n");

/***/ })

/******/ });